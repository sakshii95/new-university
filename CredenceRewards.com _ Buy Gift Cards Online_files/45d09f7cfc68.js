window.Modernizr = (function (window, document, undefined) {
  var version = "2.8.3",
    Modernizr = {},
    enableClasses = true,
    docElement = document.documentElement,
    mod = "modernizr",
    modElem = document.createElement(mod),
    mStyle = modElem.style,
    inputElem = document.createElement("input"),
    smile = ":)",
    toString = {}.toString,
    prefixes = " -webkit- -moz- -o- -ms- ".split(" "),
    omPrefixes = "Webkit Moz O ms",
    cssomPrefixes = omPrefixes.split(" "),
    domPrefixes = omPrefixes.toLowerCase().split(" "),
    ns = { svg: "http://www.w3.org/2000/svg" },
    tests = {},
    inputs = {},
    attrs = {},
    classes = [],
    slice = classes.slice,
    featureName,
    injectElementWithStyles = function (rule, callback, nodes, testnames) {
      var style,
        ret,
        node,
        docOverflow,
        div = document.createElement("div"),
        body = document.body,
        fakeBody = body || document.createElement("body");
      if (parseInt(nodes, 10)) {
        while (nodes--) {
          node = document.createElement("div");
          node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
          div.appendChild(node);
        }
      }
      style = ["&#173;", '<style id="s', mod, '">', rule, "</style>"].join("");
      div.id = mod;
      (body ? div : fakeBody).innerHTML += style;
      fakeBody.appendChild(div);
      if (!body) {
        fakeBody.style.background = "";
        fakeBody.style.overflow = "hidden";
        docOverflow = docElement.style.overflow;
        docElement.style.overflow = "hidden";
        docElement.appendChild(fakeBody);
      }
      ret = callback(div, rule);
      if (!body) {
        fakeBody.parentNode.removeChild(fakeBody);
        docElement.style.overflow = docOverflow;
      } else {
        div.parentNode.removeChild(div);
      }
      return !!ret;
    },
    testMediaQuery = function (mq) {
      var matchMedia = window.matchMedia || window.msMatchMedia;
      if (matchMedia) {
        return (matchMedia(mq) && matchMedia(mq).matches) || false;
      }
      var bool;
      injectElementWithStyles(
        "@media " + mq + " { #" + mod + " { position: absolute; } }",
        function (node) {
          bool =
            (window.getComputedStyle
              ? getComputedStyle(node, null)
              : node.currentStyle)["position"] == "absolute";
        }
      );
      return bool;
    },
    isEventSupported = (function () {
      var TAGNAMES = {
        select: "input",
        change: "input",
        submit: "form",
        reset: "form",
        error: "img",
        load: "img",
        abort: "img",
      };
      function isEventSupported(eventName, element) {
        element =
          element || document.createElement(TAGNAMES[eventName] || "div");
        eventName = "on" + eventName;
        var isSupported = eventName in element;
        if (!isSupported) {
          if (!element.setAttribute) {
            element = document.createElement("div");
          }
          if (element.setAttribute && element.removeAttribute) {
            element.setAttribute(eventName, "");
            isSupported = is(element[eventName], "function");
            if (!is(element[eventName], "undefined")) {
              element[eventName] = undefined;
            }
            element.removeAttribute(eventName);
          }
        }
        element = null;
        return isSupported;
      }
      return isEventSupported;
    })(),
    _hasOwnProperty = {}.hasOwnProperty,
    hasOwnProp;
  if (
    !is(_hasOwnProperty, "undefined") &&
    !is(_hasOwnProperty.call, "undefined")
  ) {
    hasOwnProp = function (object, property) {
      return _hasOwnProperty.call(object, property);
    };
  } else {
    hasOwnProp = function (object, property) {
      return (
        property in object &&
        is(object.constructor.prototype[property], "undefined")
      );
    };
  }
  if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) {
      var target = this;
      if (typeof target != "function") {
        throw new TypeError();
      }
      var args = slice.call(arguments, 1),
        bound = function () {
          if (this instanceof bound) {
            var F = function () {};
            F.prototype = target.prototype;
            var self = new F();
            var result = target.apply(self, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return self;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
      return bound;
    };
  }
  function setCss(str) {
    mStyle.cssText = str;
  }
  function setCssAll(str1, str2) {
    return setCss(prefixes.join(str1 + ";") + (str2 || ""));
  }
  function is(obj, type) {
    return typeof obj === type;
  }
  function contains(str, substr) {
    return !!~("" + str).indexOf(substr);
  }
  function testProps(props, prefixed) {
    for (var i in props) {
      var prop = props[i];
      if (!contains(prop, "-") && mStyle[prop] !== undefined) {
        return prefixed == "pfx" ? prop : true;
      }
    }
    return false;
  }
  function testDOMProps(props, obj, elem) {
    for (var i in props) {
      var item = obj[props[i]];
      if (item !== undefined) {
        if (elem === false) return props[i];
        if (is(item, "function")) {
          return item.bind(elem || obj);
        }
        return item;
      }
    }
    return false;
  }
  function testPropsAll(prop, prefixed, elem) {
    var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
      props = (prop + " " + cssomPrefixes.join(ucProp + " ") + ucProp).split(
        " "
      );
    if (is(prefixed, "string") || is(prefixed, "undefined")) {
      return testProps(props, prefixed);
    } else {
      props = (prop + " " + domPrefixes.join(ucProp + " ") + ucProp).split(" ");
      return testDOMProps(props, prefixed, elem);
    }
  }
  tests["flexbox"] = function () {
    return testPropsAll("flexWrap");
  };
  tests["flexboxlegacy"] = function () {
    return testPropsAll("boxDirection");
  };
  tests["canvas"] = function () {
    var elem = document.createElement("canvas");
    return !!(elem.getContext && elem.getContext("2d"));
  };
  tests["canvastext"] = function () {
    return !!(
      Modernizr["canvas"] &&
      is(document.createElement("canvas").getContext("2d").fillText, "function")
    );
  };
  tests["webgl"] = function () {
    return !!window.WebGLRenderingContext;
  };
  tests["touch"] = function () {
    var bool;
    if (
      "ontouchstart" in window ||
      (window.DocumentTouch && document instanceof DocumentTouch)
    ) {
      bool = true;
    } else {
      injectElementWithStyles(
        [
          "@media (",
          prefixes.join("touch-enabled),("),
          mod,
          ")",
          "{#modernizr{top:9px;position:absolute}}",
        ].join(""),
        function (node) {
          bool = node.offsetTop === 9;
        }
      );
    }
    return bool;
  };
  tests["geolocation"] = function () {
    return "geolocation" in navigator;
  };
  tests["postmessage"] = function () {
    return !!window.postMessage;
  };
  tests["websqldatabase"] = function () {
    return !!window.openDatabase;
  };
  tests["indexedDB"] = function () {
    return !!testPropsAll("indexedDB", window);
  };
  tests["hashchange"] = function () {
    return (
      isEventSupported("hashchange", window) &&
      (document.documentMode === undefined || document.documentMode > 7)
    );
  };
  tests["history"] = function () {
    return !!(window.history && history.pushState);
  };
  tests["draganddrop"] = function () {
    var div = document.createElement("div");
    return "draggable" in div || ("ondragstart" in div && "ondrop" in div);
  };
  tests["websockets"] = function () {
    return "WebSocket" in window || "MozWebSocket" in window;
  };
  tests["rgba"] = function () {
    setCss("background-color:rgba(150,255,150,.5)");
    return contains(mStyle.backgroundColor, "rgba");
  };
  tests["hsla"] = function () {
    setCss("background-color:hsla(120,40%,100%,.5)");
    return (
      contains(mStyle.backgroundColor, "rgba") ||
      contains(mStyle.backgroundColor, "hsla")
    );
  };
  tests["multiplebgs"] = function () {
    setCss("background:url(https://),url(https://),red url(https://)");
    return /(url\s*\(.*?){3}/.test(mStyle.background);
  };
  tests["backgroundsize"] = function () {
    return testPropsAll("backgroundSize");
  };
  tests["borderimage"] = function () {
    return testPropsAll("borderImage");
  };
  tests["borderradius"] = function () {
    return testPropsAll("borderRadius");
  };
  tests["boxshadow"] = function () {
    return testPropsAll("boxShadow");
  };
  tests["textshadow"] = function () {
    return document.createElement("div").style.textShadow === "";
  };
  tests["opacity"] = function () {
    setCssAll("opacity:.55");
    return /^0.55$/.test(mStyle.opacity);
  };
  tests["cssanimations"] = function () {
    return testPropsAll("animationName");
  };
  tests["csscolumns"] = function () {
    return testPropsAll("columnCount");
  };
  tests["cssgradients"] = function () {
    var str1 = "background-image:",
      str2 = "gradient(linear,left top,right bottom,from(#9f9),to(white));",
      str3 = "linear-gradient(left top,#9f9, white);";
    setCss(
      (
        str1 +
        "-webkit- ".split(" ").join(str2 + str1) +
        prefixes.join(str3 + str1)
      ).slice(0, -str1.length)
    );
    return contains(mStyle.backgroundImage, "gradient");
  };
  tests["cssreflections"] = function () {
    return testPropsAll("boxReflect");
  };
  tests["csstransforms"] = function () {
    return !!testPropsAll("transform");
  };
  tests["csstransforms3d"] = function () {
    var ret = !!testPropsAll("perspective");
    if (ret && "webkitPerspective" in docElement.style) {
      injectElementWithStyles(
        "@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",
        function (node, rule) {
          ret = node.offsetLeft === 9 && node.offsetHeight === 3;
        }
      );
    }
    return ret;
  };
  tests["csstransitions"] = function () {
    return testPropsAll("transition");
  };
  tests["fontface"] = function () {
    var bool;
    injectElementWithStyles(
      '@font-face {font-family:"font";src:url("https://")}',
      function (node, rule) {
        var style = document.getElementById("smodernizr"),
          sheet = style.sheet || style.styleSheet,
          cssText = sheet
            ? sheet.cssRules && sheet.cssRules[0]
              ? sheet.cssRules[0].cssText
              : sheet.cssText || ""
            : "";
        bool =
          /src/i.test(cssText) && cssText.indexOf(rule.split(" ")[0]) === 0;
      }
    );
    return bool;
  };
  tests["generatedcontent"] = function () {
    var bool;
    injectElementWithStyles(
      [
        "#",
        mod,
        "{font:0/0 a}#",
        mod,
        ':after{content:"',
        smile,
        '";visibility:hidden;font:3px/1 a}',
      ].join(""),
      function (node) {
        bool = node.offsetHeight >= 3;
      }
    );
    return bool;
  };
  tests["video"] = function () {
    var elem = document.createElement("video"),
      bool = false;
    try {
      if ((bool = !!elem.canPlayType)) {
        bool = new Boolean(bool);
        bool.ogg = elem
          .canPlayType('video/ogg; codecs="theora"')
          .replace(/^no$/, "");
        bool.h264 = elem
          .canPlayType('video/mp4; codecs="avc1.42E01E"')
          .replace(/^no$/, "");
        bool.webm = elem
          .canPlayType('video/webm; codecs="vp8, vorbis"')
          .replace(/^no$/, "");
      }
    } catch (e) {}
    return bool;
  };
  tests["audio"] = function () {
    var elem = document.createElement("audio"),
      bool = false;
    try {
      if ((bool = !!elem.canPlayType)) {
        bool = new Boolean(bool);
        bool.ogg = elem
          .canPlayType('audio/ogg; codecs="vorbis"')
          .replace(/^no$/, "");
        bool.mp3 = elem.canPlayType("audio/mpeg;").replace(/^no$/, "");
        bool.wav = elem
          .canPlayType('audio/wav; codecs="1"')
          .replace(/^no$/, "");
        bool.m4a = (
          elem.canPlayType("audio/x-m4a;") || elem.canPlayType("audio/aac;")
        ).replace(/^no$/, "");
      }
    } catch (e) {}
    return bool;
  };
  tests["localstorage"] = function () {
    try {
      localStorage.setItem(mod, mod);
      localStorage.removeItem(mod);
      return true;
    } catch (e) {
      return false;
    }
  };
  tests["sessionstorage"] = function () {
    try {
      sessionStorage.setItem(mod, mod);
      sessionStorage.removeItem(mod);
      return true;
    } catch (e) {
      return false;
    }
  };
  tests["webworkers"] = function () {
    return !!window.Worker;
  };
  tests["applicationcache"] = function () {
    return !!window.applicationCache;
  };
  tests["svg"] = function () {
    return (
      !!document.createElementNS &&
      !!document.createElementNS(ns.svg, "svg").createSVGRect
    );
  };
  tests["inlinesvg"] = function () {
    var div = document.createElement("div");
    div.innerHTML = "<svg/>";
    return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
  };
  tests["smil"] = function () {
    return (
      !!document.createElementNS &&
      /SVGAnimate/.test(
        toString.call(document.createElementNS(ns.svg, "animate"))
      )
    );
  };
  tests["svgclippaths"] = function () {
    return (
      !!document.createElementNS &&
      /SVGClipPath/.test(
        toString.call(document.createElementNS(ns.svg, "clipPath"))
      )
    );
  };
  function webforms() {
    Modernizr["input"] = (function (props) {
      for (var i = 0, len = props.length; i < len; i++) {
        attrs[props[i]] = !!(props[i] in inputElem);
      }
      if (attrs.list) {
        attrs.list = !!(
          document.createElement("datalist") && window.HTMLDataListElement
        );
      }
      return attrs;
    })(
      "autocomplete autofocus list placeholder max min multiple pattern required step".split(
        " "
      )
    );
    Modernizr["inputtypes"] = (function (props) {
      for (
        var i = 0, bool, inputElemType, defaultView, len = props.length;
        i < len;
        i++
      ) {
        inputElem.setAttribute("type", (inputElemType = props[i]));
        bool = inputElem.type !== "text";
        if (bool) {
          inputElem.value = smile;
          inputElem.style.cssText = "position:absolute;visibility:hidden;";
          if (
            /^range$/.test(inputElemType) &&
            inputElem.style.WebkitAppearance !== undefined
          ) {
            docElement.appendChild(inputElem);
            defaultView = document.defaultView;
            bool =
              defaultView.getComputedStyle &&
              defaultView.getComputedStyle(inputElem, null).WebkitAppearance !==
                "textfield" &&
              inputElem.offsetHeight !== 0;
            docElement.removeChild(inputElem);
          } else if (/^(search|tel)$/.test(inputElemType)) {
          } else if (/^(url|email)$/.test(inputElemType)) {
            bool =
              inputElem.checkValidity && inputElem.checkValidity() === false;
          } else {
            bool = inputElem.value != smile;
          }
        }
        inputs[props[i]] = !!bool;
      }
      return inputs;
    })(
      "search tel url email datetime date month week time datetime-local number range color".split(
        " "
      )
    );
  }
  for (var feature in tests) {
    if (hasOwnProp(tests, feature)) {
      featureName = feature.toLowerCase();
      Modernizr[featureName] = tests[feature]();
      classes.push((Modernizr[featureName] ? "" : "no-") + featureName);
    }
  }
  Modernizr.input || webforms();
  Modernizr.addTest = function (feature, test) {
    if (typeof feature == "object") {
      for (var key in feature) {
        if (hasOwnProp(feature, key)) {
          Modernizr.addTest(key, feature[key]);
        }
      }
    } else {
      feature = feature.toLowerCase();
      if (Modernizr[feature] !== undefined) {
        return Modernizr;
      }
      test = typeof test == "function" ? test() : test;
      if (typeof enableClasses !== "undefined" && enableClasses) {
        docElement.className += " " + (test ? "" : "no-") + feature;
      }
      Modernizr[feature] = test;
    }
    return Modernizr;
  };
  setCss("");
  modElem = inputElem = null;
  (function (window, document) {
    var version = "3.7.0";
    var options = window.html5 || {};
    var reSkip =
      /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;
    var saveClones =
      /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;
    var supportsHtml5Styles;
    var expando = "_html5shiv";
    var expanID = 0;
    var expandoData = {};
    var supportsUnknownElements;
    (function () {
      try {
        var a = document.createElement("a");
        a.innerHTML = "<xyz></xyz>";
        supportsHtml5Styles = "hidden" in a;
        supportsUnknownElements =
          a.childNodes.length == 1 ||
          (function () {
            document.createElement("a");
            var frag = document.createDocumentFragment();
            return (
              typeof frag.cloneNode == "undefined" ||
              typeof frag.createDocumentFragment == "undefined" ||
              typeof frag.createElement == "undefined"
            );
          })();
      } catch (e) {
        supportsHtml5Styles = true;
        supportsUnknownElements = true;
      }
    })();
    function addStyleSheet(ownerDocument, cssText) {
      var p = ownerDocument.createElement("p"),
        parent =
          ownerDocument.getElementsByTagName("head")[0] ||
          ownerDocument.documentElement;
      p.innerHTML = "x<style>" + cssText + "</style>";
      return parent.insertBefore(p.lastChild, parent.firstChild);
    }
    function getElements() {
      var elements = html5.elements;
      return typeof elements == "string" ? elements.split(" ") : elements;
    }
    function getExpandoData(ownerDocument) {
      var data = expandoData[ownerDocument[expando]];
      if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
      }
      return data;
    }
    function createElement(nodeName, ownerDocument, data) {
      if (!ownerDocument) {
        ownerDocument = document;
      }
      if (supportsUnknownElements) {
        return ownerDocument.createElement(nodeName);
      }
      if (!data) {
        data = getExpandoData(ownerDocument);
      }
      var node;
      if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
      } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
      } else {
        node = data.createElem(nodeName);
      }
      return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn
        ? data.frag.appendChild(node)
        : node;
    }
    function createDocumentFragment(ownerDocument, data) {
      if (!ownerDocument) {
        ownerDocument = document;
      }
      if (supportsUnknownElements) {
        return ownerDocument.createDocumentFragment();
      }
      data = data || getExpandoData(ownerDocument);
      var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
      for (; i < l; i++) {
        clone.createElement(elems[i]);
      }
      return clone;
    }
    function shivMethods(ownerDocument, data) {
      if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
      }
      ownerDocument.createElement = function (nodeName) {
        if (!html5.shivMethods) {
          return data.createElem(nodeName);
        }
        return createElement(nodeName, ownerDocument, data);
      };
      ownerDocument.createDocumentFragment = Function(
        "h,f",
        "return function(){" +
          "var n=f.cloneNode(),c=n.createElement;" +
          "h.shivMethods&&(" +
          getElements()
            .join()
            .replace(/[\w\-]+/g, function (nodeName) {
              data.createElem(nodeName);
              data.frag.createElement(nodeName);
              return 'c("' + nodeName + '")';
            }) +
          ");return n}"
      )(html5, data.frag);
    }
    function shivDocument(ownerDocument) {
      if (!ownerDocument) {
        ownerDocument = document;
      }
      var data = getExpandoData(ownerDocument);
      if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
        data.hasCSS = !!addStyleSheet(
          ownerDocument,
          "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}" +
            "mark{background:#FF0;color:#000}" +
            "template{display:none}"
        );
      }
      if (!supportsUnknownElements) {
        shivMethods(ownerDocument, data);
      }
      return ownerDocument;
    }
    var html5 = {
      elements:
        options.elements ||
        "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",
      version: version,
      shivCSS: options.shivCSS !== false,
      supportsUnknownElements: supportsUnknownElements,
      shivMethods: options.shivMethods !== false,
      type: "default",
      shivDocument: shivDocument,
      createElement: createElement,
      createDocumentFragment: createDocumentFragment,
    };
    window.html5 = html5;
    shivDocument(document);
  })(this, document);
  Modernizr._version = version;
  Modernizr._prefixes = prefixes;
  Modernizr._domPrefixes = domPrefixes;
  Modernizr._cssomPrefixes = cssomPrefixes;
  Modernizr.mq = testMediaQuery;
  Modernizr.hasEvent = isEventSupported;
  Modernizr.testProp = function (prop) {
    return testProps([prop]);
  };
  Modernizr.testAllProps = testPropsAll;
  Modernizr.testStyles = injectElementWithStyles;
  Modernizr.prefixed = function (prop, obj, elem) {
    if (!obj) {
      return testPropsAll(prop, "pfx");
    } else {
      return testPropsAll(prop, obj, elem);
    }
  };
  docElement.className =
    docElement.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") +
    (enableClasses ? " js " + classes.join(" ") : "");
  return Modernizr;
})(this, this.document);
if ("undefined" == typeof jQuery)
  throw new Error("Bootstrap's JavaScript requires jQuery");
+(function (a) {
  "use strict";
  var b = a.fn.jquery.split(" ")[0].split(".");
  if (
    (b[0] < 2 && b[1] < 9) ||
    (1 == b[0] && 9 == b[1] && b[2] < 1) ||
    b[0] > 3
  )
    throw new Error(
      "Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4"
    );
})(jQuery),
  +(function (a) {
    "use strict";
    function b() {
      var a = document.createElement("bootstrap"),
        b = {
          WebkitTransition: "webkitTransitionEnd",
          MozTransition: "transitionend",
          OTransition: "oTransitionEnd otransitionend",
          transition: "transitionend",
        };
      for (var c in b) if (void 0 !== a.style[c]) return { end: b[c] };
      return !1;
    }
    (a.fn.emulateTransitionEnd = function (b) {
      var c = !1,
        d = this;
      a(this).one("bsTransitionEnd", function () {
        c = !0;
      });
      var e = function () {
        c || a(d).trigger(a.support.transition.end);
      };
      return setTimeout(e, b), this;
    }),
      a(function () {
        (a.support.transition = b()),
          a.support.transition &&
            (a.event.special.bsTransitionEnd = {
              bindType: a.support.transition.end,
              delegateType: a.support.transition.end,
              handle: function (b) {
                if (a(b.target).is(this))
                  return b.handleObj.handler.apply(this, arguments);
              },
            });
      });
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      return this.each(function () {
        var c = a(this),
          e = c.data("bs.alert");
        e || c.data("bs.alert", (e = new d(this))),
          "string" == typeof b && e[b].call(c);
      });
    }
    var c = '[data-dismiss="alert"]',
      d = function (b) {
        a(b).on("click", c, this.close);
      };
    (d.VERSION = "3.3.7"),
      (d.TRANSITION_DURATION = 150),
      (d.prototype.close = function (b) {
        function c() {
          g.detach().trigger("closed.bs.alert").remove();
        }
        var e = a(this),
          f = e.attr("data-target");
        f || ((f = e.attr("href")), (f = f && f.replace(/.*(?=#[^\s]*$)/, "")));
        var g = a("#" === f ? [] : f);
        b && b.preventDefault(),
          g.length || (g = e.closest(".alert")),
          g.trigger((b = a.Event("close.bs.alert"))),
          b.isDefaultPrevented() ||
            (g.removeClass("in"),
            a.support.transition && g.hasClass("fade")
              ? g
                  .one("bsTransitionEnd", c)
                  .emulateTransitionEnd(d.TRANSITION_DURATION)
              : c());
      });
    var e = a.fn.alert;
    (a.fn.alert = b),
      (a.fn.alert.Constructor = d),
      (a.fn.alert.noConflict = function () {
        return (a.fn.alert = e), this;
      }),
      a(document).on("click.bs.alert.data-api", c, d.prototype.close);
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      return this.each(function () {
        var d = a(this),
          e = d.data("bs.button"),
          f = "object" == typeof b && b;
        e || d.data("bs.button", (e = new c(this, f))),
          "toggle" == b ? e.toggle() : b && e.setState(b);
      });
    }
    var c = function (b, d) {
      (this.$element = a(b)),
        (this.options = a.extend({}, c.DEFAULTS, d)),
        (this.isLoading = !1);
    };
    (c.VERSION = "3.3.7"),
      (c.DEFAULTS = { loadingText: "loading..." }),
      (c.prototype.setState = function (b) {
        var c = "disabled",
          d = this.$element,
          e = d.is("input") ? "val" : "html",
          f = d.data();
        (b += "Text"),
          null == f.resetText && d.data("resetText", d[e]()),
          setTimeout(
            a.proxy(function () {
              d[e](null == f[b] ? this.options[b] : f[b]),
                "loadingText" == b
                  ? ((this.isLoading = !0),
                    d.addClass(c).attr(c, c).prop(c, !0))
                  : this.isLoading &&
                    ((this.isLoading = !1),
                    d.removeClass(c).removeAttr(c).prop(c, !1));
            }, this),
            0
          );
      }),
      (c.prototype.toggle = function () {
        var a = !0,
          b = this.$element.closest('[data-toggle="buttons"]');
        if (b.length) {
          var c = this.$element.find("input");
          "radio" == c.prop("type")
            ? (c.prop("checked") && (a = !1),
              b.find(".active").removeClass("active"),
              this.$element.addClass("active"))
            : "checkbox" == c.prop("type") &&
              (c.prop("checked") !== this.$element.hasClass("active") &&
                (a = !1),
              this.$element.toggleClass("active")),
            c.prop("checked", this.$element.hasClass("active")),
            a && c.trigger("change");
        } else
          this.$element.attr("aria-pressed", !this.$element.hasClass("active")),
            this.$element.toggleClass("active");
      });
    var d = a.fn.button;
    (a.fn.button = b),
      (a.fn.button.Constructor = c),
      (a.fn.button.noConflict = function () {
        return (a.fn.button = d), this;
      }),
      a(document)
        .on(
          "click.bs.button.data-api",
          '[data-toggle^="button"]',
          function (c) {
            var d = a(c.target).closest(".btn");
            b.call(d, "toggle"),
              a(c.target).is('input[type="radio"], input[type="checkbox"]') ||
                (c.preventDefault(),
                d.is("input,button")
                  ? d.trigger("focus")
                  : d
                      .find("input:visible,button:visible")
                      .first()
                      .trigger("focus"));
          }
        )
        .on(
          "focus.bs.button.data-api blur.bs.button.data-api",
          '[data-toggle^="button"]',
          function (b) {
            a(b.target)
              .closest(".btn")
              .toggleClass("focus", /^focus(in)?$/.test(b.type));
          }
        );
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      return this.each(function () {
        var d = a(this),
          e = d.data("bs.carousel"),
          f = a.extend({}, c.DEFAULTS, d.data(), "object" == typeof b && b),
          g = "string" == typeof b ? b : f.slide;
        e || d.data("bs.carousel", (e = new c(this, f))),
          "number" == typeof b
            ? e.to(b)
            : g
            ? e[g]()
            : f.interval && e.pause().cycle();
      });
    }
    var c = function (b, c) {
      (this.$element = a(b)),
        (this.$indicators = this.$element.find(".carousel-indicators")),
        (this.options = c),
        (this.paused = null),
        (this.sliding = null),
        (this.interval = null),
        (this.$active = null),
        (this.$items = null),
        this.options.keyboard &&
          this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)),
        "hover" == this.options.pause &&
          !("ontouchstart" in document.documentElement) &&
          this.$element
            .on("mouseenter.bs.carousel", a.proxy(this.pause, this))
            .on("mouseleave.bs.carousel", a.proxy(this.cycle, this));
    };
    (c.VERSION = "3.3.7"),
      (c.TRANSITION_DURATION = 600),
      (c.DEFAULTS = { interval: 5e3, pause: "hover", wrap: !0, keyboard: !0 }),
      (c.prototype.keydown = function (a) {
        if (!/input|textarea/i.test(a.target.tagName)) {
          switch (a.which) {
            case 37:
              this.prev();
              break;
            case 39:
              this.next();
              break;
            default:
              return;
          }
          a.preventDefault();
        }
      }),
      (c.prototype.cycle = function (b) {
        return (
          b || (this.paused = !1),
          this.interval && clearInterval(this.interval),
          this.options.interval &&
            !this.paused &&
            (this.interval = setInterval(
              a.proxy(this.next, this),
              this.options.interval
            )),
          this
        );
      }),
      (c.prototype.getItemIndex = function (a) {
        return (
          (this.$items = a.parent().children(".item")),
          this.$items.index(a || this.$active)
        );
      }),
      (c.prototype.getItemForDirection = function (a, b) {
        var c = this.getItemIndex(b),
          d =
            ("prev" == a && 0 === c) ||
            ("next" == a && c == this.$items.length - 1);
        if (d && !this.options.wrap) return b;
        var e = "prev" == a ? -1 : 1,
          f = (c + e) % this.$items.length;
        return this.$items.eq(f);
      }),
      (c.prototype.to = function (a) {
        var b = this,
          c = this.getItemIndex(
            (this.$active = this.$element.find(".item.active"))
          );
        if (!(a > this.$items.length - 1 || a < 0))
          return this.sliding
            ? this.$element.one("slid.bs.carousel", function () {
                b.to(a);
              })
            : c == a
            ? this.pause().cycle()
            : this.slide(a > c ? "next" : "prev", this.$items.eq(a));
      }),
      (c.prototype.pause = function (b) {
        return (
          b || (this.paused = !0),
          this.$element.find(".next, .prev").length &&
            a.support.transition &&
            (this.$element.trigger(a.support.transition.end), this.cycle(!0)),
          (this.interval = clearInterval(this.interval)),
          this
        );
      }),
      (c.prototype.next = function () {
        if (!this.sliding) return this.slide("next");
      }),
      (c.prototype.prev = function () {
        if (!this.sliding) return this.slide("prev");
      }),
      (c.prototype.slide = function (b, d) {
        var e = this.$element.find(".item.active"),
          f = d || this.getItemForDirection(b, e),
          g = this.interval,
          h = "next" == b ? "left" : "right",
          i = this;
        if (f.hasClass("active")) return (this.sliding = !1);
        var j = f[0],
          k = a.Event("slide.bs.carousel", { relatedTarget: j, direction: h });
        if ((this.$element.trigger(k), !k.isDefaultPrevented())) {
          if (
            ((this.sliding = !0), g && this.pause(), this.$indicators.length)
          ) {
            this.$indicators.find(".active").removeClass("active");
            var l = a(this.$indicators.children()[this.getItemIndex(f)]);
            l && l.addClass("active");
          }
          var m = a.Event("slid.bs.carousel", {
            relatedTarget: j,
            direction: h,
          });
          return (
            a.support.transition && this.$element.hasClass("slide")
              ? (f.addClass(b),
                f[0].offsetWidth,
                e.addClass(h),
                f.addClass(h),
                e
                  .one("bsTransitionEnd", function () {
                    f.removeClass([b, h].join(" ")).addClass("active"),
                      e.removeClass(["active", h].join(" ")),
                      (i.sliding = !1),
                      setTimeout(function () {
                        i.$element.trigger(m);
                      }, 0);
                  })
                  .emulateTransitionEnd(c.TRANSITION_DURATION))
              : (e.removeClass("active"),
                f.addClass("active"),
                (this.sliding = !1),
                this.$element.trigger(m)),
            g && this.cycle(),
            this
          );
        }
      });
    var d = a.fn.carousel;
    (a.fn.carousel = b),
      (a.fn.carousel.Constructor = c),
      (a.fn.carousel.noConflict = function () {
        return (a.fn.carousel = d), this;
      });
    var e = function (c) {
      var d,
        e = a(this),
        f = a(
          e.attr("data-target") ||
            ((d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, ""))
        );
      if (f.hasClass("carousel")) {
        var g = a.extend({}, f.data(), e.data()),
          h = e.attr("data-slide-to");
        h && (g.interval = !1),
          b.call(f, g),
          h && f.data("bs.carousel").to(h),
          c.preventDefault();
      }
    };
    a(document)
      .on("click.bs.carousel.data-api", "[data-slide]", e)
      .on("click.bs.carousel.data-api", "[data-slide-to]", e),
      a(window).on("load", function () {
        a('[data-ride="carousel"]').each(function () {
          var c = a(this);
          b.call(c, c.data());
        });
      });
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      var c,
        d =
          b.attr("data-target") ||
          ((c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, ""));
      return a(d);
    }
    function c(b) {
      return this.each(function () {
        var c = a(this),
          e = c.data("bs.collapse"),
          f = a.extend({}, d.DEFAULTS, c.data(), "object" == typeof b && b);
        !e && f.toggle && /show|hide/.test(b) && (f.toggle = !1),
          e || c.data("bs.collapse", (e = new d(this, f))),
          "string" == typeof b && e[b]();
      });
    }
    var d = function (b, c) {
      (this.$element = a(b)),
        (this.options = a.extend({}, d.DEFAULTS, c)),
        (this.$trigger = a(
          '[data-toggle="collapse"][href="#' +
            b.id +
            '"],[data-toggle="collapse"][data-target="#' +
            b.id +
            '"]'
        )),
        (this.transitioning = null),
        this.options.parent
          ? (this.$parent = this.getParent())
          : this.addAriaAndCollapsedClass(this.$element, this.$trigger),
        this.options.toggle && this.toggle();
    };
    (d.VERSION = "3.3.7"),
      (d.TRANSITION_DURATION = 350),
      (d.DEFAULTS = { toggle: !0 }),
      (d.prototype.dimension = function () {
        var a = this.$element.hasClass("width");
        return a ? "width" : "height";
      }),
      (d.prototype.show = function () {
        if (!this.transitioning && !this.$element.hasClass("in")) {
          var b,
            e =
              this.$parent &&
              this.$parent.children(".panel").children(".in, .collapsing");
          if (
            !(
              e &&
              e.length &&
              ((b = e.data("bs.collapse")), b && b.transitioning)
            )
          ) {
            var f = a.Event("show.bs.collapse");
            if ((this.$element.trigger(f), !f.isDefaultPrevented())) {
              e &&
                e.length &&
                (c.call(e, "hide"), b || e.data("bs.collapse", null));
              var g = this.dimension();
              this.$element
                .removeClass("collapse")
                .addClass("collapsing")
                [g](0)
                .attr("aria-expanded", !0),
                this.$trigger
                  .removeClass("collapsed")
                  .attr("aria-expanded", !0),
                (this.transitioning = 1);
              var h = function () {
                this.$element
                  .removeClass("collapsing")
                  .addClass("collapse in")
                  [g](""),
                  (this.transitioning = 0),
                  this.$element.trigger("shown.bs.collapse");
              };
              if (!a.support.transition) return h.call(this);
              var i = a.camelCase(["scroll", g].join("-"));
              this.$element
                .one("bsTransitionEnd", a.proxy(h, this))
                .emulateTransitionEnd(d.TRANSITION_DURATION)
                [g](this.$element[0][i]);
            }
          }
        }
      }),
      (d.prototype.hide = function () {
        if (!this.transitioning && this.$element.hasClass("in")) {
          var b = a.Event("hide.bs.collapse");
          if ((this.$element.trigger(b), !b.isDefaultPrevented())) {
            var c = this.dimension();
            this.$element[c](this.$element[c]())[0].offsetHeight,
              this.$element
                .addClass("collapsing")
                .removeClass("collapse in")
                .attr("aria-expanded", !1),
              this.$trigger.addClass("collapsed").attr("aria-expanded", !1),
              (this.transitioning = 1);
            var e = function () {
              (this.transitioning = 0),
                this.$element
                  .removeClass("collapsing")
                  .addClass("collapse")
                  .trigger("hidden.bs.collapse");
            };
            return a.support.transition
              ? void this.$element[c](0)
                  .one("bsTransitionEnd", a.proxy(e, this))
                  .emulateTransitionEnd(d.TRANSITION_DURATION)
              : e.call(this);
          }
        }
      }),
      (d.prototype.toggle = function () {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
      }),
      (d.prototype.getParent = function () {
        return a(this.options.parent)
          .find(
            '[data-toggle="collapse"][data-parent="' +
              this.options.parent +
              '"]'
          )
          .each(
            a.proxy(function (c, d) {
              var e = a(d);
              this.addAriaAndCollapsedClass(b(e), e);
            }, this)
          )
          .end();
      }),
      (d.prototype.addAriaAndCollapsedClass = function (a, b) {
        var c = a.hasClass("in");
        a.attr("aria-expanded", c),
          b.toggleClass("collapsed", !c).attr("aria-expanded", c);
      });
    var e = a.fn.collapse;
    (a.fn.collapse = c),
      (a.fn.collapse.Constructor = d),
      (a.fn.collapse.noConflict = function () {
        return (a.fn.collapse = e), this;
      }),
      a(document).on(
        "click.bs.collapse.data-api",
        '[data-toggle="collapse"]',
        function (d) {
          var e = a(this);
          e.attr("data-target") || d.preventDefault();
          var f = b(e),
            g = f.data("bs.collapse"),
            h = g ? "toggle" : e.data();
          c.call(f, h);
        }
      );
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      var c = b.attr("data-target");
      c ||
        ((c = b.attr("href")),
        (c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, "")));
      var d = c && a(c);
      return d && d.length ? d : b.parent();
    }
    function c(c) {
      (c && 3 === c.which) ||
        (a(e).remove(),
        a(f).each(function () {
          var d = a(this),
            e = b(d),
            f = { relatedTarget: this };
          e.hasClass("open") &&
            ((c &&
              "click" == c.type &&
              /input|textarea/i.test(c.target.tagName) &&
              a.contains(e[0], c.target)) ||
              (e.trigger((c = a.Event("hide.bs.dropdown", f))),
              c.isDefaultPrevented() ||
                (d.attr("aria-expanded", "false"),
                e
                  .removeClass("open")
                  .trigger(a.Event("hidden.bs.dropdown", f)))));
        }));
    }
    function d(b) {
      return this.each(function () {
        var c = a(this),
          d = c.data("bs.dropdown");
        d || c.data("bs.dropdown", (d = new g(this))),
          "string" == typeof b && d[b].call(c);
      });
    }
    var e = ".dropdown-backdrop",
      f = '[data-toggle="dropdown"]',
      g = function (b) {
        a(b).on("click.bs.dropdown", this.toggle);
      };
    (g.VERSION = "3.3.7"),
      (g.prototype.toggle = function (d) {
        var e = a(this);
        if (!e.is(".disabled, :disabled")) {
          var f = b(e),
            g = f.hasClass("open");
          if ((c(), !g)) {
            "ontouchstart" in document.documentElement &&
              !f.closest(".navbar-nav").length &&
              a(document.createElement("div"))
                .addClass("dropdown-backdrop")
                .insertAfter(a(this))
                .on("click", c);
            var h = { relatedTarget: this };
            if (
              (f.trigger((d = a.Event("show.bs.dropdown", h))),
              d.isDefaultPrevented())
            )
              return;
            e.trigger("focus").attr("aria-expanded", "true"),
              f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h));
          }
          return !1;
        }
      }),
      (g.prototype.keydown = function (c) {
        if (
          /(38|40|27|32)/.test(c.which) &&
          !/input|textarea/i.test(c.target.tagName)
        ) {
          var d = a(this);
          if (
            (c.preventDefault(),
            c.stopPropagation(),
            !d.is(".disabled, :disabled"))
          ) {
            var e = b(d),
              g = e.hasClass("open");
            if ((!g && 27 != c.which) || (g && 27 == c.which))
              return (
                27 == c.which && e.find(f).trigger("focus"), d.trigger("click")
              );
            var h = " li:not(.disabled):visible a",
              i = e.find(".dropdown-menu" + h);
            if (i.length) {
              var j = i.index(c.target);
              38 == c.which && j > 0 && j--,
                40 == c.which && j < i.length - 1 && j++,
                ~j || (j = 0),
                i.eq(j).trigger("focus");
            }
          }
        }
      });
    var h = a.fn.dropdown;
    (a.fn.dropdown = d),
      (a.fn.dropdown.Constructor = g),
      (a.fn.dropdown.noConflict = function () {
        return (a.fn.dropdown = h), this;
      }),
      a(document)
        .on("click.bs.dropdown.data-api", c)
        .on("click.bs.dropdown.data-api", ".dropdown form", function (a) {
          a.stopPropagation();
        })
        .on("click.bs.dropdown.data-api", f, g.prototype.toggle)
        .on("keydown.bs.dropdown.data-api", f, g.prototype.keydown)
        .on(
          "keydown.bs.dropdown.data-api",
          ".dropdown-menu",
          g.prototype.keydown
        );
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b, d) {
      return this.each(function () {
        var e = a(this),
          f = e.data("bs.modal"),
          g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b);
        f || e.data("bs.modal", (f = new c(this, g))),
          "string" == typeof b ? f[b](d) : g.show && f.show(d);
      });
    }
    var c = function (b, c) {
      (this.options = c),
        (this.$body = a(document.body)),
        (this.$element = a(b)),
        (this.$dialog = this.$element.find(".modal-dialog")),
        (this.$backdrop = null),
        (this.isShown = null),
        (this.originalBodyPad = null),
        (this.scrollbarWidth = 0),
        (this.ignoreBackdropClick = !1),
        this.options.remote &&
          this.$element.find(".modal-content").load(
            this.options.remote,
            a.proxy(function () {
              this.$element.trigger("loaded.bs.modal");
            }, this)
          );
    };
    (c.VERSION = "3.3.7"),
      (c.TRANSITION_DURATION = 300),
      (c.BACKDROP_TRANSITION_DURATION = 150),
      (c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }),
      (c.prototype.toggle = function (a) {
        return this.isShown ? this.hide() : this.show(a);
      }),
      (c.prototype.show = function (b) {
        var d = this,
          e = a.Event("show.bs.modal", { relatedTarget: b });
        this.$element.trigger(e),
          this.isShown ||
            e.isDefaultPrevented() ||
            ((this.isShown = !0),
            this.checkScrollbar(),
            this.setScrollbar(),
            this.$body.addClass("modal-open"),
            this.escape(),
            this.resize(),
            this.$element.on(
              "click.dismiss.bs.modal",
              '[data-dismiss="modal"]',
              a.proxy(this.hide, this)
            ),
            this.$dialog.on("mousedown.dismiss.bs.modal", function () {
              d.$element.one("mouseup.dismiss.bs.modal", function (b) {
                a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0);
              });
            }),
            this.backdrop(function () {
              var e = a.support.transition && d.$element.hasClass("fade");
              d.$element.parent().length || d.$element.appendTo(d.$body),
                d.$element.show().scrollTop(0),
                d.adjustDialog(),
                e && d.$element[0].offsetWidth,
                d.$element.addClass("in"),
                d.enforceFocus();
              var f = a.Event("shown.bs.modal", { relatedTarget: b });
              e
                ? d.$dialog
                    .one("bsTransitionEnd", function () {
                      d.$element.trigger("focus").trigger(f);
                    })
                    .emulateTransitionEnd(c.TRANSITION_DURATION)
                : d.$element.trigger("focus").trigger(f);
            }));
      }),
      (c.prototype.hide = function (b) {
        b && b.preventDefault(),
          (b = a.Event("hide.bs.modal")),
          this.$element.trigger(b),
          this.isShown &&
            !b.isDefaultPrevented() &&
            ((this.isShown = !1),
            this.escape(),
            this.resize(),
            a(document).off("focusin.bs.modal"),
            this.$element
              .removeClass("in")
              .off("click.dismiss.bs.modal")
              .off("mouseup.dismiss.bs.modal"),
            this.$dialog.off("mousedown.dismiss.bs.modal"),
            a.support.transition && this.$element.hasClass("fade")
              ? this.$element
                  .one("bsTransitionEnd", a.proxy(this.hideModal, this))
                  .emulateTransitionEnd(c.TRANSITION_DURATION)
              : this.hideModal());
      }),
      (c.prototype.enforceFocus = function () {
        a(document)
          .off("focusin.bs.modal")
          .on(
            "focusin.bs.modal",
            a.proxy(function (a) {
              document === a.target ||
                this.$element[0] === a.target ||
                this.$element.has(a.target).length ||
                this.$element.trigger("focus");
            }, this)
          );
      }),
      (c.prototype.escape = function () {
        this.isShown && this.options.keyboard
          ? this.$element.on(
              "keydown.dismiss.bs.modal",
              a.proxy(function (a) {
                27 == a.which && this.hide();
              }, this)
            )
          : this.isShown || this.$element.off("keydown.dismiss.bs.modal");
      }),
      (c.prototype.resize = function () {
        this.isShown
          ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this))
          : a(window).off("resize.bs.modal");
      }),
      (c.prototype.hideModal = function () {
        var a = this;
        this.$element.hide(),
          this.backdrop(function () {
            a.$body.removeClass("modal-open"),
              a.resetAdjustments(),
              a.resetScrollbar(),
              a.$element.trigger("hidden.bs.modal");
          });
      }),
      (c.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove(), (this.$backdrop = null);
      }),
      (c.prototype.backdrop = function (b) {
        var d = this,
          e = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
          var f = a.support.transition && e;
          if (
            ((this.$backdrop = a(document.createElement("div"))
              .addClass("modal-backdrop " + e)
              .appendTo(this.$body)),
            this.$element.on(
              "click.dismiss.bs.modal",
              a.proxy(function (a) {
                return this.ignoreBackdropClick
                  ? void (this.ignoreBackdropClick = !1)
                  : void (
                      a.target === a.currentTarget &&
                      ("static" == this.options.backdrop
                        ? this.$element[0].focus()
                        : this.hide())
                    );
              }, this)
            ),
            f && this.$backdrop[0].offsetWidth,
            this.$backdrop.addClass("in"),
            !b)
          )
            return;
          f
            ? this.$backdrop
                .one("bsTransitionEnd", b)
                .emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION)
            : b();
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass("in");
          var g = function () {
            d.removeBackdrop(), b && b();
          };
          a.support.transition && this.$element.hasClass("fade")
            ? this.$backdrop
                .one("bsTransitionEnd", g)
                .emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION)
            : g();
        } else b && b();
      }),
      (c.prototype.handleUpdate = function () {
        this.adjustDialog();
      }),
      (c.prototype.adjustDialog = function () {
        var a =
          this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
          paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "",
          paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : "",
        });
      }),
      (c.prototype.resetAdjustments = function () {
        this.$element.css({ paddingLeft: "", paddingRight: "" });
      }),
      (c.prototype.checkScrollbar = function () {
        var a = window.innerWidth;
        if (!a) {
          var b = document.documentElement.getBoundingClientRect();
          a = b.right - Math.abs(b.left);
        }
        (this.bodyIsOverflowing = document.body.clientWidth < a),
          (this.scrollbarWidth = this.measureScrollbar());
      }),
      (c.prototype.setScrollbar = function () {
        var a = parseInt(this.$body.css("padding-right") || 0, 10);
        (this.originalBodyPad = document.body.style.paddingRight || ""),
          this.bodyIsOverflowing &&
            this.$body.css("padding-right", a + this.scrollbarWidth);
      }),
      (c.prototype.resetScrollbar = function () {
        this.$body.css("padding-right", this.originalBodyPad);
      }),
      (c.prototype.measureScrollbar = function () {
        var a = document.createElement("div");
        (a.className = "modal-scrollbar-measure"), this.$body.append(a);
        var b = a.offsetWidth - a.clientWidth;
        return this.$body[0].removeChild(a), b;
      });
    var d = a.fn.modal;
    (a.fn.modal = b),
      (a.fn.modal.Constructor = c),
      (a.fn.modal.noConflict = function () {
        return (a.fn.modal = d), this;
      }),
      a(document).on(
        "click.bs.modal.data-api",
        '[data-toggle="modal"]',
        function (c) {
          var d = a(this),
            e = d.attr("href"),
            f = a(
              d.attr("data-target") || (e && e.replace(/.*(?=#[^\s]+$)/, ""))
            ),
            g = f.data("bs.modal")
              ? "toggle"
              : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data());
          d.is("a") && c.preventDefault(),
            f.one("show.bs.modal", function (a) {
              a.isDefaultPrevented() ||
                f.one("hidden.bs.modal", function () {
                  d.is(":visible") && d.trigger("focus");
                });
            }),
            b.call(f, g, this);
        }
      );
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      return this.each(function () {
        var d = a(this),
          e = d.data("bs.tooltip"),
          f = "object" == typeof b && b;
        (!e && /destroy|hide/.test(b)) ||
          (e || d.data("bs.tooltip", (e = new c(this, f))),
          "string" == typeof b && e[b]());
      });
    }
    var c = function (a, b) {
      (this.type = null),
        (this.options = null),
        (this.enabled = null),
        (this.timeout = null),
        (this.hoverState = null),
        (this.$element = null),
        (this.inState = null),
        this.init("tooltip", a, b);
    };
    (c.VERSION = "3.3.7"),
      (c.TRANSITION_DURATION = 150),
      (c.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template:
          '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: { selector: "body", padding: 0 },
      }),
      (c.prototype.init = function (b, c, d) {
        if (
          ((this.enabled = !0),
          (this.type = b),
          (this.$element = a(c)),
          (this.options = this.getOptions(d)),
          (this.$viewport =
            this.options.viewport &&
            a(
              a.isFunction(this.options.viewport)
                ? this.options.viewport.call(this, this.$element)
                : this.options.viewport.selector || this.options.viewport
            )),
          (this.inState = { click: !1, hover: !1, focus: !1 }),
          this.$element[0] instanceof document.constructor &&
            !this.options.selector)
        )
          throw new Error(
            "`selector` option must be specified when initializing " +
              this.type +
              " on the window.document object!"
          );
        for (var e = this.options.trigger.split(" "), f = e.length; f--; ) {
          var g = e[f];
          if ("click" == g)
            this.$element.on(
              "click." + this.type,
              this.options.selector,
              a.proxy(this.toggle, this)
            );
          else if ("manual" != g) {
            var h = "hover" == g ? "mouseenter" : "focusin",
              i = "hover" == g ? "mouseleave" : "focusout";
            this.$element.on(
              h + "." + this.type,
              this.options.selector,
              a.proxy(this.enter, this)
            ),
              this.$element.on(
                i + "." + this.type,
                this.options.selector,
                a.proxy(this.leave, this)
              );
          }
        }
        this.options.selector
          ? (this._options = a.extend({}, this.options, {
              trigger: "manual",
              selector: "",
            }))
          : this.fixTitle();
      }),
      (c.prototype.getDefaults = function () {
        return c.DEFAULTS;
      }),
      (c.prototype.getOptions = function (b) {
        return (
          (b = a.extend({}, this.getDefaults(), this.$element.data(), b)),
          b.delay &&
            "number" == typeof b.delay &&
            (b.delay = { show: b.delay, hide: b.delay }),
          b
        );
      }),
      (c.prototype.getDelegateOptions = function () {
        var b = {},
          c = this.getDefaults();
        return (
          this._options &&
            a.each(this._options, function (a, d) {
              c[a] != d && (b[a] = d);
            }),
          b
        );
      }),
      (c.prototype.enter = function (b) {
        var c =
          b instanceof this.constructor
            ? b
            : a(b.currentTarget).data("bs." + this.type);
        return (
          c ||
            ((c = new this.constructor(
              b.currentTarget,
              this.getDelegateOptions()
            )),
            a(b.currentTarget).data("bs." + this.type, c)),
          b instanceof a.Event &&
            (c.inState["focusin" == b.type ? "focus" : "hover"] = !0),
          c.tip().hasClass("in") || "in" == c.hoverState
            ? void (c.hoverState = "in")
            : (clearTimeout(c.timeout),
              (c.hoverState = "in"),
              c.options.delay && c.options.delay.show
                ? void (c.timeout = setTimeout(function () {
                    "in" == c.hoverState && c.show();
                  }, c.options.delay.show))
                : c.show())
        );
      }),
      (c.prototype.isInStateTrue = function () {
        for (var a in this.inState) if (this.inState[a]) return !0;
        return !1;
      }),
      (c.prototype.leave = function (b) {
        var c =
          b instanceof this.constructor
            ? b
            : a(b.currentTarget).data("bs." + this.type);
        if (
          (c ||
            ((c = new this.constructor(
              b.currentTarget,
              this.getDelegateOptions()
            )),
            a(b.currentTarget).data("bs." + this.type, c)),
          b instanceof a.Event &&
            (c.inState["focusout" == b.type ? "focus" : "hover"] = !1),
          !c.isInStateTrue())
        )
          return (
            clearTimeout(c.timeout),
            (c.hoverState = "out"),
            c.options.delay && c.options.delay.hide
              ? void (c.timeout = setTimeout(function () {
                  "out" == c.hoverState && c.hide();
                }, c.options.delay.hide))
              : c.hide()
          );
      }),
      (c.prototype.show = function () {
        var b = a.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
          this.$element.trigger(b);
          var d = a.contains(
            this.$element[0].ownerDocument.documentElement,
            this.$element[0]
          );
          if (b.isDefaultPrevented() || !d) return;
          var e = this,
            f = this.tip(),
            g = this.getUID(this.type);
          this.setContent(),
            f.attr("id", g),
            this.$element.attr("aria-describedby", g),
            this.options.animation && f.addClass("fade");
          var h =
              "function" == typeof this.options.placement
                ? this.options.placement.call(this, f[0], this.$element[0])
                : this.options.placement,
            i = /\s?auto?\s?/i,
            j = i.test(h);
          j && (h = h.replace(i, "") || "top"),
            f
              .detach()
              .css({ top: 0, left: 0, display: "block" })
              .addClass(h)
              .data("bs." + this.type, this),
            this.options.container
              ? f.appendTo(this.options.container)
              : f.insertAfter(this.$element),
            this.$element.trigger("inserted.bs." + this.type);
          var k = this.getPosition(),
            l = f[0].offsetWidth,
            m = f[0].offsetHeight;
          if (j) {
            var n = h,
              o = this.getPosition(this.$viewport);
            (h =
              "bottom" == h && k.bottom + m > o.bottom
                ? "top"
                : "top" == h && k.top - m < o.top
                ? "bottom"
                : "right" == h && k.right + l > o.width
                ? "left"
                : "left" == h && k.left - l < o.left
                ? "right"
                : h),
              f.removeClass(n).addClass(h);
          }
          var p = this.getCalculatedOffset(h, k, l, m);
          this.applyPlacement(p, h);
          var q = function () {
            var a = e.hoverState;
            e.$element.trigger("shown.bs." + e.type),
              (e.hoverState = null),
              "out" == a && e.leave(e);
          };
          a.support.transition && this.$tip.hasClass("fade")
            ? f
                .one("bsTransitionEnd", q)
                .emulateTransitionEnd(c.TRANSITION_DURATION)
            : q();
        }
      }),
      (c.prototype.applyPlacement = function (b, c) {
        var d = this.tip(),
          e = d[0].offsetWidth,
          f = d[0].offsetHeight,
          g = parseInt(d.css("margin-top"), 10),
          h = parseInt(d.css("margin-left"), 10);
        isNaN(g) && (g = 0),
          isNaN(h) && (h = 0),
          (b.top += g),
          (b.left += h),
          a.offset.setOffset(
            d[0],
            a.extend(
              {
                using: function (a) {
                  d.css({ top: Math.round(a.top), left: Math.round(a.left) });
                },
              },
              b
            ),
            0
          ),
          d.addClass("in");
        var i = d[0].offsetWidth,
          j = d[0].offsetHeight;
        "top" == c && j != f && (b.top = b.top + f - j);
        var k = this.getViewportAdjustedDelta(c, b, i, j);
        k.left ? (b.left += k.left) : (b.top += k.top);
        var l = /top|bottom/.test(c),
          m = l ? 2 * k.left - e + i : 2 * k.top - f + j,
          n = l ? "offsetWidth" : "offsetHeight";
        d.offset(b), this.replaceArrow(m, d[0][n], l);
      }),
      (c.prototype.replaceArrow = function (a, b, c) {
        this.arrow()
          .css(c ? "left" : "top", 50 * (1 - a / b) + "%")
          .css(c ? "top" : "left", "");
      }),
      (c.prototype.setContent = function () {
        var a = this.tip(),
          b = this.getTitle();
        a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b),
          a.removeClass("fade in top bottom left right");
      }),
      (c.prototype.hide = function (b) {
        function d() {
          "in" != e.hoverState && f.detach(),
            e.$element &&
              e.$element
                .removeAttr("aria-describedby")
                .trigger("hidden.bs." + e.type),
            b && b();
        }
        var e = this,
          f = a(this.$tip),
          g = a.Event("hide.bs." + this.type);
        if ((this.$element.trigger(g), !g.isDefaultPrevented()))
          return (
            f.removeClass("in"),
            a.support.transition && f.hasClass("fade")
              ? f
                  .one("bsTransitionEnd", d)
                  .emulateTransitionEnd(c.TRANSITION_DURATION)
              : d(),
            (this.hoverState = null),
            this
          );
      }),
      (c.prototype.fixTitle = function () {
        var a = this.$element;
        (a.attr("title") || "string" != typeof a.attr("data-original-title")) &&
          a
            .attr("data-original-title", a.attr("title") || "")
            .attr("title", "");
      }),
      (c.prototype.hasContent = function () {
        return this.getTitle();
      }),
      (c.prototype.getPosition = function (b) {
        b = b || this.$element;
        var c = b[0],
          d = "BODY" == c.tagName,
          e = c.getBoundingClientRect();
        null == e.width &&
          (e = a.extend({}, e, {
            width: e.right - e.left,
            height: e.bottom - e.top,
          }));
        var f = window.SVGElement && c instanceof window.SVGElement,
          g = d ? { top: 0, left: 0 } : f ? null : b.offset(),
          h = {
            scroll: d
              ? document.documentElement.scrollTop || document.body.scrollTop
              : b.scrollTop(),
          },
          i = d
            ? { width: a(window).width(), height: a(window).height() }
            : null;
        return a.extend({}, e, h, i, g);
      }),
      (c.prototype.getCalculatedOffset = function (a, b, c, d) {
        return "bottom" == a
          ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 }
          : "top" == a
          ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 }
          : "left" == a
          ? { top: b.top + b.height / 2 - d / 2, left: b.left - c }
          : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width };
      }),
      (c.prototype.getViewportAdjustedDelta = function (a, b, c, d) {
        var e = { top: 0, left: 0 };
        if (!this.$viewport) return e;
        var f = (this.options.viewport && this.options.viewport.padding) || 0,
          g = this.getPosition(this.$viewport);
        if (/right|left/.test(a)) {
          var h = b.top - f - g.scroll,
            i = b.top + f - g.scroll + d;
          h < g.top
            ? (e.top = g.top - h)
            : i > g.top + g.height && (e.top = g.top + g.height - i);
        } else {
          var j = b.left - f,
            k = b.left + f + c;
          j < g.left
            ? (e.left = g.left - j)
            : k > g.right && (e.left = g.left + g.width - k);
        }
        return e;
      }),
      (c.prototype.getTitle = function () {
        var a,
          b = this.$element,
          c = this.options;
        return (a =
          b.attr("data-original-title") ||
          ("function" == typeof c.title ? c.title.call(b[0]) : c.title));
      }),
      (c.prototype.getUID = function (a) {
        do a += ~~(1e6 * Math.random());
        while (document.getElementById(a));
        return a;
      }),
      (c.prototype.tip = function () {
        if (
          !this.$tip &&
          ((this.$tip = a(this.options.template)), 1 != this.$tip.length)
        )
          throw new Error(
            this.type +
              " `template` option must consist of exactly 1 top-level element!"
          );
        return this.$tip;
      }),
      (c.prototype.arrow = function () {
        return (this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow"));
      }),
      (c.prototype.enable = function () {
        this.enabled = !0;
      }),
      (c.prototype.disable = function () {
        this.enabled = !1;
      }),
      (c.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled;
      }),
      (c.prototype.toggle = function (b) {
        var c = this;
        b &&
          ((c = a(b.currentTarget).data("bs." + this.type)),
          c ||
            ((c = new this.constructor(
              b.currentTarget,
              this.getDelegateOptions()
            )),
            a(b.currentTarget).data("bs." + this.type, c))),
          b
            ? ((c.inState.click = !c.inState.click),
              c.isInStateTrue() ? c.enter(c) : c.leave(c))
            : c.tip().hasClass("in")
            ? c.leave(c)
            : c.enter(c);
      }),
      (c.prototype.destroy = function () {
        var a = this;
        clearTimeout(this.timeout),
          this.hide(function () {
            a.$element.off("." + a.type).removeData("bs." + a.type),
              a.$tip && a.$tip.detach(),
              (a.$tip = null),
              (a.$arrow = null),
              (a.$viewport = null),
              (a.$element = null);
          });
      });
    var d = a.fn.tooltip;
    (a.fn.tooltip = b),
      (a.fn.tooltip.Constructor = c),
      (a.fn.tooltip.noConflict = function () {
        return (a.fn.tooltip = d), this;
      });
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      return this.each(function () {
        var d = a(this),
          e = d.data("bs.popover"),
          f = "object" == typeof b && b;
        (!e && /destroy|hide/.test(b)) ||
          (e || d.data("bs.popover", (e = new c(this, f))),
          "string" == typeof b && e[b]());
      });
    }
    var c = function (a, b) {
      this.init("popover", a, b);
    };
    if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");
    (c.VERSION = "3.3.7"),
      (c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template:
          '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>',
      })),
      (c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype)),
      (c.prototype.constructor = c),
      (c.prototype.getDefaults = function () {
        return c.DEFAULTS;
      }),
      (c.prototype.setContent = function () {
        var a = this.tip(),
          b = this.getTitle(),
          c = this.getContent();
        a.find(".popover-title")[this.options.html ? "html" : "text"](b),
          a
            .find(".popover-content")
            .children()
            .detach()
            .end()
            [
              this.options.html
                ? "string" == typeof c
                  ? "html"
                  : "append"
                : "text"
            ](c),
          a.removeClass("fade top bottom left right in"),
          a.find(".popover-title").html() || a.find(".popover-title").hide();
      }),
      (c.prototype.hasContent = function () {
        return this.getTitle() || this.getContent();
      }),
      (c.prototype.getContent = function () {
        var a = this.$element,
          b = this.options;
        return (
          a.attr("data-content") ||
          ("function" == typeof b.content ? b.content.call(a[0]) : b.content)
        );
      }),
      (c.prototype.arrow = function () {
        return (this.$arrow = this.$arrow || this.tip().find(".arrow"));
      });
    var d = a.fn.popover;
    (a.fn.popover = b),
      (a.fn.popover.Constructor = c),
      (a.fn.popover.noConflict = function () {
        return (a.fn.popover = d), this;
      });
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(c, d) {
      (this.$body = a(document.body)),
        (this.$scrollElement = a(a(c).is(document.body) ? window : c)),
        (this.options = a.extend({}, b.DEFAULTS, d)),
        (this.selector = (this.options.target || "") + " .nav li > a"),
        (this.offsets = []),
        (this.targets = []),
        (this.activeTarget = null),
        (this.scrollHeight = 0),
        this.$scrollElement.on(
          "scroll.bs.scrollspy",
          a.proxy(this.process, this)
        ),
        this.refresh(),
        this.process();
    }
    function c(c) {
      return this.each(function () {
        var d = a(this),
          e = d.data("bs.scrollspy"),
          f = "object" == typeof c && c;
        e || d.data("bs.scrollspy", (e = new b(this, f))),
          "string" == typeof c && e[c]();
      });
    }
    (b.VERSION = "3.3.7"),
      (b.DEFAULTS = { offset: 10 }),
      (b.prototype.getScrollHeight = function () {
        return (
          this.$scrollElement[0].scrollHeight ||
          Math.max(
            this.$body[0].scrollHeight,
            document.documentElement.scrollHeight
          )
        );
      }),
      (b.prototype.refresh = function () {
        var b = this,
          c = "offset",
          d = 0;
        (this.offsets = []),
          (this.targets = []),
          (this.scrollHeight = this.getScrollHeight()),
          a.isWindow(this.$scrollElement[0]) ||
            ((c = "position"), (d = this.$scrollElement.scrollTop())),
          this.$body
            .find(this.selector)
            .map(function () {
              var b = a(this),
                e = b.data("target") || b.attr("href"),
                f = /^#./.test(e) && a(e);
              return (
                (f && f.length && f.is(":visible") && [[f[c]().top + d, e]]) ||
                null
              );
            })
            .sort(function (a, b) {
              return a[0] - b[0];
            })
            .each(function () {
              b.offsets.push(this[0]), b.targets.push(this[1]);
            });
      }),
      (b.prototype.process = function () {
        var a,
          b = this.$scrollElement.scrollTop() + this.options.offset,
          c = this.getScrollHeight(),
          d = this.options.offset + c - this.$scrollElement.height(),
          e = this.offsets,
          f = this.targets,
          g = this.activeTarget;
        if ((this.scrollHeight != c && this.refresh(), b >= d))
          return g != (a = f[f.length - 1]) && this.activate(a);
        if (g && b < e[0]) return (this.activeTarget = null), this.clear();
        for (a = e.length; a--; )
          g != f[a] &&
            b >= e[a] &&
            (void 0 === e[a + 1] || b < e[a + 1]) &&
            this.activate(f[a]);
      }),
      (b.prototype.activate = function (b) {
        (this.activeTarget = b), this.clear();
        var c =
            this.selector +
            '[data-target="' +
            b +
            '"],' +
            this.selector +
            '[href="' +
            b +
            '"]',
          d = a(c).parents("li").addClass("active");
        d.parent(".dropdown-menu").length &&
          (d = d.closest("li.dropdown").addClass("active")),
          d.trigger("activate.bs.scrollspy");
      }),
      (b.prototype.clear = function () {
        a(this.selector)
          .parentsUntil(this.options.target, ".active")
          .removeClass("active");
      });
    var d = a.fn.scrollspy;
    (a.fn.scrollspy = c),
      (a.fn.scrollspy.Constructor = b),
      (a.fn.scrollspy.noConflict = function () {
        return (a.fn.scrollspy = d), this;
      }),
      a(window).on("load.bs.scrollspy.data-api", function () {
        a('[data-spy="scroll"]').each(function () {
          var b = a(this);
          c.call(b, b.data());
        });
      });
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      return this.each(function () {
        var d = a(this),
          e = d.data("bs.tab");
        e || d.data("bs.tab", (e = new c(this))),
          "string" == typeof b && e[b]();
      });
    }
    var c = function (b) {
      this.element = a(b);
    };
    (c.VERSION = "3.3.7"),
      (c.TRANSITION_DURATION = 150),
      (c.prototype.show = function () {
        var b = this.element,
          c = b.closest("ul:not(.dropdown-menu)"),
          d = b.data("target");
        if (
          (d ||
            ((d = b.attr("href")), (d = d && d.replace(/.*(?=#[^\s]*$)/, ""))),
          !b.parent("li").hasClass("active"))
        ) {
          var e = c.find(".active:last a"),
            f = a.Event("hide.bs.tab", { relatedTarget: b[0] }),
            g = a.Event("show.bs.tab", { relatedTarget: e[0] });
          if (
            (e.trigger(f),
            b.trigger(g),
            !g.isDefaultPrevented() && !f.isDefaultPrevented())
          ) {
            var h = a(d);
            this.activate(b.closest("li"), c),
              this.activate(h, h.parent(), function () {
                e.trigger({ type: "hidden.bs.tab", relatedTarget: b[0] }),
                  b.trigger({ type: "shown.bs.tab", relatedTarget: e[0] });
              });
          }
        }
      }),
      (c.prototype.activate = function (b, d, e) {
        function f() {
          g
            .removeClass("active")
            .find("> .dropdown-menu > .active")
            .removeClass("active")
            .end()
            .find('[data-toggle="tab"]')
            .attr("aria-expanded", !1),
            b
              .addClass("active")
              .find('[data-toggle="tab"]')
              .attr("aria-expanded", !0),
            h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"),
            b.parent(".dropdown-menu").length &&
              b
                .closest("li.dropdown")
                .addClass("active")
                .end()
                .find('[data-toggle="tab"]')
                .attr("aria-expanded", !0),
            e && e();
        }
        var g = d.find("> .active"),
          h =
            e &&
            a.support.transition &&
            ((g.length && g.hasClass("fade")) || !!d.find("> .fade").length);
        g.length && h
          ? g
              .one("bsTransitionEnd", f)
              .emulateTransitionEnd(c.TRANSITION_DURATION)
          : f(),
          g.removeClass("in");
      });
    var d = a.fn.tab;
    (a.fn.tab = b),
      (a.fn.tab.Constructor = c),
      (a.fn.tab.noConflict = function () {
        return (a.fn.tab = d), this;
      });
    var e = function (c) {
      c.preventDefault(), b.call(a(this), "show");
    };
    a(document)
      .on("click.bs.tab.data-api", '[data-toggle="tab"]', e)
      .on("click.bs.tab.data-api", '[data-toggle="pill"]', e);
  })(jQuery),
  +(function (a) {
    "use strict";
    function b(b) {
      return this.each(function () {
        var d = a(this),
          e = d.data("bs.affix"),
          f = "object" == typeof b && b;
        e || d.data("bs.affix", (e = new c(this, f))),
          "string" == typeof b && e[b]();
      });
    }
    var c = function (b, d) {
      (this.options = a.extend({}, c.DEFAULTS, d)),
        (this.$target = a(this.options.target)
          .on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this))
          .on(
            "click.bs.affix.data-api",
            a.proxy(this.checkPositionWithEventLoop, this)
          )),
        (this.$element = a(b)),
        (this.affixed = null),
        (this.unpin = null),
        (this.pinnedOffset = null),
        this.checkPosition();
    };
    (c.VERSION = "3.3.7"),
      (c.RESET = "affix affix-top affix-bottom"),
      (c.DEFAULTS = { offset: 0, target: window }),
      (c.prototype.getState = function (a, b, c, d) {
        var e = this.$target.scrollTop(),
          f = this.$element.offset(),
          g = this.$target.height();
        if (null != c && "top" == this.affixed) return e < c && "top";
        if ("bottom" == this.affixed)
          return null != c
            ? !(e + this.unpin <= f.top) && "bottom"
            : !(e + g <= a - d) && "bottom";
        var h = null == this.affixed,
          i = h ? e : f.top,
          j = h ? g : b;
        return null != c && e <= c
          ? "top"
          : null != d && i + j >= a - d && "bottom";
      }),
      (c.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(c.RESET).addClass("affix");
        var a = this.$target.scrollTop(),
          b = this.$element.offset();
        return (this.pinnedOffset = b.top - a);
      }),
      (c.prototype.checkPositionWithEventLoop = function () {
        setTimeout(a.proxy(this.checkPosition, this), 1);
      }),
      (c.prototype.checkPosition = function () {
        if (this.$element.is(":visible")) {
          var b = this.$element.height(),
            d = this.options.offset,
            e = d.top,
            f = d.bottom,
            g = Math.max(a(document).height(), a(document.body).height());
          "object" != typeof d && (f = e = d),
            "function" == typeof e && (e = d.top(this.$element)),
            "function" == typeof f && (f = d.bottom(this.$element));
          var h = this.getState(g, b, e, f);
          if (this.affixed != h) {
            null != this.unpin && this.$element.css("top", "");
            var i = "affix" + (h ? "-" + h : ""),
              j = a.Event(i + ".bs.affix");
            if ((this.$element.trigger(j), j.isDefaultPrevented())) return;
            (this.affixed = h),
              (this.unpin = "bottom" == h ? this.getPinnedOffset() : null),
              this.$element
                .removeClass(c.RESET)
                .addClass(i)
                .trigger(i.replace("affix", "affixed") + ".bs.affix");
          }
          "bottom" == h && this.$element.offset({ top: g - b - f });
        }
      });
    var d = a.fn.affix;
    (a.fn.affix = b),
      (a.fn.affix.Constructor = c),
      (a.fn.affix.noConflict = function () {
        return (a.fn.affix = d), this;
      }),
      a(window).on("load", function () {
        a('[data-spy="affix"]').each(function () {
          var c = a(this),
            d = c.data();
          (d.offset = d.offset || {}),
            null != d.offsetBottom && (d.offset.bottom = d.offsetBottom),
            null != d.offsetTop && (d.offset.top = d.offsetTop),
            b.call(c, d);
        });
      });
  })(jQuery);
(function (a) {
  a.fn.extend({
    styledSelect: function (b) {
      if (typeof document.body.style.maxHeight != "undefined") {
        var c = { customClass: null, mapClass: true, mapStyle: true };
        var b = a.extend(c, b);
        return this.each(function () {
          var d = a(this);
          var f = a('<span class="customSelectInner" />');
          var e = a('<span class="customSelect" />').append(f);
          d.after(e);
          if (b.customClass) {
            e.addClass(b.customClass);
          }
          if (b.mapClass) {
            e.addClass(d.attr("class"));
          }
          if (b.mapStyle) {
            e.attr("style", d.attr("style"));
          }
          d.bind("update", function () {
            d.change();
            var h =
              parseInt(d.outerWidth()) -
              (parseInt(e.outerWidth()) - parseInt(e.width()));
            e.css({ display: "inline-block" });
            f.css({ width: h, display: "inline-block" });
            var g = e.outerHeight();
            d.css({
              "-webkit-appearance": "menulist-button",
              width: e.outerWidth(),
              position: "absolute",
              opacity: 0,
              height: g,
              fontSize: e.css("font-size"),
            });
          })
            .change(function () {
              var g = d.find(":selected");
              var h = g.html() || "&nbsp;";
              f.html(h).parent().addClass("customSelectChanged");
              setTimeout(function () {
                e.removeClass("customSelectOpen");
              }, 60);
            })
            .bind("mousedown", function () {
              e.toggleClass("customSelectOpen");
            })
            .focus(function () {
              e.addClass("customSelectFocus");
            })
            .blur(function () {
              e.removeClass("customSelectFocus customSelectOpen");
            })
            .trigger("update");
        });
      }
    },
  });
})(jQuery);
(function ($, window, document, undefined) {
  var pluginName = "svgInject";
  function Plugin(element, options) {
    this.element = element;
    this._name = pluginName;
    this.init();
  }
  Plugin.prototype = {
    init: function () {
      $(this.element).css("visibility", "hidden");
      this.swapSVG(this.element);
    },
    swapSVG: function (el) {
      var imgURL = $(el).attr("src");
      var imgID = $(el).attr("id");
      var imgClass = $(el).attr("class");
      var imgData = $(el).clone(true).data();
      var dimensions = { w: $(el).attr("width"), h: $(el).attr("height") };
      $.get(imgURL, function (data) {
        var svg = $(data).find("svg");
        if (typeof imgID !== undefined) {
          svg = svg.attr("id", imgID);
        }
        if (typeof imgClass !== undefined) {
          var cls = svg.attr("class") !== undefined ? svg.attr("class") : "";
          svg = svg.attr("class", imgClass + " " + cls + " replaced-svg");
        }
        $.each(imgData, function (name, value) {
          svg[0].setAttribute("data-" + name, value);
        });
        svg = svg.removeAttr("xmlns:a");
        var ow = parseFloat(svg.attr("width"));
        var oh = parseFloat(svg.attr("height"));
        if (dimensions.w && dimensions.h) {
          $(svg).attr("width", dimensions.w);
          $(svg).attr("height", dimensions.h);
        } else if (dimensions.w) {
          $(svg).attr("width", dimensions.w);
          $(svg).attr("height", (oh / ow) * dimensions.w);
        } else if (dimensions.h) {
          $(svg).attr("height", dimensions.h);
          $(svg).attr("width", (ow / oh) * dimensions.h);
        }
        $(el).replaceWith(svg);
        var js = new Function(svg.find("script").text());
        js();
      });
    },
  };
  $.fn[pluginName] = function (options) {
    return this.each(function () {
      if (!$.data(this, "plugin_" + pluginName)) {
        $.data(this, "plugin_" + pluginName, new Plugin(this, options));
      }
    });
  };
})(jQuery, window, document);
!(function (a, b, c) {
  var d = window.matchMedia;
  "undefined" != typeof module && module.exports
    ? (module.exports = c(d))
    : "function" == typeof define && define.amd
    ? define(function () {
        return (b[a] = c(d));
      })
    : (b[a] = c(d));
})("enquire", this, function (a) {
  "use strict";
  function b(a, b) {
    var c,
      d = 0,
      e = a.length;
    for (d; e > d && ((c = b(a[d], d)), c !== !1); d++);
  }
  function c(a) {
    return "[object Array]" === Object.prototype.toString.apply(a);
  }
  function d(a) {
    return "function" == typeof a;
  }
  function e(a) {
    (this.options = a), !a.deferSetup && this.setup();
  }
  function f(b, c) {
    (this.query = b),
      (this.isUnconditional = c),
      (this.handlers = []),
      (this.mql = a(b));
    var d = this;
    (this.listener = function (a) {
      (d.mql = a), d.assess();
    }),
      this.mql.addListener(this.listener);
  }
  function g() {
    if (!a)
      throw new Error(
        "matchMedia not present, legacy browsers require a polyfill"
      );
    (this.queries = {}), (this.browserIsIncapable = !a("only all").matches);
  }
  return (
    (e.prototype = {
      setup: function () {
        this.options.setup && this.options.setup(), (this.initialised = !0);
      },
      on: function () {
        !this.initialised && this.setup(),
          this.options.match && this.options.match();
      },
      off: function () {
        this.options.unmatch && this.options.unmatch();
      },
      destroy: function () {
        this.options.destroy ? this.options.destroy() : this.off();
      },
      equals: function (a) {
        return this.options === a || this.options.match === a;
      },
    }),
    (f.prototype = {
      addHandler: function (a) {
        var b = new e(a);
        this.handlers.push(b), this.matches() && b.on();
      },
      removeHandler: function (a) {
        var c = this.handlers;
        b(c, function (b, d) {
          return b.equals(a) ? (b.destroy(), !c.splice(d, 1)) : void 0;
        });
      },
      matches: function () {
        return this.mql.matches || this.isUnconditional;
      },
      clear: function () {
        b(this.handlers, function (a) {
          a.destroy();
        }),
          this.mql.removeListener(this.listener),
          (this.handlers.length = 0);
      },
      assess: function () {
        var a = this.matches() ? "on" : "off";
        b(this.handlers, function (b) {
          b[a]();
        });
      },
    }),
    (g.prototype = {
      register: function (a, e, g) {
        var h = this.queries,
          i = g && this.browserIsIncapable;
        return (
          h[a] || (h[a] = new f(a, i)),
          d(e) && (e = { match: e }),
          c(e) || (e = [e]),
          b(e, function (b) {
            d(b) && (b = { match: b }), h[a].addHandler(b);
          }),
          this
        );
      },
      unregister: function (a, b) {
        var c = this.queries[a];
        return (
          c && (b ? c.removeHandler(b) : (c.clear(), delete this.queries[a])),
          this
        );
      },
    }),
    new g()
  );
});
function valid_email(email) {
  return email.match(EMAIL_REGEX);
}
function displayFormError(params) {
  var html =
    '\
	    <div class="form_error ygt_hide">\
		    <div class="form_error_content">' +
    params.errorMsg +
    '</div>\
		    <span class="arrow-down"></span>\
	    </div>';
  params.element.addClass("form_validation_element");
  params.element.parent().addClass("form_error_parent");
  params.element.siblings(".form_error").remove();
  params.element.before(html);
  params.element.siblings(".form_error").fadeIn(300);
}
function personalizePrepareStep(step) {
  $("#finished-step").val(step);
  var nextStep = parseInt(step) + 1;
  $(".side-nav ul li.step-" + nextStep + " a").trigger("click");
}
function digitValidate(element) {
  var is_digit = /^\d+$/;
  if (!is_digit.test(element.val())) {
    element.val(element.val().substring(0, element.val().length - 1));
  } else if (element.val().length == 1 && element.val() == "0") {
    element.val(element.val().substring(0, element.val().length - 1));
    return;
  }
}
function async_load_js(url, after_load, config) {
  var node = document.createElement("script");
  node.type = "text/javascript";
  node.async = true;
  node.src = url;
  if (config !== undefined && config.id) node.id = config.id;
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(node, s);
  if (after_load !== undefined) {
    node.onreadystatechange = node.onload = after_load;
  }
}
$.fn.goTo = function (after) {
  if ($(this).length == 0) return this;
  if ($.fn.goTo.no_scroll) {
    if (after !== undefined) after();
    return this;
  }
  var scroll_top = $(this).offset().top;
  $("html, body").animate({ scrollTop: scroll_top + "px" }, "slow", after);
  return this;
};
$(function () {
  if (!$("body").hasClass("b2c")) {
    $('a[href^="mailto:"]').each(function () {
      this.href = this.href.replace("(at)", "@").replace(/\(dot\)/g, ".");
    });
    var elEmail = $(".email-me");
    if (elEmail.length) {
      var tooltipEmail = $(".email-me")
        .data("original-title")
        .replace("(at)", "@")
        .replace(/\(dot\)/g, ".");
      $(".email-me").attr("data-original-title", tooltipEmail);
    }
  }
  $("body").on("click", ".form_error", function () {
    $(this).fadeOut(300, function () {
      $(this).parent().removeClass("form_error_parent");
      $(this).remove();
    });
  });
  $("body").on("keyup change", ".form_validation_element", function () {
    $(this).siblings(".form_error").trigger("click");
  });
  $(".cat-nav").hover(
    function () {
      $(".cat-menu").addClass("hovered");
      $(".dropdown_menu").show().addClass("dropdownshow");
    },
    function () {
      $(".cat-menu").removeClass("hovered");
      $(".dropdown_menu").hide().removeClass("dropdownshow");
    }
  );
  $(".sub-nav").hover(
    function () {
      $(".sub-menu").addClass("hovered");
      $(".dropdown_list").show().addClass("floated");
    },
    function () {
      $(".sub-menu").removeClass("hovered");
      $(".dropdown_list").hide().removeClass("floated");
    }
  );
  $(".dropdown-menu li a").click(function () {
    $(".dropdown-menu li a").removeClass("active");
    $(this).addClass("active");
    var selText = $(this).text();
    $(this)
      .closest(".dropdown")
      .find('a[data-toggle="dropdown"]')
      .html(selText + ' <span class="caret"></span>');
  });
  $(".login-drop").hover(
    function () {
      $(".login_wr").addClass("active");
      $(".master_logout_menu").show();
    },
    function () {
      $(".master_logout_menu").hide();
      $(".login_wr").removeClass("active");
    }
  );
  $("button.btn-subscribe").on("click", function () {
    $(".newsletter label").remove();
    var email = $.trim($(this).parents(".input:first").find("input").val());
    if (email != "" && valid_email(email)) {
      var url = SENDY_URL.replace("user_email", email);
      $(".newsletter .input").hide();
      $(".newsletter .h2").hide();
      $(".newsletter .loading").removeClass("hide").fadeIn("fast");
      $.ajax({
        type: "GET",
        url: url,
        complete: function (html) {
          $(".newsletter .loading").addClass("hide").hide();
          $(".newsletter .thanks").removeClass("hide").fadeIn("fast");
          $(".newsletter label").remove();
        },
      });
    } else {
      $(this)
        .parents(".input")
        .after(
          "<label class='error'>Please enter a valid email address to subscribe.</label>"
        );
    }
  });
  $(".sublevel").hover(
    function () {
      $("a.login_wr_new").addClass("active");
      $("#login_form_wr_new").show().addClass("floated");
    },
    function () {
      $("a.login_wr_new").removeClass("active");
      $("#login_form_wr_new").hide().removeClass("floated");
    }
  );

  $(".login_form_wr_new input").keyup(function () {
    $(this).closest(".input").removeClass("error");
  });
  $(".login_form_wr_new input").keydown(function (e) {
    if (e.keyCode == 13) $("button.login-submit").click();
  });
  $("button.login-submit").click(function () {
    $(".login_form_wr_new .error_msg").hide();
    $(".login_form_wr_new input").removeClass("error");
    var data = "&username=" + $.trim($("#id_header_login_username").val());
    data += "&password=" + $.trim($("#id_header_login_password").val());
    data +=
      "&csrfmiddlewaretoken=" +
      $.trim($("#login_form_wr_new form [name=csrfmiddlewaretoken]").val());
    if (
      $.trim($("#id_header_login_username").val()) == "" ||
      $.trim($("#id_header_login_password").val()) == ""
    ) {
      $("#login_form_wr_new .loader").hide();
      $(".login_form_wr_new .input").addClass("error");
      $(".login_form_wr_new .error_msg").show();
      return;
    }
    $("#login_form_wr_new .loader").show();
    login(data, function (data) {
      if (data.success) {
        $("#login_form_wr_new .loader").hide();
        if (data !== undefined && data.next !== undefined && data.next != BASE)
          window.location = data.next;
        else window.location.reload();
      } else if (data.error) {
        $("#login_form_wr_new .loader").hide();
        $(".login_form_wr_new .input").addClass("error");
        $(".login_form_wr_new .error_msg").text(data.data.responseJSON.errors);
        $(".login_form_wr_new .error_msg").show();
      }
    });
  });
  function ipadDropdown() {
    return {
      match: function () {
        $(".mob-menu ul li:first").remove();
        $(".mob-menu > ul li").remove();
        $(".navbar-nav .hidden-sm").clone().appendTo(".mob-menu ul");
        $("li.ipad-meni").hover(
          function () {
            $("a.ipad-toggle").addClass("active");
            $(".mob-menu").show();
          },
          function () {
            $("a.ipad-toggle").removeClass("active");
            $(".mob-menu").hide();
          }
        );
        $(".cat-nav").hover(
          function () {
            $(".cat-menu").addClass("hovered");
            $(".dropdown_menu").show().addClass("dropdownshow");
          },
          function () {
            $(".cat-menu").removeClass("hovered");
            $(".dropdown_menu").hide().removeClass("dropdownshow");
          }
        );
        $(".sub-nav").hover(
          function () {
            $(".sub-menu").addClass("hovered");
            $(".dropdown_list").show().addClass("dropdownshow");
          },
          function () {
            $(".sub-menu").removeClass("hovered");
            $(".dropdown_list").hide().removeClass("dropdownshow");
          }
        );
        var reviewHeight = $(".review-block").height() + 62;
        $(".white-strap").css({ height: reviewHeight });
      },
    };
  }
  enquire
    .register("(min-width: 320px) and (max-width: 767px)", ipadDropdown())
    .register("(min-width: 768px) and (max-width: 1023px)", ipadDropdown())
    .register("(min-width: 1024px) and (max-width: 1249px)", {
      match: function () {
        $(".mob-menu > ul li").remove();
        var reviewHeight = $(".review-block").height() + 85;
        $(".white-strap").css({ height: reviewHeight });
      },
    })
    .register("(min-width: 1259px)", {
      match: function () {
        $("#partnersCarousel .carousel-inner").find(".hidden-lg").remove();
      },
    });
  $(".show-pass")
    .off("click")
    .on("click", function () {
      var target = $(this).closest("div").find("input");
      if (target.val() != "") {
        if (target.attr("type") == "text") {
          target.attr("type", "password");
          $(this).html('<span class="icon-eye_active"></span>');
        } else if (target.attr("type") == "password") {
          target.attr("type", "text");
          $(this).html('<span class="icon-eye"></span>');
        }
      }
    });
});


function initTooltip(parent) {
  $('[data-tooltip="true"]').tooltip({
    container: "body",
    trigger: "hover click",
  });
  parent.find(".input-group.error:first").find(".icon-error").tooltip("show");
  parent.find(".input-group.error:first").find("input").focus();
}
function fnValidation(el, msg) {
  el.closest(".input-group")
    .addClass("error")
    .find(".icon-error")
    .attr("data-original-title", msg);
}
function validateDecimalAmount(element) {
  var decimal_notation = element.data("decimal");
  if (decimal_notation > 0) {
    var regex_str = "^\\d+(\\.\\d{0," + decimal_notation + "})?$";
    regex_str = regex_str.replace(/\s+/, "");
    var regex = new RegExp(regex_str);
    if (regex.test(element.val()) == false) {
      element.val(element.val().substring(0, element.val().length - 1));
    }
  } else {
    digitValidate(element);
  }
}
function pushYGAGEvent(data) {
  let ygagData = {
    Identity: data.email,
    Name: data.name,
    Phone: data.phone,
    AcquistionType: "Website",
    RegistrationStartDate: "",
    AppVersion: "",
    LoginMethodUsed: "Conventional",
    "Account Type": "Personal",
    "User Type": "Logged In",
    Platform: sitePlatform,
    Language: siteLanguage,
  };
  clevertap.event.push(clevertap_events.YGAG, ygagData);
}
!(function (a) {
  "function" == typeof define && define.amd
    ? define(["jquery"], a)
    : "object" == typeof module && module.exports
    ? (module.exports = a(require("jquery")))
    : a(jQuery);
})(function (a) {
  a.extend(a.fn, {
    validate: function (b) {
      if (!this.length)
        return void (
          b &&
          b.debug &&
          window.console &&
          console.warn("Nothing selected, can't validate, returning nothing.")
        );
      var c = a.data(this[0], "validator");
      return c
        ? c
        : (this.attr("novalidate", "novalidate"),
          (c = new a.validator(b, this[0])),
          a.data(this[0], "validator", c),
          c.settings.onsubmit &&
            (this.on("click.validate", ":submit", function (b) {
              c.settings.submitHandler && (c.submitButton = b.target),
                a(this).hasClass("cancel") && (c.cancelSubmit = !0),
                void 0 !== a(this).attr("formnovalidate") &&
                  (c.cancelSubmit = !0);
            }),
            this.on("submit.validate", function (b) {
              function d() {
                var d, e;
                return (
                  !c.settings.submitHandler ||
                  (c.submitButton &&
                    (d = a("<input type='hidden'/>")
                      .attr("name", c.submitButton.name)
                      .val(a(c.submitButton).val())
                      .appendTo(c.currentForm)),
                  (e = c.settings.submitHandler.call(c, c.currentForm, b)),
                  c.submitButton && d.remove(),
                  void 0 !== e && e)
                );
              }
              return (
                c.settings.debug && b.preventDefault(),
                c.cancelSubmit
                  ? ((c.cancelSubmit = !1), d())
                  : c.form()
                  ? c.pendingRequest
                    ? ((c.formSubmitted = !0), !1)
                    : d()
                  : (c.focusInvalid(), !1)
              );
            })),
          c);
    },
    valid: function () {
      var b, c, d;
      return (
        a(this[0]).is("form")
          ? (b = this.validate().form())
          : ((d = []),
            (b = !0),
            (c = a(this[0].form).validate()),
            this.each(function () {
              (b = c.element(this) && b), b || (d = d.concat(c.errorList));
            }),
            (c.errorList = d)),
        b
      );
    },
    rules: function (b, c) {
      var d,
        e,
        f,
        g,
        h,
        i,
        j = this[0];
      if (null != j && null != j.form) {
        if (b)
          switch (
            ((d = a.data(j.form, "validator").settings),
            (e = d.rules),
            (f = a.validator.staticRules(j)),
            b)
          ) {
            case "add":
              a.extend(f, a.validator.normalizeRule(c)),
                delete f.messages,
                (e[j.name] = f),
                c.messages &&
                  (d.messages[j.name] = a.extend(
                    d.messages[j.name],
                    c.messages
                  ));
              break;
            case "remove":
              return c
                ? ((i = {}),
                  a.each(c.split(/\s/), function (b, c) {
                    (i[c] = f[c]),
                      delete f[c],
                      "required" === c && a(j).removeAttr("aria-required");
                  }),
                  i)
                : (delete e[j.name], f);
          }
        return (
          (g = a.validator.normalizeRules(
            a.extend(
              {},
              a.validator.classRules(j),
              a.validator.attributeRules(j),
              a.validator.dataRules(j),
              a.validator.staticRules(j)
            ),
            j
          )),
          g.required &&
            ((h = g.required),
            delete g.required,
            (g = a.extend({ required: h }, g)),
            a(j).attr("aria-required", "true")),
          g.remote &&
            ((h = g.remote), delete g.remote, (g = a.extend(g, { remote: h }))),
          g
        );
      }
    },
  }),
    a.extend(a.expr.pseudos || a.expr[":"], {
      blank: function (b) {
        return !a.trim("" + a(b).val());
      },
      filled: function (b) {
        var c = a(b).val();
        return null !== c && !!a.trim("" + c);
      },
      unchecked: function (b) {
        return !a(b).prop("checked");
      },
    }),
    (a.validator = function (b, c) {
      (this.settings = a.extend(!0, {}, a.validator.defaults, b)),
        (this.currentForm = c),
        this.init();
    }),
    (a.validator.format = function (b, c) {
      return 1 === arguments.length
        ? function () {
            var c = a.makeArray(arguments);
            return c.unshift(b), a.validator.format.apply(this, c);
          }
        : void 0 === c
        ? b
        : (arguments.length > 2 &&
            c.constructor !== Array &&
            (c = a.makeArray(arguments).slice(1)),
          c.constructor !== Array && (c = [c]),
          a.each(c, function (a, c) {
            b = b.replace(new RegExp("\\{" + a + "\\}", "g"), function () {
              return c;
            });
          }),
          b);
    }),
    a.extend(a.validator, {
      defaults: {
        messages: {},
        groups: {},
        rules: {},
        errorClass: "error",
        pendingClass: "pending",
        validClass: "valid",
        errorElement: "label",
        focusCleanup: !1,
        focusInvalid: !0,
        errorContainer: a([]),
        errorLabelContainer: a([]),
        onsubmit: !0,
        ignore: ":hidden",
        ignoreTitle: !1,
        onfocusin: function (a) {
          (this.lastActive = a),
            this.settings.focusCleanup &&
              (this.settings.unhighlight &&
                this.settings.unhighlight.call(
                  this,
                  a,
                  this.settings.errorClass,
                  this.settings.validClass
                ),
              this.hideThese(this.errorsFor(a)));
        },
        onfocusout: function (a) {
          this.checkable(a) ||
            (!(a.name in this.submitted) && this.optional(a)) ||
            this.element(a);
        },
        onkeyup: function (b, c) {
          var d = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];
          (9 === c.which && "" === this.elementValue(b)) ||
            a.inArray(c.keyCode, d) !== -1 ||
            ((b.name in this.submitted || b.name in this.invalid) &&
              this.element(b));
        },
        onclick: function (a) {
          a.name in this.submitted
            ? this.element(a)
            : a.parentNode.name in this.submitted && this.element(a.parentNode);
        },
        highlight: function (b, c, d) {
          "radio" === b.type
            ? this.findByName(b.name).addClass(c).removeClass(d)
            : a(b).addClass(c).removeClass(d);
        },
        unhighlight: function (b, c, d) {
          "radio" === b.type
            ? this.findByName(b.name).removeClass(c).addClass(d)
            : a(b).removeClass(c).addClass(d);
        },
      },
      setDefaults: function (b) {
        a.extend(a.validator.defaults, b);
      },
      messages: {
        required: "This field is required.",
        remote: "Please fix this field.",
        email: "Please enter a valid email address.",
        url: "Please enter a valid URL.",
        date: "Please enter a valid date.",
        dateISO: "Please enter a valid date (ISO).",
        number: "Please enter a valid number.",
        digits: "Please enter only digits.",
        equalTo: "Please enter the same value again.",
        maxlength: a.validator.format(
          "Please enter no more than {0} characters."
        ),
        minlength: a.validator.format("Please enter at least {0} characters."),
        rangelength: a.validator.format(
          "Please enter a value between {0} and {1} characters long."
        ),
        range: a.validator.format("Please enter a value between {0} and {1}."),
        max: a.validator.format(
          "Please enter a value less than or equal to {0}."
        ),
        min: a.validator.format(
          "Please enter a value greater than or equal to {0}."
        ),
        step: a.validator.format("Please enter a multiple of {0}."),
      },
      autoCreateRanges: !1,
      prototype: {
        init: function () {
          function b(b) {
            !this.form &&
              this.hasAttribute("contenteditable") &&
              (this.form = a(this).closest("form")[0]);
            var c = a.data(this.form, "validator"),
              d = "on" + b.type.replace(/^validate/, ""),
              e = c.settings;
            e[d] && !a(this).is(e.ignore) && e[d].call(c, this, b);
          }
          (this.labelContainer = a(this.settings.errorLabelContainer)),
            (this.errorContext =
              (this.labelContainer.length && this.labelContainer) ||
              a(this.currentForm)),
            (this.containers = a(this.settings.errorContainer).add(
              this.settings.errorLabelContainer
            )),
            (this.submitted = {}),
            (this.valueCache = {}),
            (this.pendingRequest = 0),
            (this.pending = {}),
            (this.invalid = {}),
            this.reset();
          var c,
            d = (this.groups = {});
          a.each(this.settings.groups, function (b, c) {
            "string" == typeof c && (c = c.split(/\s/)),
              a.each(c, function (a, c) {
                d[c] = b;
              });
          }),
            (c = this.settings.rules),
            a.each(c, function (b, d) {
              c[b] = a.validator.normalizeRule(d);
            }),
            a(this.currentForm)
              .on(
                "focusin.validate focusout.validate keyup.validate",
                ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']",
                b
              )
              .on(
                "click.validate",
                "select, option, [type='radio'], [type='checkbox']",
                b
              ),
            this.settings.invalidHandler &&
              a(this.currentForm).on(
                "invalid-form.validate",
                this.settings.invalidHandler
              ),
            a(this.currentForm)
              .find("[required], [data-rule-required], .required")
              .attr("aria-required", "true");
        },
        form: function () {
          return (
            this.checkForm(),
            a.extend(this.submitted, this.errorMap),
            (this.invalid = a.extend({}, this.errorMap)),
            this.valid() ||
              a(this.currentForm).triggerHandler("invalid-form", [this]),
            this.showErrors(),
            this.valid()
          );
        },
        checkForm: function () {
          this.prepareForm();
          for (
            var a = 0, b = (this.currentElements = this.elements());
            b[a];
            a++
          )
            this.check(b[a]);
          return this.valid();
        },
        element: function (b) {
          var c,
            d,
            e = this.clean(b),
            f = this.validationTargetFor(e),
            g = this,
            h = !0;
          return (
            void 0 === f
              ? delete this.invalid[e.name]
              : (this.prepareElement(f),
                (this.currentElements = a(f)),
                (d = this.groups[f.name]),
                d &&
                  a.each(this.groups, function (a, b) {
                    b === d &&
                      a !== f.name &&
                      ((e = g.validationTargetFor(g.clean(g.findByName(a)))),
                      e &&
                        e.name in g.invalid &&
                        (g.currentElements.push(e), (h = g.check(e) && h)));
                  }),
                (c = this.check(f) !== !1),
                (h = h && c),
                c ? (this.invalid[f.name] = !1) : (this.invalid[f.name] = !0),
                this.numberOfInvalids() ||
                  (this.toHide = this.toHide.add(this.containers)),
                this.showErrors(),
                a(b).attr("aria-invalid", !c)),
            h
          );
        },
        showErrors: function (b) {
          if (b) {
            var c = this;
            a.extend(this.errorMap, b),
              (this.errorList = a.map(this.errorMap, function (a, b) {
                return { message: a, element: c.findByName(b)[0] };
              })),
              (this.successList = a.grep(this.successList, function (a) {
                return !(a.name in b);
              }));
          }
          this.settings.showErrors
            ? this.settings.showErrors.call(this, this.errorMap, this.errorList)
            : this.defaultShowErrors();
        },
        resetForm: function () {
          a.fn.resetForm && a(this.currentForm).resetForm(),
            (this.invalid = {}),
            (this.submitted = {}),
            this.prepareForm(),
            this.hideErrors();
          var b = this.elements()
            .removeData("previousValue")
            .removeAttr("aria-invalid");
          this.resetElements(b);
        },
        resetElements: function (a) {
          var b;
          if (this.settings.unhighlight)
            for (b = 0; a[b]; b++)
              this.settings.unhighlight.call(
                this,
                a[b],
                this.settings.errorClass,
                ""
              ),
                this.findByName(a[b].name).removeClass(
                  this.settings.validClass
                );
          else
            a.removeClass(this.settings.errorClass).removeClass(
              this.settings.validClass
            );
        },
        numberOfInvalids: function () {
          return this.objectLength(this.invalid);
        },
        objectLength: function (a) {
          var b,
            c = 0;
          for (b in a) a[b] && c++;
          return c;
        },
        hideErrors: function () {
          this.hideThese(this.toHide);
        },
        hideThese: function (a) {
          a.not(this.containers).text(""), this.addWrapper(a).hide();
        },
        valid: function () {
          return 0 === this.size();
        },
        size: function () {
          return this.errorList.length;
        },
        focusInvalid: function () {
          if (this.settings.focusInvalid)
            try {
              a(
                this.findLastActive() ||
                  (this.errorList.length && this.errorList[0].element) ||
                  []
              )
                .filter(":visible")
                .focus()
                .trigger("focusin");
            } catch (b) {}
        },
        findLastActive: function () {
          var b = this.lastActive;
          return (
            b &&
            1 ===
              a.grep(this.errorList, function (a) {
                return a.element.name === b.name;
              }).length &&
            b
          );
        },
        elements: function () {
          var b = this,
            c = {};
          return a(this.currentForm)
            .find("input, select, textarea, [contenteditable]")
            .not(":submit, :reset, :image, :disabled")
            .not(this.settings.ignore)
            .filter(function () {
              var d = this.name || a(this).attr("name");
              return (
                !d &&
                  b.settings.debug &&
                  window.console &&
                  console.error("%o has no name assigned", this),
                this.hasAttribute("contenteditable") &&
                  (this.form = a(this).closest("form")[0]),
                !(d in c || !b.objectLength(a(this).rules())) &&
                  ((c[d] = !0), !0)
              );
            });
        },
        clean: function (b) {
          return a(b)[0];
        },
        errors: function () {
          var b = this.settings.errorClass.split(" ").join(".");
          return a(this.settings.errorElement + "." + b, this.errorContext);
        },
        resetInternals: function () {
          (this.successList = []),
            (this.errorList = []),
            (this.errorMap = {}),
            (this.toShow = a([])),
            (this.toHide = a([]));
        },
        reset: function () {
          this.resetInternals(), (this.currentElements = a([]));
        },
        prepareForm: function () {
          this.reset(), (this.toHide = this.errors().add(this.containers));
        },
        prepareElement: function (a) {
          this.reset(), (this.toHide = this.errorsFor(a));
        },
        elementValue: function (b) {
          var c,
            d,
            e = a(b),
            f = b.type;
          return "radio" === f || "checkbox" === f
            ? this.findByName(b.name).filter(":checked").val()
            : "number" === f && "undefined" != typeof b.validity
            ? b.validity.badInput
              ? "NaN"
              : e.val()
            : ((c = b.hasAttribute("contenteditable") ? e.text() : e.val()),
              "file" === f
                ? "C:\\fakepath\\" === c.substr(0, 12)
                  ? c.substr(12)
                  : ((d = c.lastIndexOf("/")),
                    d >= 0
                      ? c.substr(d + 1)
                      : ((d = c.lastIndexOf("\\")),
                        d >= 0 ? c.substr(d + 1) : c))
                : "string" == typeof c
                ? c.replace(/\r/g, "")
                : c);
        },
        check: function (b) {
          b = this.validationTargetFor(this.clean(b));
          var c,
            d,
            e,
            f = a(b).rules(),
            g = a.map(f, function (a, b) {
              return b;
            }).length,
            h = !1,
            i = this.elementValue(b);
          if ("function" == typeof f.normalizer) {
            if (((i = f.normalizer.call(b, i)), "string" != typeof i))
              throw new TypeError(
                "The normalizer should return a string value."
              );
            delete f.normalizer;
          }
          for (d in f) {
            e = { method: d, parameters: f[d] };
            try {
              if (
                ((c = a.validator.methods[d].call(this, i, b, e.parameters)),
                "dependency-mismatch" === c && 1 === g)
              ) {
                h = !0;
                continue;
              }
              if (((h = !1), "pending" === c))
                return void (this.toHide = this.toHide.not(this.errorsFor(b)));
              if (!c) return this.formatAndAdd(b, e), !1;
            } catch (j) {
              throw (
                (this.settings.debug &&
                  window.console &&
                  console.log(
                    "Exception occurred when checking element " +
                      b.id +
                      ", check the '" +
                      e.method +
                      "' method.",
                    j
                  ),
                j instanceof TypeError &&
                  (j.message +=
                    ".  Exception occurred when checking element " +
                    b.id +
                    ", check the '" +
                    e.method +
                    "' method."),
                j)
              );
            }
          }
          if (!h) return this.objectLength(f) && this.successList.push(b), !0;
        },
        customDataMessage: function (b, c) {
          return (
            a(b).data(
              "msg" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()
            ) || a(b).data("msg")
          );
        },
        customMessage: function (a, b) {
          var c = this.settings.messages[a];
          return c && (c.constructor === String ? c : c[b]);
        },
        findDefined: function () {
          for (var a = 0; a < arguments.length; a++)
            if (void 0 !== arguments[a]) return arguments[a];
        },
        defaultMessage: function (b, c) {
          "string" == typeof c && (c = { method: c });
          var d = this.findDefined(
              this.customMessage(b.name, c.method),
              this.customDataMessage(b, c.method),
              (!this.settings.ignoreTitle && b.title) || void 0,
              a.validator.messages[c.method],
              "<strong>Warning: No message defined for " + b.name + "</strong>"
            ),
            e = /\$?\{(\d+)\}/g;
          return (
            "function" == typeof d
              ? (d = d.call(this, c.parameters, b))
              : e.test(d) &&
                (d = a.validator.format(d.replace(e, "{$1}"), c.parameters)),
            d
          );
        },
        formatAndAdd: function (a, b) {
          var c = this.defaultMessage(a, b);
          this.errorList.push({ message: c, element: a, method: b.method }),
            (this.errorMap[a.name] = c),
            (this.submitted[a.name] = c);
        },
        addWrapper: function (a) {
          return (
            this.settings.wrapper &&
              (a = a.add(a.parent(this.settings.wrapper))),
            a
          );
        },
        defaultShowErrors: function () {
          var a, b, c;
          for (a = 0; this.errorList[a]; a++)
            (c = this.errorList[a]),
              this.settings.highlight &&
                this.settings.highlight.call(
                  this,
                  c.element,
                  this.settings.errorClass,
                  this.settings.validClass
                ),
              this.showLabel(c.element, c.message);
          if (
            (this.errorList.length &&
              (this.toShow = this.toShow.add(this.containers)),
            this.settings.success)
          )
            for (a = 0; this.successList[a]; a++)
              this.showLabel(this.successList[a]);
          if (this.settings.unhighlight)
            for (a = 0, b = this.validElements(); b[a]; a++)
              this.settings.unhighlight.call(
                this,
                b[a],
                this.settings.errorClass,
                this.settings.validClass
              );
          (this.toHide = this.toHide.not(this.toShow)),
            this.hideErrors(),
            this.addWrapper(this.toShow).show();
        },
        validElements: function () {
          return this.currentElements.not(this.invalidElements());
        },
        invalidElements: function () {
          return a(this.errorList).map(function () {
            return this.element;
          });
        },
        showLabel: function (b, c) {
          var d,
            e,
            f,
            g,
            h = this.errorsFor(b),
            i = this.idOrName(b),
            j = a(b).attr("aria-describedby");
          h.length
            ? (h
                .removeClass(this.settings.validClass)
                .addClass(this.settings.errorClass),
              h.html(c))
            : ((h = a("<" + this.settings.errorElement + ">")
                .attr("id", i + "-error")
                .addClass(this.settings.errorClass)
                .html(c || "")),
              (d = h),
              this.settings.wrapper &&
                (d = h
                  .hide()
                  .show()
                  .wrap("<" + this.settings.wrapper + "/>")
                  .parent()),
              this.labelContainer.length
                ? this.labelContainer.append(d)
                : this.settings.errorPlacement
                ? this.settings.errorPlacement.call(this, d, a(b))
                : d.insertAfter(b),
              h.is("label")
                ? h.attr("for", i)
                : 0 ===
                    h.parents("label[for='" + this.escapeCssMeta(i) + "']")
                      .length &&
                  ((f = h.attr("id")),
                  j
                    ? j.match(
                        new RegExp("\\b" + this.escapeCssMeta(f) + "\\b")
                      ) || (j += " " + f)
                    : (j = f),
                  a(b).attr("aria-describedby", j),
                  (e = this.groups[b.name]),
                  e &&
                    ((g = this),
                    a.each(g.groups, function (b, c) {
                      c === e &&
                        a(
                          "[name='" + g.escapeCssMeta(b) + "']",
                          g.currentForm
                        ).attr("aria-describedby", h.attr("id"));
                    })))),
            !c &&
              this.settings.success &&
              (h.text(""),
              "string" == typeof this.settings.success
                ? h.addClass(this.settings.success)
                : this.settings.success(h, b)),
            (this.toShow = this.toShow.add(h));
        },
        errorsFor: function (b) {
          var c = this.escapeCssMeta(this.idOrName(b)),
            d = a(b).attr("aria-describedby"),
            e = "label[for='" + c + "'], label[for='" + c + "'] *";
          return (
            d && (e = e + ", #" + this.escapeCssMeta(d).replace(/\s+/g, ", #")),
            this.errors().filter(e)
          );
        },
        escapeCssMeta: function (a) {
          return a.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1");
        },
        idOrName: function (a) {
          return (
            this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name)
          );
        },
        validationTargetFor: function (b) {
          return (
            this.checkable(b) && (b = this.findByName(b.name)),
            a(b).not(this.settings.ignore)[0]
          );
        },
        checkable: function (a) {
          return /radio|checkbox/i.test(a.type);
        },
        findByName: function (b) {
          return a(this.currentForm).find(
            "[name='" + this.escapeCssMeta(b) + "']"
          );
        },
        getLength: function (b, c) {
          switch (c.nodeName.toLowerCase()) {
            case "select":
              return a("option:selected", c).length;
            case "input":
              if (this.checkable(c))
                return this.findByName(c.name).filter(":checked").length;
          }
          return b.length;
        },
        depend: function (a, b) {
          return (
            !this.dependTypes[typeof a] || this.dependTypes[typeof a](a, b)
          );
        },
        dependTypes: {
          boolean: function (a) {
            return a;
          },
          string: function (b, c) {
            return !!a(b, c.form).length;
          },
          function: function (a, b) {
            return a(b);
          },
        },
        optional: function (b) {
          var c = this.elementValue(b);
          return (
            !a.validator.methods.required.call(this, c, b) &&
            "dependency-mismatch"
          );
        },
        startRequest: function (b) {
          this.pending[b.name] ||
            (this.pendingRequest++,
            a(b).addClass(this.settings.pendingClass),
            (this.pending[b.name] = !0));
        },
        stopRequest: function (b, c) {
          this.pendingRequest--,
            this.pendingRequest < 0 && (this.pendingRequest = 0),
            delete this.pending[b.name],
            a(b).removeClass(this.settings.pendingClass),
            c && 0 === this.pendingRequest && this.formSubmitted && this.form()
              ? (a(this.currentForm).submit(), (this.formSubmitted = !1))
              : !c &&
                0 === this.pendingRequest &&
                this.formSubmitted &&
                (a(this.currentForm).triggerHandler("invalid-form", [this]),
                (this.formSubmitted = !1));
        },
        previousValue: function (b, c) {
          return (
            (c = ("string" == typeof c && c) || "remote"),
            a.data(b, "previousValue") ||
              a.data(b, "previousValue", {
                old: null,
                valid: !0,
                message: this.defaultMessage(b, { method: c }),
              })
          );
        },
        destroy: function () {
          this.resetForm(),
            a(this.currentForm)
              .off(".validate")
              .removeData("validator")
              .find(".validate-equalTo-blur")
              .off(".validate-equalTo")
              .removeClass("validate-equalTo-blur");
        },
      },
      classRuleSettings: {
        required: { required: !0 },
        email: { email: !0 },
        url: { url: !0 },
        date: { date: !0 },
        dateISO: { dateISO: !0 },
        number: { number: !0 },
        digits: { digits: !0 },
        creditcard: { creditcard: !0 },
      },
      addClassRules: function (b, c) {
        b.constructor === String
          ? (this.classRuleSettings[b] = c)
          : a.extend(this.classRuleSettings, b);
      },
      classRules: function (b) {
        var c = {},
          d = a(b).attr("class");
        return (
          d &&
            a.each(d.split(" "), function () {
              this in a.validator.classRuleSettings &&
                a.extend(c, a.validator.classRuleSettings[this]);
            }),
          c
        );
      },
      normalizeAttributeRule: function (a, b, c, d) {
        /min|max|step/.test(c) &&
          (null === b || /number|range|text/.test(b)) &&
          ((d = Number(d)), isNaN(d) && (d = void 0)),
          d || 0 === d ? (a[c] = d) : b === c && "range" !== b && (a[c] = !0);
      },
      attributeRules: function (b) {
        var c,
          d,
          e = {},
          f = a(b),
          g = b.getAttribute("type");
        for (c in a.validator.methods)
          "required" === c
            ? ((d = b.getAttribute(c)), "" === d && (d = !0), (d = !!d))
            : (d = f.attr(c)),
            this.normalizeAttributeRule(e, g, c, d);
        return (
          e.maxlength &&
            /-1|2147483647|524288/.test(e.maxlength) &&
            delete e.maxlength,
          e
        );
      },
      dataRules: function (b) {
        var c,
          d,
          e = {},
          f = a(b),
          g = b.getAttribute("type");
        for (c in a.validator.methods)
          (d = f.data(
            "rule" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()
          )),
            this.normalizeAttributeRule(e, g, c, d);
        return e;
      },
      staticRules: function (b) {
        var c = {},
          d = a.data(b.form, "validator");
        return (
          d.settings.rules &&
            (c = a.validator.normalizeRule(d.settings.rules[b.name]) || {}),
          c
        );
      },
      normalizeRules: function (b, c) {
        return (
          a.each(b, function (d, e) {
            if (e === !1) return void delete b[d];
            if (e.param || e.depends) {
              var f = !0;
              switch (typeof e.depends) {
                case "string":
                  f = !!a(e.depends, c.form).length;
                  break;
                case "function":
                  f = e.depends.call(c, c);
              }
              f
                ? (b[d] = void 0 === e.param || e.param)
                : (a.data(c.form, "validator").resetElements(a(c)),
                  delete b[d]);
            }
          }),
          a.each(b, function (d, e) {
            b[d] = a.isFunction(e) && "normalizer" !== d ? e(c) : e;
          }),
          a.each(["minlength", "maxlength"], function () {
            b[this] && (b[this] = Number(b[this]));
          }),
          a.each(["rangelength", "range"], function () {
            var c;
            b[this] &&
              (a.isArray(b[this])
                ? (b[this] = [Number(b[this][0]), Number(b[this][1])])
                : "string" == typeof b[this] &&
                  ((c = b[this].replace(/[\[\]]/g, "").split(/[\s,]+/)),
                  (b[this] = [Number(c[0]), Number(c[1])])));
          }),
          a.validator.autoCreateRanges &&
            (null != b.min &&
              null != b.max &&
              ((b.range = [b.min, b.max]), delete b.min, delete b.max),
            null != b.minlength &&
              null != b.maxlength &&
              ((b.rangelength = [b.minlength, b.maxlength]),
              delete b.minlength,
              delete b.maxlength)),
          b
        );
      },
      normalizeRule: function (b) {
        if ("string" == typeof b) {
          var c = {};
          a.each(b.split(/\s/), function () {
            c[this] = !0;
          }),
            (b = c);
        }
        return b;
      },
      addMethod: function (b, c, d) {
        (a.validator.methods[b] = c),
          (a.validator.messages[b] =
            void 0 !== d ? d : a.validator.messages[b]),
          c.length < 3 &&
            a.validator.addClassRules(b, a.validator.normalizeRule(b));
      },
      methods: {
        required: function (b, c, d) {
          if (!this.depend(d, c)) return "dependency-mismatch";
          if ("select" === c.nodeName.toLowerCase()) {
            var e = a(c).val();
            return e && e.length > 0;
          }
          return this.checkable(c) ? this.getLength(b, c) > 0 : b.length > 0;
        },
        email: function (a, b) {
          return (
            this.optional(b) ||
            /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(
              a
            )
          );
        },
        url: function (a, b) {
          return (
            this.optional(b) ||
            /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(
              a
            )
          );
        },
        date: function (a, b) {
          return (
            this.optional(b) || !/Invalid|NaN/.test(new Date(a).toString())
          );
        },
        dateISO: function (a, b) {
          return (
            this.optional(b) ||
            /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(
              a
            )
          );
        },
        number: function (a, b) {
          return (
            this.optional(b) ||
            /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a)
          );
        },
        digits: function (a, b) {
          return this.optional(b) || /^\d+$/.test(a);
        },
        minlength: function (b, c, d) {
          var e = a.isArray(b) ? b.length : this.getLength(b, c);
          return this.optional(c) || e >= d;
        },
        maxlength: function (b, c, d) {
          var e = a.isArray(b) ? b.length : this.getLength(b, c);
          return this.optional(c) || e <= d;
        },
        rangelength: function (b, c, d) {
          var e = a.isArray(b) ? b.length : this.getLength(b, c);
          return this.optional(c) || (e >= d[0] && e <= d[1]);
        },
        min: function (a, b, c) {
          return this.optional(b) || a >= c;
        },
        max: function (a, b, c) {
          return this.optional(b) || a <= c;
        },
        range: function (a, b, c) {
          return this.optional(b) || (a >= c[0] && a <= c[1]);
        },
        step: function (b, c, d) {
          var e,
            f = a(c).attr("type"),
            g = "Step attribute on input type " + f + " is not supported.",
            h = ["text", "number", "range"],
            i = new RegExp("\\b" + f + "\\b"),
            j = f && !i.test(h.join()),
            k = function (a) {
              var b = ("" + a).match(/(?:\.(\d+))?$/);
              return b && b[1] ? b[1].length : 0;
            },
            l = function (a) {
              return Math.round(a * Math.pow(10, e));
            },
            m = !0;
          if (j) throw new Error(g);
          return (
            (e = k(d)),
            (k(b) > e || l(b) % l(d) !== 0) && (m = !1),
            this.optional(c) || m
          );
        },
        equalTo: function (b, c, d) {
          var e = a(d);
          return (
            this.settings.onfocusout &&
              e.not(".validate-equalTo-blur").length &&
              e
                .addClass("validate-equalTo-blur")
                .on("blur.validate-equalTo", function () {
                  a(c).valid();
                }),
            b === e.val()
          );
        },
        remote: function (b, c, d, e) {
          if (this.optional(c)) return "dependency-mismatch";
          e = ("string" == typeof e && e) || "remote";
          var f,
            g,
            h,
            i = this.previousValue(c, e);
          return (
            this.settings.messages[c.name] ||
              (this.settings.messages[c.name] = {}),
            (i.originalMessage =
              i.originalMessage || this.settings.messages[c.name][e]),
            (this.settings.messages[c.name][e] = i.message),
            (d = ("string" == typeof d && { url: d }) || d),
            (h = a.param(a.extend({ data: b }, d.data))),
            i.old === h
              ? i.valid
              : ((i.old = h),
                (f = this),
                this.startRequest(c),
                (g = {}),
                (g[c.name] = b),
                a.ajax(
                  a.extend(
                    !0,
                    {
                      mode: "abort",
                      port: "validate" + c.name,
                      dataType: "json",
                      data: g,
                      context: f.currentForm,
                      success: function (a) {
                        var d,
                          g,
                          h,
                          j = a === !0 || "true" === a;
                        (f.settings.messages[c.name][e] = i.originalMessage),
                          j
                            ? ((h = f.formSubmitted),
                              f.resetInternals(),
                              (f.toHide = f.errorsFor(c)),
                              (f.formSubmitted = h),
                              f.successList.push(c),
                              (f.invalid[c.name] = !1),
                              f.showErrors())
                            : ((d = {}),
                              (g =
                                a ||
                                f.defaultMessage(c, {
                                  method: e,
                                  parameters: b,
                                })),
                              (d[c.name] = i.message = g),
                              (f.invalid[c.name] = !0),
                              f.showErrors(d)),
                          (i.valid = j),
                          f.stopRequest(c, j);
                      },
                    },
                    d
                  )
                ),
                "pending")
          );
        },
      },
    });
  var b,
    c = {};
  return (
    a.ajaxPrefilter
      ? a.ajaxPrefilter(function (a, b, d) {
          var e = a.port;
          "abort" === a.mode && (c[e] && c[e].abort(), (c[e] = d));
        })
      : ((b = a.ajax),
        (a.ajax = function (d) {
          var e = ("mode" in d ? d : a.ajaxSettings).mode,
            f = ("port" in d ? d : a.ajaxSettings).port;
          return "abort" === e
            ? (c[f] && c[f].abort(), (c[f] = b.apply(this, arguments)), c[f])
            : b.apply(this, arguments);
        })),
    a
  );
});
var GPLUS_URL = "/india/complete/google-plus/";
var GPLUS_PROFILE_UPDATE_URL = "/india/google-plus/update/";
var CLIENT_ID =
  "934240995862-576kvkp9kfrb7gr2r0nle52vf9kr7k8k.apps.googleusercontent.com";
var CURRENY_COUNTRY = "IN";

(function (w, d, s, l, i) {
  w[l] = w[l] || [];
  w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
  var f = d.getElementsByTagName(s)[0],
    j = d.createElement(s),
    dl = l != "dataLayer" ? "&l=" + l : "";
  j.async = true;
  j.src = "//www.googletagmanager.com/gtm.js?id=" + i + dl;
  f.parentNode.insertBefore(j, f);
})(window, document, "script", "dataLayer", "GTM-WKXZ48");
var B2C_URL_PREFIX = "";
(function (c, d) {
  var b = "2.9999.8";
  if (c.support === d) {
    c.support = { opacity: !c.browser.msie };
  }
  function g(t) {
    if (c.fn.cycle.debug) {
      f(t);
    }
  }
  function f() {
    if (window.console && console.log) {
      console.log("[cycle] " + Array.prototype.join.call(arguments, " "));
    }
  }
  c.expr[":"].paused = function (s) {
    return s.cyclePause;
  };
  c.fn.cycle = function (t, s) {
    var u = { s: this.selector, c: this.context };
    if (this.length === 0 && t != "stop") {
      if (!c.isReady && u.s) {
        f("DOM not ready, queuing slideshow");
        c(function () {
          c(u.s, u.c).cycle(t, s);
        });
        return this;
      }
      f(
        "terminating; zero elements found by selector" +
          (c.isReady ? "" : " (DOM not ready)")
      );
      return this;
    }
    return this.each(function () {
      var y = l(this, t, s);
      if (y === false) {
        return;
      }
      y.updateActivePagerLink =
        y.updateActivePagerLink || c.fn.cycle.updateActivePagerLink;
      if (this.cycleTimeout) {
        clearTimeout(this.cycleTimeout);
      }
      this.cycleTimeout = this.cyclePause = 0;
      this.cycleStop = 0;
      var z = c(this);
      var A = y.slideExpr ? c(y.slideExpr, this) : z.children();
      var w = A.get();
      if (w.length < 2) {
        f("terminating; too few slides: " + w.length);
        return;
      }
      var v = q(z, A, w, y, u);
      if (v === false) {
        return;
      }
      var x = v.continuous
        ? 10
        : m(w[v.currSlide], w[v.nextSlide], v, !v.backwards);
      if (x) {
        x += v.delay || 0;
        if (x < 10) {
          x = 10;
        }
        g("first timeout: " + x);
        this.cycleTimeout = setTimeout(function () {
          n(w, v, 0, !y.backwards);
        }, x);
      }
    });
  };
  function k(s, v, u) {
    var w = c(s).data("cycle.opts");
    if (!w) {
      return;
    }
    var t = !!s.cyclePause;
    if (t && w.paused) {
      w.paused(s, w, v, u);
    } else {
      if (!t && w.resumed) {
        w.resumed(s, w, v, u);
      }
    }
  }
  function l(s, v, t) {
    if (s.cycleStop === d) {
      s.cycleStop = 0;
    }
    if (v === d || v === null) {
      v = {};
    }
    if (v.constructor == String) {
      switch (v) {
        case "destroy":
        case "stop":
          var x = c(s).data("cycle.opts");
          if (!x) {
            return false;
          }
          s.cycleStop++;
          if (s.cycleTimeout) {
            clearTimeout(s.cycleTimeout);
          }
          s.cycleTimeout = 0;
          if (x.elements) {
            c(x.elements).stop();
          }
          c(s).removeData("cycle.opts");
          if (v == "destroy") {
            r(s, x);
          }
          return false;
        case "toggle":
          s.cyclePause = s.cyclePause === 1 ? 0 : 1;
          w(s.cyclePause, t, s);
          k(s);
          return false;
        case "pause":
          s.cyclePause = 1;
          k(s);
          return false;
        case "resume":
          s.cyclePause = 0;
          w(false, t, s);
          k(s);
          return false;
        case "prev":
        case "next":
          x = c(s).data("cycle.opts");
          if (!x) {
            f('options not found, "prev/next" ignored');
            return false;
          }
          c.fn.cycle[v](x);
          return false;
        default:
          v = { fx: v };
      }
      return v;
    } else {
      if (v.constructor == Number) {
        var u = v;
        v = c(s).data("cycle.opts");
        if (!v) {
          f("options not found, can not advance slide");
          return false;
        }
        if (u < 0 || u >= v.elements.length) {
          f("invalid slide index: " + u);
          return false;
        }
        v.nextSlide = u;
        if (s.cycleTimeout) {
          clearTimeout(s.cycleTimeout);
          s.cycleTimeout = 0;
        }
        if (typeof t == "string") {
          v.oneTimeFx = t;
        }
        n(v.elements, v, 1, u >= v.currSlide);
        return false;
      }
    }
    return v;
    function w(z, A, y) {
      if (!z && A === true) {
        var B = c(y).data("cycle.opts");
        if (!B) {
          f("options not found, can not resume");
          return false;
        }
        if (y.cycleTimeout) {
          clearTimeout(y.cycleTimeout);
          y.cycleTimeout = 0;
        }
        n(B.elements, B, 1, !B.backwards);
      }
    }
  }
  function e(s, t) {
    if (!c.support.opacity && t.cleartype && s.style.filter) {
      try {
        s.style.removeAttribute("filter");
      } catch (u) {}
    }
  }
  function r(s, t) {
    if (t.next) {
      c(t.next).unbind(t.prevNextEvent);
    }
    if (t.prev) {
      c(t.prev).unbind(t.prevNextEvent);
    }
    if (t.pager || t.pagerAnchorBuilder) {
      c.each(t.pagerAnchors || [], function () {
        this.unbind().remove();
      });
    }
    t.pagerAnchors = null;
    c(s).unbind("mouseenter.cycle mouseleave.cycle");
    if (t.destroy) {
      t.destroy(t);
    }
  }
  function q(C, Q, z, y, J) {
    var s;
    var H = c.extend(
      {},
      c.fn.cycle.defaults,
      y || {},
      c.metadata ? C.metadata() : c.meta ? C.data() : {}
    );
    var F = c.isFunction(C.data) ? C.data(H.metaAttr) : null;
    if (F) {
      H = c.extend(H, F);
    }
    if (H.autostop) {
      H.countdown = H.autostopCount || z.length;
    }
    var u = C[0];
    C.data("cycle.opts", H);
    H.$cont = C;
    H.stopCount = u.cycleStop;
    H.elements = z;
    H.before = H.before ? [H.before] : [];
    H.after = H.after ? [H.after] : [];
    if (!c.support.opacity && H.cleartype) {
      H.after.push(function () {
        e(this, H);
      });
    }
    if (H.continuous) {
      H.after.push(function () {
        n(z, H, 0, !H.backwards);
      });
    }
    i(H);
    if (!c.support.opacity && H.cleartype && !H.cleartypeNoBg) {
      a(Q);
    }
    if (C.css("position") == "static") {
      C.css("position", "relative");
    }
    if (H.width) {
      C.width(H.width);
    }
    if (H.height && H.height != "auto") {
      C.height(H.height);
    }
    if (H.startingSlide !== d) {
      H.startingSlide = parseInt(H.startingSlide, 10);
      if (H.startingSlide >= z.length || H.startSlide < 0) {
        H.startingSlide = 0;
      } else {
        s = true;
      }
    } else {
      if (H.backwards) {
        H.startingSlide = z.length - 1;
      } else {
        H.startingSlide = 0;
      }
    }
    if (H.random) {
      H.randomMap = [];
      for (var O = 0; O < z.length; O++) {
        H.randomMap.push(O);
      }
      H.randomMap.sort(function (S, w) {
        return Math.random() - 0.5;
      });
      if (s) {
        for (var M = 0; M < z.length; M++) {
          if (H.startingSlide == H.randomMap[M]) {
            H.randomIndex = M;
          }
        }
      } else {
        H.randomIndex = 1;
        H.startingSlide = H.randomMap[1];
      }
    } else {
      if (H.startingSlide >= z.length) {
        H.startingSlide = 0;
      }
    }
    H.currSlide = H.startingSlide || 0;
    var B = H.startingSlide;
    Q.css({ position: "absolute", top: 0, left: 0 })
      .hide()
      .each(function (w) {
        var S;
        if (H.backwards) {
          S = B ? (w <= B ? z.length + (w - B) : B - w) : z.length - w;
        } else {
          S = B ? (w >= B ? z.length - (w - B) : B - w) : z.length - w;
        }
        c(this).css("z-index", S);
      });
    c(z[B]).css("opacity", 1).show();
    e(z[B], H);
    if (H.fit) {
      if (!H.aspect) {
        if (H.width) {
          Q.width(H.width);
        }
        if (H.height && H.height != "auto") {
          Q.height(H.height);
        }
      } else {
        Q.each(function () {
          var S = c(this);
          var w = H.aspect === true ? S.width() / S.height() : H.aspect;
          if (H.width && S.width() != H.width) {
            S.width(H.width);
            S.height(H.width / w);
          }
          if (H.height && S.height() < H.height) {
            S.height(H.height);
            S.width(H.height * w);
          }
        });
      }
    }
    if (H.center && (!H.fit || H.aspect)) {
      Q.each(function () {
        var w = c(this);
        w.css({
          "margin-left": H.width ? (H.width - w.width()) / 2 + "px" : 0,
          "margin-top": H.height ? (H.height - w.height()) / 2 + "px" : 0,
        });
      });
    }
    if (H.center && !H.fit && !H.slideResize) {
      Q.each(function () {
        var w = c(this);
        w.css({
          "margin-left": H.width ? (H.width - w.width()) / 2 + "px" : 0,
          "margin-top": H.height ? (H.height - w.height()) / 2 + "px" : 0,
        });
      });
    }
    var I = (H.containerResize || H.containerResizeHeight) && !C.innerHeight();
    if (I) {
      var A = 0,
        G = 0;
      for (var L = 0; L < z.length; L++) {
        var t = c(z[L]),
          R = t[0],
          E = t.outerWidth(),
          P = t.outerHeight();
        if (!E) {
          E = R.offsetWidth || R.width || t.attr("width");
        }
        if (!P) {
          P = R.offsetHeight || R.height || t.attr("height");
        }
        A = E > A ? E : A;
        G = P > G ? P : G;
      }
      if (H.containerResize && A > 0 && G > 0) {
        C.css({ width: A + "px", height: G + "px" });
      }
      if (H.containerResizeHeight && G > 0) {
        C.css({ height: G + "px" });
      }
    }
    var x = false;
    if (H.pause) {
      C.bind("mouseenter.cycle", function () {
        x = true;
        this.cyclePause++;
        k(u, true);
      }).bind("mouseleave.cycle", function () {
        if (x) {
          this.cyclePause--;
        }
        k(u, true);
      });
    }
    if (o(H) === false) {
      return false;
    }
    var v = false;
    y.requeueAttempts = y.requeueAttempts || 0;
    Q.each(function () {
      var U = c(this);
      this.cycleH =
        H.fit && H.height
          ? H.height
          : U.height() ||
            this.offsetHeight ||
            this.height ||
            U.attr("height") ||
            0;
      this.cycleW =
        H.fit && H.width
          ? H.width
          : U.width() || this.offsetWidth || this.width || U.attr("width") || 0;
      if (U.is("img")) {
        var S =
          c.browser.msie &&
          this.cycleW == 28 &&
          this.cycleH == 30 &&
          !this.complete;
        var V =
          c.browser.mozilla &&
          this.cycleW == 34 &&
          this.cycleH == 19 &&
          !this.complete;
        var T =
          c.browser.opera &&
          ((this.cycleW == 42 && this.cycleH == 19) ||
            (this.cycleW == 37 && this.cycleH == 17)) &&
          !this.complete;
        var w = this.cycleH === 0 && this.cycleW === 0 && !this.complete;
        if (S || V || T || w) {
          if (J.s && H.requeueOnImageNotLoaded && ++y.requeueAttempts < 100) {
            f(
              y.requeueAttempts,
              " - img slide not loaded, requeuing slideshow: ",
              this.src,
              this.cycleW,
              this.cycleH
            );
            setTimeout(function () {
              c(J.s, J.c).cycle(y);
            }, H.requeueTimeout);
            v = true;
            return false;
          } else {
            f(
              "could not determine size of image: " + this.src,
              this.cycleW,
              this.cycleH
            );
          }
        }
      }
      return true;
    });
    if (v) {
      return false;
    }
    H.cssBefore = H.cssBefore || {};
    H.cssAfter = H.cssAfter || {};
    H.cssFirst = H.cssFirst || {};
    H.animIn = H.animIn || {};
    H.animOut = H.animOut || {};
    Q.not(":eq(" + B + ")").css(H.cssBefore);
    c(Q[B]).css(H.cssFirst);
    if (H.timeout) {
      H.timeout = parseInt(H.timeout, 10);
      if (H.speed.constructor == String) {
        H.speed = c.fx.speeds[H.speed] || parseInt(H.speed, 10);
      }
      if (!H.sync) {
        H.speed = H.speed / 2;
      }
      var K = H.fx == "none" ? 0 : H.fx == "shuffle" ? 500 : 250;
      while (H.timeout - H.speed < K) {
        H.timeout += H.speed;
      }
    }
    if (H.easing) {
      H.easeIn = H.easeOut = H.easing;
    }
    if (!H.speedIn) {
      H.speedIn = H.speed;
    }
    if (!H.speedOut) {
      H.speedOut = H.speed;
    }
    H.slideCount = z.length;
    H.currSlide = H.lastSlide = B;
    if (H.random) {
      if (++H.randomIndex == z.length) {
        H.randomIndex = 0;
      }
      H.nextSlide = H.randomMap[H.randomIndex];
    } else {
      if (H.backwards) {
        H.nextSlide =
          H.startingSlide === 0 ? z.length - 1 : H.startingSlide - 1;
      } else {
        H.nextSlide = H.startingSlide >= z.length - 1 ? 0 : H.startingSlide + 1;
      }
    }
    if (!H.multiFx) {
      var N = c.fn.cycle.transitions[H.fx];
      if (c.isFunction(N)) {
        N(C, Q, H);
      } else {
        if (H.fx != "custom" && !H.multiFx) {
          f("unknown transition: " + H.fx, "; slideshow terminating");
          return false;
        }
      }
    }
    var D = Q[B];
    if (!H.skipInitializationCallbacks) {
      if (H.before.length) {
        H.before[0].apply(D, [D, D, H, true]);
      }
      if (H.after.length) {
        H.after[0].apply(D, [D, D, H, true]);
      }
    }
    if (H.next) {
      c(H.next).bind(H.prevNextEvent, function () {
        return h(H, 1);
      });
    }
    if (H.prev) {
      c(H.prev).bind(H.prevNextEvent, function () {
        return h(H, 0);
      });
    }
    if (H.pager || H.pagerAnchorBuilder) {
      p(z, H);
    }
    j(H, z);
    return H;
  }
  function i(s) {
    s.original = { before: [], after: [] };
    s.original.cssBefore = c.extend({}, s.cssBefore);
    s.original.cssAfter = c.extend({}, s.cssAfter);
    s.original.animIn = c.extend({}, s.animIn);
    s.original.animOut = c.extend({}, s.animOut);
    c.each(s.before, function () {
      s.original.before.push(this);
    });
    c.each(s.after, function () {
      s.original.after.push(this);
    });
  }
  function o(y) {
    var w,
      u,
      t = c.fn.cycle.transitions;
    if (y.fx.indexOf(",") > 0) {
      y.multiFx = true;
      y.fxs = y.fx.replace(/\s*/g, "").split(",");
      for (w = 0; w < y.fxs.length; w++) {
        var x = y.fxs[w];
        u = t[x];
        if (!u || !t.hasOwnProperty(x) || !c.isFunction(u)) {
          f("discarding unknown transition: ", x);
          y.fxs.splice(w, 1);
          w--;
        }
      }
      if (!y.fxs.length) {
        f("No valid transitions named; slideshow terminating.");
        return false;
      }
    } else {
      if (y.fx == "all") {
        y.multiFx = true;
        y.fxs = [];
        for (var z in t) {
          if (t.hasOwnProperty(z)) {
            u = t[z];
            if (t.hasOwnProperty(z) && c.isFunction(u)) {
              y.fxs.push(z);
            }
          }
        }
      }
    }
    if (y.multiFx && y.randomizeEffects) {
      var v = Math.floor(Math.random() * 20) + 30;
      for (w = 0; w < v; w++) {
        var s = Math.floor(Math.random() * y.fxs.length);
        y.fxs.push(y.fxs.splice(s, 1)[0]);
      }
      g("randomized fx sequence: ", y.fxs);
    }
    return true;
  }
  function j(t, s) {
    t.addSlide = function (v, w) {
      var u = c(v),
        x = u[0];
      if (!t.autostopCount) {
        t.countdown++;
      }
      s[w ? "unshift" : "push"](x);
      if (t.els) {
        t.els[w ? "unshift" : "push"](x);
      }
      t.slideCount = s.length;
      if (t.random) {
        t.randomMap.push(t.slideCount - 1);
        t.randomMap.sort(function (z, y) {
          return Math.random() - 0.5;
        });
      }
      u.css("position", "absolute");
      u[w ? "prependTo" : "appendTo"](t.$cont);
      if (w) {
        t.currSlide++;
        t.nextSlide++;
      }
      if (!c.support.opacity && t.cleartype && !t.cleartypeNoBg) {
        a(u);
      }
      if (t.fit && t.width) {
        u.width(t.width);
      }
      if (t.fit && t.height && t.height != "auto") {
        u.height(t.height);
      }
      x.cycleH = t.fit && t.height ? t.height : u.height();
      x.cycleW = t.fit && t.width ? t.width : u.width();
      u.css(t.cssBefore);
      if (t.pager || t.pagerAnchorBuilder) {
        c.fn.cycle.createPagerAnchor(s.length - 1, x, c(t.pager), s, t);
      }
      if (c.isFunction(t.onAddSlide)) {
        t.onAddSlide(u);
      } else {
        u.hide();
      }
    };
  }
  c.fn.cycle.resetState = function (t, s) {
    s = s || t.fx;
    t.before = [];
    t.after = [];
    t.cssBefore = c.extend({}, t.original.cssBefore);
    t.cssAfter = c.extend({}, t.original.cssAfter);
    t.animIn = c.extend({}, t.original.animIn);
    t.animOut = c.extend({}, t.original.animOut);
    t.fxFn = null;
    c.each(t.original.before, function () {
      t.before.push(this);
    });
    c.each(t.original.after, function () {
      t.after.push(this);
    });
    var u = c.fn.cycle.transitions[s];
    if (c.isFunction(u)) {
      u(t.$cont, c(t.elements), t);
    }
  };
  function n(y, s, x, A) {
    var v = s.$cont[0],
      D = y[s.currSlide],
      B = y[s.nextSlide];
    if (x && s.busy && s.manualTrump) {
      g("manualTrump in go(), stopping active transition");
      c(y).stop(true, true);
      s.busy = 0;
      clearTimeout(v.cycleTimeout);
    }
    if (s.busy) {
      g("transition active, ignoring new tx request");
      return;
    }
    if (v.cycleStop != s.stopCount || (v.cycleTimeout === 0 && !x)) {
      return;
    }
    if (
      !x &&
      !v.cyclePause &&
      !s.bounce &&
      ((s.autostop && --s.countdown <= 0) ||
        (s.nowrap && !s.random && s.nextSlide < s.currSlide))
    ) {
      if (s.end) {
        s.end(s);
      }
      return;
    }
    var z = false;
    if ((x || !v.cyclePause) && s.nextSlide != s.currSlide) {
      z = true;
      var w = s.fx;
      D.cycleH = D.cycleH || c(D).height();
      D.cycleW = D.cycleW || c(D).width();
      B.cycleH = B.cycleH || c(B).height();
      B.cycleW = B.cycleW || c(B).width();
      if (s.multiFx) {
        if (A && (s.lastFx === d || ++s.lastFx >= s.fxs.length)) {
          s.lastFx = 0;
        } else {
          if (!A && (s.lastFx === d || --s.lastFx < 0)) {
            s.lastFx = s.fxs.length - 1;
          }
        }
        w = s.fxs[s.lastFx];
      }
      if (s.oneTimeFx) {
        w = s.oneTimeFx;
        s.oneTimeFx = null;
      }
      c.fn.cycle.resetState(s, w);
      if (s.before.length) {
        c.each(s.before, function (E, F) {
          if (v.cycleStop != s.stopCount) {
            return;
          }
          F.apply(B, [D, B, s, A]);
        });
      }
      var t = function () {
        s.busy = 0;
        c.each(s.after, function (E, F) {
          if (v.cycleStop != s.stopCount) {
            return;
          }
          F.apply(B, [D, B, s, A]);
        });
        if (!v.cycleStop) {
          C();
        }
      };
      g(
        "tx firing(" +
          w +
          "); currSlide: " +
          s.currSlide +
          "; nextSlide: " +
          s.nextSlide
      );
      s.busy = 1;
      if (s.fxFn) {
        s.fxFn(D, B, s, t, A, x && s.fastOnEvent);
      } else {
        if (c.isFunction(c.fn.cycle[s.fx])) {
          c.fn.cycle[s.fx](D, B, s, t, A, x && s.fastOnEvent);
        } else {
          c.fn.cycle.custom(D, B, s, t, A, x && s.fastOnEvent);
        }
      }
    } else {
      C();
    }
    if (z || s.nextSlide == s.currSlide) {
      var u;
      s.lastSlide = s.currSlide;
      if (s.random) {
        s.currSlide = s.nextSlide;
        if (++s.randomIndex == y.length) {
          s.randomIndex = 0;
          s.randomMap.sort(function (F, E) {
            return Math.random() - 0.5;
          });
        }
        s.nextSlide = s.randomMap[s.randomIndex];
        if (s.nextSlide == s.currSlide) {
          s.nextSlide = s.currSlide == s.slideCount - 1 ? 0 : s.currSlide + 1;
        }
      } else {
        if (s.backwards) {
          u = s.nextSlide - 1 < 0;
          if (u && s.bounce) {
            s.backwards = !s.backwards;
            s.nextSlide = 1;
            s.currSlide = 0;
          } else {
            s.nextSlide = u ? y.length - 1 : s.nextSlide - 1;
            s.currSlide = u ? 0 : s.nextSlide + 1;
          }
        } else {
          u = s.nextSlide + 1 == y.length;
          if (u && s.bounce) {
            s.backwards = !s.backwards;
            s.nextSlide = y.length - 2;
            s.currSlide = y.length - 1;
          } else {
            s.nextSlide = u ? 0 : s.nextSlide + 1;
            s.currSlide = u ? y.length - 1 : s.nextSlide - 1;
          }
        }
      }
    }
    if (z && s.pager) {
      s.updateActivePagerLink(s.pager, s.currSlide, s.activePagerClass);
    }
    function C() {
      var E = 0,
        F = s.timeout;
      if (s.timeout && !s.continuous) {
        E = m(y[s.currSlide], y[s.nextSlide], s, A);
        if (s.fx == "shuffle") {
          E -= s.speedOut;
        }
      } else {
        if (s.continuous && v.cyclePause) {
          E = 10;
        }
      }
      if (E > 0) {
        v.cycleTimeout = setTimeout(function () {
          n(y, s, 0, !s.backwards);
        }, E);
      }
    }
  }
  c.fn.cycle.updateActivePagerLink = function (s, u, t) {
    c(s).each(function () {
      c(this).children().removeClass(t).eq(u).addClass(t);
    });
  };
  function m(x, v, w, u) {
    if (w.timeoutFn) {
      var s = w.timeoutFn.call(x, x, v, w, u);
      while (w.fx != "none" && s - w.speed < 250) {
        s += w.speed;
      }
      g("calculated timeout: " + s + "; speed: " + w.speed);
      if (s !== false) {
        return s;
      }
    }
    return w.timeout;
  }
  c.fn.cycle.next = function (s) {
    h(s, 1);
  };
  c.fn.cycle.prev = function (s) {
    h(s, 0);
  };
  function h(v, u) {
    var y = u ? 1 : -1;
    var t = v.elements;
    var x = v.$cont[0],
      w = x.cycleTimeout;
    if (w) {
      clearTimeout(w);
      x.cycleTimeout = 0;
    }
    if (v.random && y < 0) {
      v.randomIndex--;
      if (--v.randomIndex == -2) {
        v.randomIndex = t.length - 2;
      } else {
        if (v.randomIndex == -1) {
          v.randomIndex = t.length - 1;
        }
      }
      v.nextSlide = v.randomMap[v.randomIndex];
    } else {
      if (v.random) {
        v.nextSlide = v.randomMap[v.randomIndex];
      } else {
        v.nextSlide = v.currSlide + y;
        if (v.nextSlide < 0) {
          if (v.nowrap) {
            return false;
          }
          v.nextSlide = t.length - 1;
        } else {
          if (v.nextSlide >= t.length) {
            if (v.nowrap) {
              return false;
            }
            v.nextSlide = 0;
          }
        }
      }
    }
    var s = v.onPrevNextEvent || v.prevNextClick;
    if (c.isFunction(s)) {
      s(y > 0, v.nextSlide, t[v.nextSlide]);
    }
    n(t, v, 1, u);
    return false;
  }
  function p(t, u) {
    var s = c(u.pager);
    c.each(t, function (v, w) {
      c.fn.cycle.createPagerAnchor(v, w, s, t, u);
    });
    u.updateActivePagerLink(u.pager, u.startingSlide, u.activePagerClass);
  }
  c.fn.cycle.createPagerAnchor = function (x, u, z, w, t) {
    var A;
    if (c.isFunction(t.pagerAnchorBuilder)) {
      A = t.pagerAnchorBuilder(x, u);
      g("pagerAnchorBuilder(" + x + ", el) returned: " + A);
    } else {
      A = '<a href="#">' + (x + 1) + "</a>";
    }
    if (!A) {
      return;
    }
    var v = c(A);
    if (v.parents("body").length === 0) {
      var y = [];
      if (z.length > 1) {
        z.each(function () {
          var D = v.clone(true);
          c(this).append(D);
          y.push(D[0]);
        });
        v = c(y);
      } else {
        v.appendTo(z);
      }
    }
    t.pagerAnchors = t.pagerAnchors || [];
    t.pagerAnchors.push(v);
    var B = function (G) {
      G.preventDefault();
      t.nextSlide = x;
      var F = t.$cont[0],
        E = F.cycleTimeout;
      if (E) {
        clearTimeout(E);
        F.cycleTimeout = 0;
      }
      var D = t.onPagerEvent || t.pagerClick;
      if (c.isFunction(D)) {
        D(t.nextSlide, w[t.nextSlide]);
      }
      n(w, t, 1, t.currSlide < x);
    };
    if (/mouseenter|mouseover/i.test(t.pagerEvent)) {
      v.hover(B, function () {});
    } else {
      v.bind(t.pagerEvent, B);
    }
    if (!/^click/.test(t.pagerEvent) && !t.allowPagerClickBubble) {
      v.bind("click.cycle", function () {
        return false;
      });
    }
    var C = t.$cont[0];
    var s = false;
    if (t.pauseOnPagerHover) {
      v.hover(
        function () {
          s = true;
          C.cyclePause++;
          k(C, true, true);
        },
        function () {
          if (s) {
            C.cyclePause--;
          }
          k(C, true, true);
        }
      );
    }
  };
  c.fn.cycle.hopsFromLast = function (v, u) {
    var t,
      s = v.lastSlide,
      w = v.currSlide;
    if (u) {
      t = w > s ? w - s : v.slideCount - s;
    } else {
      t = w < s ? s - w : s + v.slideCount - w;
    }
    return t;
  };
  function a(u) {
    g("applying clearType background-color hack");
    function t(v) {
      v = parseInt(v, 10).toString(16);
      return v.length < 2 ? "0" + v : v;
    }
    function s(y) {
      for (; y && y.nodeName.toLowerCase() != "html"; y = y.parentNode) {
        var w = c.css(y, "background-color");
        if (w && w.indexOf("rgb") >= 0) {
          var x = w.match(/\d+/g);
          return "#" + t(x[0]) + t(x[1]) + t(x[2]);
        }
        if (w && w != "transparent") {
          return w;
        }
      }
      return "#ffffff";
    }
    u.each(function () {
      c(this).css("background-color", s(this));
    });
  }
  c.fn.cycle.commonReset = function (y, v, x, t, u, s) {
    c(x.elements).not(y).hide();
    if (typeof x.cssBefore.opacity == "undefined") {
      x.cssBefore.opacity = 1;
    }
    x.cssBefore.display = "block";
    if (x.slideResize && t !== false && v.cycleW > 0) {
      x.cssBefore.width = v.cycleW;
    }
    if (x.slideResize && u !== false && v.cycleH > 0) {
      x.cssBefore.height = v.cycleH;
    }
    x.cssAfter = x.cssAfter || {};
    x.cssAfter.display = "none";
    c(y).css("zIndex", x.slideCount + (s === true ? 1 : 0));
    c(v).css("zIndex", x.slideCount + (s === true ? 0 : 1));
  };
  c.fn.cycle.custom = function (E, y, s, v, x, t) {
    var D = c(E),
      z = c(y);
    var u = s.speedIn,
      C = s.speedOut,
      w = s.easeIn,
      B = s.easeOut;
    z.css(s.cssBefore);
    if (t) {
      if (typeof t == "number") {
        u = C = t;
      } else {
        u = C = 1;
      }
      w = B = null;
    }
    var A = function () {
      z.animate(s.animIn, u, w, function () {
        v();
      });
    };
    D.animate(s.animOut, C, B, function () {
      D.css(s.cssAfter);
      if (!s.sync) {
        A();
      }
    });
    if (s.sync) {
      A();
    }
  };
  c.fn.cycle.transitions = {
    fade: function (t, u, s) {
      u.not(":eq(" + s.currSlide + ")").css("opacity", 0);
      s.before.push(function (x, v, w) {
        c.fn.cycle.commonReset(x, v, w);
        w.cssBefore.opacity = 0;
      });
      s.animIn = { opacity: 1 };
      s.animOut = { opacity: 0 };
      s.cssBefore = { top: 0, left: 0 };
    },
  };
  c.fn.cycle.ver = function () {
    return b;
  };
  c.fn.cycle.defaults = {
    activePagerClass: "activeSlide",
    after: null,
    allowPagerClickBubble: false,
    animIn: null,
    animOut: null,
    aspect: false,
    autostop: 0,
    autostopCount: 0,
    backwards: false,
    before: null,
    center: null,
    cleartype: !c.support.opacity,
    cleartypeNoBg: false,
    containerResize: 1,
    containerResizeHeight: 0,
    continuous: 0,
    cssAfter: null,
    cssBefore: null,
    delay: 0,
    easeIn: null,
    easeOut: null,
    easing: null,
    end: null,
    fastOnEvent: 0,
    fit: 0,
    fx: "fade",
    fxFn: null,
    height: "auto",
    manualTrump: true,
    metaAttr: "cycle",
    next: null,
    nowrap: 0,
    onPagerEvent: null,
    onPrevNextEvent: null,
    pager: null,
    pagerAnchorBuilder: null,
    pagerEvent: "click.cycle",
    pause: 0,
    pauseOnPagerHover: 0,
    prev: null,
    prevNextEvent: "click.cycle",
    random: 0,
    randomizeEffects: 1,
    requeueOnImageNotLoaded: true,
    requeueTimeout: 250,
    rev: 0,
    shuffle: null,
    skipInitializationCallbacks: false,
    slideExpr: null,
    slideResize: 1,
    speed: 1000,
    speedIn: null,
    speedOut: null,
    startingSlide: d,
    sync: 1,
    timeout: 4000,
    timeoutFn: null,
    updateActivePagerLink: null,
    width: null,
  };
})(jQuery);
(function (a) {
  a.fn.cycle.transitions.none = function (c, d, b) {
    b.fxFn = function (g, e, f, h) {
      a(e).show();
      a(g).hide();
      h();
    };
  };
  a.fn.cycle.transitions.fadeout = function (c, d, b) {
    d.not(":eq(" + b.currSlide + ")").css({ display: "block", opacity: 1 });
    b.before.push(function (k, i, j, f, g, e) {
      a(k).css("zIndex", j.slideCount + (e !== true ? 1 : 0));
      a(i).css("zIndex", j.slideCount + (e !== true ? 0 : 1));
    });
    b.animIn.opacity = 1;
    b.animOut.opacity = 0;
    b.cssBefore.opacity = 1;
    b.cssBefore.display = "block";
    b.cssAfter.zIndex = 0;
  };
  a.fn.cycle.transitions.scrollUp = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.height();
    c.cssBefore.top = b;
    c.cssBefore.left = 0;
    c.cssFirst.top = 0;
    c.animIn.top = 0;
    c.animOut.top = -b;
  };
  a.fn.cycle.transitions.scrollDown = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.height();
    c.cssFirst.top = 0;
    c.cssBefore.top = -b;
    c.cssBefore.left = 0;
    c.animIn.top = 0;
    c.animOut.top = b;
  };
  a.fn.cycle.transitions.scrollLeft = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.width();
    c.cssFirst.left = 0;
    c.cssBefore.left = b;
    c.cssBefore.top = 0;
    c.animIn.left = 0;
    c.animOut.left = 0 - b;
  };
  a.fn.cycle.transitions.scrollRight = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.width();
    c.cssFirst.left = 0;
    c.cssBefore.left = -b;
    c.cssBefore.top = 0;
    c.animIn.left = 0;
    c.animOut.left = b;
  };
  a.fn.cycle.transitions.scrollHorz = function (c, d, b) {
    c.css("overflow", "hidden").width();
    b.before.push(function (h, f, g, e) {
      if (g.rev) {
        e = !e;
      }
      a.fn.cycle.commonReset(h, f, g);
      g.cssBefore.left = e ? f.cycleW - 1 : 1 - f.cycleW;
      g.animOut.left = e ? -h.cycleW : h.cycleW;
    });
    b.cssFirst.left = 0;
    b.cssBefore.top = 0;
    b.animIn.left = 0;
    b.animOut.top = 0;
  };
  a.fn.cycle.transitions.scrollVert = function (c, d, b) {
    c.css("overflow", "hidden");
    b.before.push(function (h, f, g, e) {
      if (g.rev) {
        e = !e;
      }
      a.fn.cycle.commonReset(h, f, g);
      g.cssBefore.top = e ? 1 - f.cycleH : f.cycleH - 1;
      g.animOut.top = e ? h.cycleH : -h.cycleH;
    });
    b.cssFirst.top = 0;
    b.cssBefore.left = 0;
    b.animIn.top = 0;
    b.animOut.left = 0;
  };
  a.fn.cycle.transitions.slideX = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a(f.elements).not(g).hide();
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.animIn.width = e.cycleW;
    });
    b.cssBefore.left = 0;
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
    b.animIn.width = "show";
    b.animOut.width = 0;
  };
  a.fn.cycle.transitions.slideY = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a(f.elements).not(g).hide();
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.animIn.height = e.cycleH;
    });
    b.cssBefore.left = 0;
    b.cssBefore.top = 0;
    b.cssBefore.height = 0;
    b.animIn.height = "show";
    b.animOut.height = 0;
  };
  a.fn.cycle.transitions.shuffle = function (e, f, d) {
    var c,
      b = e.css("overflow", "visible").width();
    f.css({ left: 0, top: 0 });
    d.before.push(function (i, g, h) {
      a.fn.cycle.commonReset(i, g, h, true, true, true);
    });
    if (!d.speedAdjusted) {
      d.speed = d.speed / 2;
      d.speedAdjusted = true;
    }
    d.random = 0;
    d.shuffle = d.shuffle || { left: -b, top: 15 };
    d.els = [];
    for (c = 0; c < f.length; c++) {
      d.els.push(f[c]);
    }
    for (c = 0; c < d.currSlide; c++) {
      d.els.push(d.els.shift());
    }
    d.fxFn = function (m, j, l, g, i) {
      if (l.rev) {
        i = !i;
      }
      var h = i ? a(m) : a(j);
      a(j).css(l.cssBefore);
      var k = l.slideCount;
      h.animate(l.shuffle, l.speedIn, l.easeIn, function () {
        var o = a.fn.cycle.hopsFromLast(l, i);
        for (var p = 0; p < o; p++) {
          if (i) {
            l.els.push(l.els.shift());
          } else {
            l.els.unshift(l.els.pop());
          }
        }
        if (i) {
          for (var q = 0, n = l.els.length; q < n; q++) {
            a(l.els[q]).css("z-index", n - q + k);
          }
        } else {
          var r = a(m).css("z-index");
          h.css("z-index", parseInt(r, 10) + 1 + k);
        }
        h.animate({ left: 0, top: 0 }, l.speedOut, l.easeOut, function () {
          a(i ? this : m).hide();
          if (g) {
            g();
          }
        });
      });
    };
    a.extend(d.cssBefore, { display: "block", opacity: 1, top: 0, left: 0 });
  };
  a.fn.cycle.transitions.turnUp = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.cssBefore.top = e.cycleH;
      f.animIn.height = e.cycleH;
      f.animOut.width = e.cycleW;
    });
    b.cssFirst.top = 0;
    b.cssBefore.left = 0;
    b.cssBefore.height = 0;
    b.animIn.top = 0;
    b.animOut.height = 0;
  };
  a.fn.cycle.transitions.turnDown = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.animIn.height = e.cycleH;
      f.animOut.top = g.cycleH;
    });
    b.cssFirst.top = 0;
    b.cssBefore.left = 0;
    b.cssBefore.top = 0;
    b.cssBefore.height = 0;
    b.animOut.height = 0;
  };
  a.fn.cycle.transitions.turnLeft = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.cssBefore.left = e.cycleW;
      f.animIn.width = e.cycleW;
    });
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
    b.animIn.left = 0;
    b.animOut.width = 0;
  };
  a.fn.cycle.transitions.turnRight = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.animIn.width = e.cycleW;
      f.animOut.left = g.cycleW;
    });
    a.extend(b.cssBefore, { top: 0, left: 0, width: 0 });
    b.animIn.left = 0;
    b.animOut.width = 0;
  };
  a.fn.cycle.transitions.zoom = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, false, true);
      f.cssBefore.top = e.cycleH / 2;
      f.cssBefore.left = e.cycleW / 2;
      a.extend(f.animIn, {
        top: 0,
        left: 0,
        width: e.cycleW,
        height: e.cycleH,
      });
      a.extend(f.animOut, {
        width: 0,
        height: 0,
        top: g.cycleH / 2,
        left: g.cycleW / 2,
      });
    });
    b.cssFirst.top = 0;
    b.cssFirst.left = 0;
    b.cssBefore.width = 0;
    b.cssBefore.height = 0;
  };
  a.fn.cycle.transitions.fadeZoom = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, false);
      f.cssBefore.left = e.cycleW / 2;
      f.cssBefore.top = e.cycleH / 2;
      a.extend(f.animIn, {
        top: 0,
        left: 0,
        width: e.cycleW,
        height: e.cycleH,
      });
    });
    b.cssBefore.width = 0;
    b.cssBefore.height = 0;
    b.animOut.opacity = 0;
  };
  a.fn.cycle.transitions.blindX = function (d, e, c) {
    var b = d.css("overflow", "hidden").width();
    c.before.push(function (h, f, g) {
      a.fn.cycle.commonReset(h, f, g);
      g.animIn.width = f.cycleW;
      g.animOut.left = h.cycleW;
    });
    c.cssBefore.left = b;
    c.cssBefore.top = 0;
    c.animIn.left = 0;
    c.animOut.left = b;
  };
  a.fn.cycle.transitions.blindY = function (d, e, c) {
    var b = d.css("overflow", "hidden").height();
    c.before.push(function (h, f, g) {
      a.fn.cycle.commonReset(h, f, g);
      g.animIn.height = f.cycleH;
      g.animOut.top = h.cycleH;
    });
    c.cssBefore.top = b;
    c.cssBefore.left = 0;
    c.animIn.top = 0;
    c.animOut.top = b;
  };
  a.fn.cycle.transitions.blindZ = function (e, f, d) {
    var c = e.css("overflow", "hidden").height();
    var b = e.width();
    d.before.push(function (i, g, h) {
      a.fn.cycle.commonReset(i, g, h);
      h.animIn.height = g.cycleH;
      h.animOut.top = i.cycleH;
    });
    d.cssBefore.top = c;
    d.cssBefore.left = b;
    d.animIn.top = 0;
    d.animIn.left = 0;
    d.animOut.top = c;
    d.animOut.left = b;
  };
  a.fn.cycle.transitions.growX = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.cssBefore.left = this.cycleW / 2;
      f.animIn.left = 0;
      f.animIn.width = this.cycleW;
      f.animOut.left = 0;
    });
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
  };
  a.fn.cycle.transitions.growY = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.cssBefore.top = this.cycleH / 2;
      f.animIn.top = 0;
      f.animIn.height = this.cycleH;
      f.animOut.top = 0;
    });
    b.cssBefore.height = 0;
    b.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.curtainX = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true, true);
      f.cssBefore.left = e.cycleW / 2;
      f.animIn.left = 0;
      f.animIn.width = this.cycleW;
      f.animOut.left = g.cycleW / 2;
      f.animOut.width = 0;
    });
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
  };
  a.fn.cycle.transitions.curtainY = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false, true);
      f.cssBefore.top = e.cycleH / 2;
      f.animIn.top = 0;
      f.animIn.height = e.cycleH;
      f.animOut.top = g.cycleH / 2;
      f.animOut.height = 0;
    });
    b.cssBefore.height = 0;
    b.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.cover = function (f, g, e) {
    var i = e.direction || "left";
    var b = f.css("overflow", "hidden").width();
    var c = f.height();
    e.before.push(function (j, d, h) {
      a.fn.cycle.commonReset(j, d, h);
      h.cssAfter.display = "";
      if (i == "right") {
        h.cssBefore.left = -b;
      } else {
        if (i == "up") {
          h.cssBefore.top = c;
        } else {
          if (i == "down") {
            h.cssBefore.top = -c;
          } else {
            h.cssBefore.left = b;
          }
        }
      }
    });
    e.animIn.left = 0;
    e.animIn.top = 0;
    e.cssBefore.top = 0;
    e.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.uncover = function (f, g, e) {
    var i = e.direction || "left";
    var b = f.css("overflow", "hidden").width();
    var c = f.height();
    e.before.push(function (j, d, h) {
      a.fn.cycle.commonReset(j, d, h, true, true, true);
      if (i == "right") {
        h.animOut.left = b;
      } else {
        if (i == "up") {
          h.animOut.top = -c;
        } else {
          if (i == "down") {
            h.animOut.top = c;
          } else {
            h.animOut.left = -b;
          }
        }
      }
    });
    e.animIn.left = 0;
    e.animIn.top = 0;
    e.cssBefore.top = 0;
    e.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.toss = function (e, f, d) {
    var b = e.css("overflow", "visible").width();
    var c = e.height();
    d.before.push(function (i, g, h) {
      a.fn.cycle.commonReset(i, g, h, true, true, true);
      if (!h.animOut.left && !h.animOut.top) {
        a.extend(h.animOut, { left: b * 2, top: -c / 2, opacity: 0 });
      } else {
        h.animOut.opacity = 0;
      }
    });
    d.cssBefore.left = 0;
    d.cssBefore.top = 0;
    d.animIn.left = 0;
  };
  a.fn.cycle.transitions.wipe = function (q, m, e) {
    var p = q.css("overflow", "hidden").width();
    var j = q.height();
    e.cssBefore = e.cssBefore || {};
    var g;
    if (e.clip) {
      if (/l2r/.test(e.clip)) {
        g = "rect(0px 0px " + j + "px 0px)";
      } else {
        if (/r2l/.test(e.clip)) {
          g = "rect(0px " + p + "px " + j + "px " + p + "px)";
        } else {
          if (/t2b/.test(e.clip)) {
            g = "rect(0px " + p + "px 0px 0px)";
          } else {
            if (/b2t/.test(e.clip)) {
              g = "rect(" + j + "px " + p + "px " + j + "px 0px)";
            } else {
              if (/zoom/.test(e.clip)) {
                var o = parseInt(j / 2, 10);
                var f = parseInt(p / 2, 10);
                g = "rect(" + o + "px " + f + "px " + o + "px " + f + "px)";
              }
            }
          }
        }
      }
    }
    e.cssBefore.clip = e.cssBefore.clip || g || "rect(0px 0px 0px 0px)";
    var k = e.cssBefore.clip.match(/(\d+)/g);
    var s = parseInt(k[0], 10),
      c = parseInt(k[1], 10),
      n = parseInt(k[2], 10),
      i = parseInt(k[3], 10);
    e.before.push(function (v, h, t) {
      if (v == h) {
        return;
      }
      var d = a(v),
        b = a(h);
      a.fn.cycle.commonReset(v, h, t, true, true, false);
      t.cssAfter.display = "block";
      var r = 1,
        l = parseInt(t.speedIn / 13, 10) - 1;
      (function u() {
        var x = s ? s - parseInt(r * (s / l), 10) : 0;
        var y = i ? i - parseInt(r * (i / l), 10) : 0;
        var z = n < j ? n + parseInt(r * ((j - n) / l || 1), 10) : j;
        var w = c < p ? c + parseInt(r * ((p - c) / l || 1), 10) : p;
        b.css({
          clip: "rect(" + x + "px " + w + "px " + z + "px " + y + "px)",
        });
        r++ <= l ? setTimeout(u, 13) : d.css("display", "none");
      })();
    });
    a.extend(e.cssBefore, { display: "block", opacity: 1, top: 0, left: 0 });
    e.animIn = { left: 0 };
    e.animOut = { left: 0 };
  };
})(jQuery);
$(function () {
  $("div.ecom_login_dropdown a").click(function () {
    let tabNameTappedData = {
      "Tab Name Tapped": $(this).text(),
      "Page Name": window.location.pathname,
    };
    clevertap.event.push(clevertap_events.myAccountMenu, tabNameTappedData);
    console.log("Clevertap Web MyAccountMenu event pushed");
  });
});
(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
    ? define(factory)
    : (global.moment = factory());
})(this, function () {
  "use strict";
  var hookCallback;
  function utils_hooks__hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return Object.prototype.toString.call(input) === "[object Array]";
  }
  function isDate(input) {
    return (
      input instanceof Date ||
      Object.prototype.toString.call(input) === "[object Date]"
    );
  }
  function map(arr, fn) {
    var res = [],
      i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, "toString")) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, "valueOf")) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function create_utc__createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  function valid__isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      m._isValid =
        !isNaN(m._d.getTime()) &&
        flags.overflow < 0 &&
        !flags.empty &&
        !flags.invalidMonth &&
        !flags.invalidWeekday &&
        !flags.nullInput &&
        !flags.invalidFormat &&
        !flags.userInvalidated;
      if (m._strict) {
        m._isValid =
          m._isValid &&
          flags.charsLeftOver === 0 &&
          flags.unusedTokens.length === 0 &&
          flags.bigHour === undefined;
      }
    }
    return m._isValid;
  }
  function valid__createInvalid(flags) {
    var m = create_utc__createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }
  var momentProperties = (utils_hooks__hooks.momentProperties = []);
  function copyConfig(to, from) {
    var i, prop, val;
    if (typeof from._isAMomentObject !== "undefined") {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (typeof from._i !== "undefined") {
      to._i = from._i;
    }
    if (typeof from._f !== "undefined") {
      to._f = from._f;
    }
    if (typeof from._l !== "undefined") {
      to._l = from._l;
    }
    if (typeof from._strict !== "undefined") {
      to._strict = from._strict;
    }
    if (typeof from._tzm !== "undefined") {
      to._tzm = from._tzm;
    }
    if (typeof from._isUTC !== "undefined") {
      to._isUTC = from._isUTC;
    }
    if (typeof from._offset !== "undefined") {
      to._offset = from._offset;
    }
    if (typeof from._pf !== "undefined") {
      to._pf = getParsingFlags(from);
    }
    if (typeof from._locale !== "undefined") {
      to._locale = from._locale;
    }
    if (momentProperties.length > 0) {
      for (i in momentProperties) {
        prop = momentProperties[i];
        val = from[prop];
        if (typeof val !== "undefined") {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  var updateInProgress = false;
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (updateInProgress === false) {
      updateInProgress = true;
      utils_hooks__hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return (
      obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
    );
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number);
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
      value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
      lengthDiff = Math.abs(array1.length - array2.length),
      diffs = 0,
      i;
    for (i = 0; i < len; i++) {
      if (
        (dontConvert && array1[i] !== array2[i]) ||
        (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
      ) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function Locale() {}
  var locales = {};
  var globalLocale;
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace("_", "-") : key;
  }
  function chooseLocale(names) {
    var i = 0,
      j,
      next,
      locale,
      split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split("-");
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split("-") : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join("-"));
        if (locale) {
          return locale;
        }
        if (
          next &&
          next.length >= j &&
          compareArrays(split, next, true) >= j - 1
        ) {
          break;
        }
        j--;
      }
      i++;
    }
    return null;
  }
  function loadLocale(name) {
    var oldLocale = null;
    if (
      !locales[name] &&
      typeof module !== "undefined" &&
      module &&
      module.exports
    ) {
      try {
        oldLocale = globalLocale._abbr;
        require("./locale/" + name);
        locale_locales__getSetGlobalLocale(oldLocale);
      } catch (e) {}
    }
    return locales[name];
  }
  function locale_locales__getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (typeof values === "undefined") {
        data = locale_locales__getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        globalLocale = data;
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, values) {
    if (values !== null) {
      values.abbr = name;
      locales[name] = locales[name] || new Locale();
      locales[name].set(values);
      locale_locales__getSetGlobalLocale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  }
  function locale_locales__getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === "string"
      ? aliases[units] || aliases[units.toLowerCase()]
      : undefined;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
      normalizedProp,
      prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        get_set__set(this, unit, value);
        utils_hooks__hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get_set__get(this, unit);
      }
    };
  }
  function get_set__get(mom, unit) {
    return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
  }
  function get_set__set(mom, unit, value) {
    return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
  }
  function getSet(units, value) {
    var unit;
    if (typeof units === "object") {
      for (unit in units) {
        this.set(unit, units[unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (typeof this[units] === "function") {
        return this[units](value);
      }
    }
    return this;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = "" + Math.abs(number),
      zerosToFill = targetLength - absNumber.length,
      sign = number >= 0;
    return (
      (sign ? (forceSign ? "+" : "") : "-") +
      Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
      absNumber
    );
  }
  var formattingTokens =
    /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === "string") {
      func = function () {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, "");
    }
    return input.replace(/\\/g, "");
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
      i,
      length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function (mom) {
      var output = "";
      for (i = 0; i < length; i++) {
        output +=
          array[i] instanceof Function ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    formatFunctions[format] =
      formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(
        localFormattingTokens,
        replaceLongDateFormatTokens
      );
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var match1 = /\d/;
  var match2 = /\d\d/;
  var match3 = /\d{3}/;
  var match4 = /\d{4}/;
  var match6 = /[+-]?\d{6}/;
  var match1to2 = /\d\d?/;
  var match1to3 = /\d{1,3}/;
  var match1to4 = /\d{1,4}/;
  var match1to6 = /[+-]?\d{1,6}/;
  var matchUnsigned = /\d+/;
  var matchSigned = /[+-]?\d+/;
  var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  var matchWord =
    /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var regexes = {};
  function isFunction(sth) {
    return (
      typeof sth === "function" &&
      Object.prototype.toString.call(sth) === "[object Function]"
    );
  }
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex)
      ? regex
      : function (isStrict) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }
  function unescapeFormat(s) {
    return s
      .replace("\\", "")
      .replace(
        /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
        function (matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }
      )
      .replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i,
      func = callback;
    if (typeof token === "string") {
      token = [token];
    }
    if (typeof callback === "number") {
      func = function (input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
  }
  addFormatToken("M", ["MM", 2], "Mo", function () {
    return this.month() + 1;
  });
  addFormatToken("MMM", 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken("MMMM", 0, 0, function (format) {
    return this.localeData().months(this, format);
  });
  addUnitAlias("month", "M");
  addRegexToken("M", match1to2);
  addRegexToken("MM", match1to2, match2);
  addRegexToken("MMM", matchWord);
  addRegexToken("MMMM", matchWord);
  addParseToken(["M", "MM"], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(["MMM", "MMMM"], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  var defaultLocaleMonths =
    "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    );
  function localeMonths(m) {
    return this._months[m.month()];
  }
  var defaultLocaleMonthsShort =
    "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
  function localeMonthsShort(m) {
    return this._monthsShort[m.month()];
  }
  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i = 0; i < 12; i++) {
      mom = create_utc__createUTC([2000, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp(
          "^" + this.months(mom, "").replace(".", "") + "$",
          "i"
        );
        this._shortMonthsParse[i] = new RegExp(
          "^" + this.monthsShort(mom, "").replace(".", "") + "$",
          "i"
        );
      }
      if (!strict && !this._monthsParse[i]) {
        regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
        this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      if (
        strict &&
        format === "MMMM" &&
        this._longMonthsParse[i].test(monthName)
      ) {
        return i;
      } else if (
        strict &&
        format === "MMM" &&
        this._shortMonthsParse[i].test(monthName)
      ) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }
  function setMonth(mom, value) {
    var dayOfMonth;
    if (typeof value === "string") {
      value = mom.localeData().monthsParse(value);
      if (typeof value !== "number") {
        return mom;
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      utils_hooks__hooks.updateOffset(this, true);
      return this;
    } else {
      return get_set__get(this, "Month");
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  function checkOverflow(m) {
    var overflow;
    var a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow =
        a[MONTH] < 0 || a[MONTH] > 11
          ? MONTH
          : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
          ? DATE
          : a[HOUR] < 0 ||
            a[HOUR] > 24 ||
            (a[HOUR] === 24 &&
              (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0))
          ? HOUR
          : a[MINUTE] < 0 || a[MINUTE] > 59
          ? MINUTE
          : a[SECOND] < 0 || a[SECOND] > 59
          ? SECOND
          : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
          ? MILLISECOND
          : -1;
      if (
        getParsingFlags(m)._overflowDayOfYear &&
        (overflow < YEAR || overflow > DATE)
      ) {
        overflow = DATE;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }
  function warn(msg) {
    if (
      utils_hooks__hooks.suppressDeprecationWarnings === false &&
      typeof console !== "undefined" &&
      console.warn
    ) {
      console.warn("Deprecation warning: " + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function () {
      if (firstTime) {
        warn(msg + "\n" + new Error().stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  utils_hooks__hooks.suppressDeprecationWarnings = false;
  var from_string__isoRegex =
    /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var isoDates = [
    ["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/],
    ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/],
    ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/],
    ["GGGG-[W]WW", /\d{4}-W\d{2}/],
    ["YYYY-DDD", /\d{4}-\d{3}/],
  ];
  var isoTimes = [
    ["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/],
    ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/],
    ["HH:mm", /(T| )\d\d:\d\d/],
    ["HH", /(T| )\d\d/],
  ];
  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
  function configFromISO(config) {
    var i,
      l,
      string = config._i,
      match = from_string__isoRegex.exec(string);
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(string)) {
          config._f = isoDates[i][0];
          break;
        }
      }
      for (i = 0, l = isoTimes.length; i < l; i++) {
        if (isoTimes[i][1].exec(string)) {
          config._f += (match[6] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (string.match(matchOffset)) {
        config._f += "Z";
      }
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  utils_hooks__hooks.createFromInputFallback = deprecate(
    "moment construction falls back to js Date. This is " +
      "discouraged and will be removed in upcoming major " +
      "release. Please refer to " +
      "https://github.com/moment/moment/issues/1407 for more info.",
    function (config) {
      config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    }
  );
  function createDate(y, m, d, h, M, s, ms) {
    var date = new Date(y, m, d, h, M, s, ms);
    if (y < 1970) {
      date.setFullYear(y);
    }
    return date;
  }
  function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));
    if (y < 1970) {
      date.setUTCFullYear(y);
    }
    return date;
  }
  addFormatToken(0, ["YY", 2], 0, function () {
    return this.year() % 100;
  });
  addFormatToken(0, ["YYYY", 4], 0, "year");
  addFormatToken(0, ["YYYYY", 5], 0, "year");
  addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
  addUnitAlias("year", "y");
  addRegexToken("Y", matchSigned);
  addRegexToken("YY", match1to2, match2);
  addRegexToken("YYYY", match1to4, match4);
  addRegexToken("YYYYY", match1to6, match6);
  addRegexToken("YYYYYY", match1to6, match6);
  addParseToken(["YYYYY", "YYYYYY"], YEAR);
  addParseToken("YYYY", function (input, array) {
    array[YEAR] =
      input.length === 2
        ? utils_hooks__hooks.parseTwoDigitYear(input)
        : toInt(input);
  });
  addParseToken("YY", function (input, array) {
    array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }
  utils_hooks__hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };
  var getSetYear = makeGetSet("FullYear", false);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  addFormatToken("w", ["ww", 2], "wo", "week");
  addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
  addUnitAlias("week", "w");
  addUnitAlias("isoWeek", "W");
  addRegexToken("w", match1to2);
  addRegexToken("ww", match1to2, match2);
  addRegexToken("W", match1to2);
  addRegexToken("WW", match1to2, match2);
  addWeekParseToken(
    ["w", "ww", "W", "WW"],
    function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }
  );
  function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
    var end = firstDayOfWeekOfYear - firstDayOfWeek,
      daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
      adjustedMoment;
    if (daysToDayOfWeek > end) {
      daysToDayOfWeek -= 7;
    }
    if (daysToDayOfWeek < end - 7) {
      daysToDayOfWeek += 7;
    }
    adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, "d");
    return {
      week: Math.ceil(adjustedMoment.dayOfYear() / 7),
      year: adjustedMoment.year(),
    };
  }
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = { dow: 0, doy: 6 };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
  addUnitAlias("dayOfYear", "DDD");
  addRegexToken("DDD", match1to3);
  addRegexToken("DDDD", match3);
  addParseToken(["DDD", "DDDD"], function (input, array, config) {
    config._dayOfYear = toInt(input);
  });
  function dayOfYearFromWeeks(
    year,
    week,
    weekday,
    firstDayOfWeekOfYear,
    firstDayOfWeek
  ) {
    var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear,
      janX = createUTCDate(year, 0, 1 + week1Jan),
      d = janX.getUTCDay(),
      dayOfYear;
    if (d < firstDayOfWeek) {
      d += 7;
    }
    weekday = weekday != null ? 1 * weekday : firstDayOfWeek;
    dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;
    return {
      year: dayOfYear > 0 ? year : year - 1,
      dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear,
    };
  }
  function getSetDayOfYear(input) {
    var dayOfYear =
      Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
  }
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    var now = new Date();
    if (config._useUTC) {
      return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
    }
    return [now.getFullYear(), now.getMonth(), now.getDate()];
  }
  function configFromArray(config) {
    var i,
      date,
      input = [],
      currentDate,
      yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    if (config._dayOfYear) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse)) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    for (; i < 7; i++) {
      config._a[i] = input[i] =
        config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
    }
    if (
      config._a[HOUR] === 24 &&
      config._a[MINUTE] === 0 &&
      config._a[SECOND] === 0 &&
      config._a[MILLISECOND] === 0
    ) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(
      null,
      input
    );
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      weekYear = defaults(
        w.GG,
        config._a[YEAR],
        weekOfYear(local__createLocal(), 1, 4).year
      );
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      weekYear = defaults(
        w.gg,
        config._a[YEAR],
        weekOfYear(local__createLocal(), dow, doy).year
      );
      week = defaults(w.w, 1);
      if (w.d != null) {
        weekday = w.d;
        if (weekday < dow) {
          ++week;
        }
      } else if (w.e != null) {
        weekday = w.e + dow;
      } else {
        weekday = dow;
      }
    }
    temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
  utils_hooks__hooks.ISO_8601 = function () {};
  function configFromStringAndFormat(config) {
    if (config._f === utils_hooks__hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;
    var string = "" + config._i,
      i,
      parsedInput,
      tokens,
      token,
      skipped,
      stringLength = string.length,
      totalParsedInputLength = 0;
    tokens =
      expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) ||
        [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }
    getParsingFlags(config).charsLeftOver =
      stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }
    if (
      getParsingFlags(config).bigHour === true &&
      config._a[HOUR] <= 12 &&
      config._a[HOUR] > 0
    ) {
      getParsingFlags(config).bigHour = undefined;
    }
    config._a[HOUR] = meridiemFixWrap(
      config._locale,
      config._a[HOUR],
      config._meridiem
    );
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      return hour;
    }
  }
  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;
    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (!valid__isValid(tempConfig)) {
        continue;
      }
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i);
    config._a = [
      i.year,
      i.month,
      i.day || i.date,
      i.hour,
      i.minute,
      i.second,
      i.millisecond,
    ];
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      res.add(1, "d");
      res._nextDay = undefined;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i,
      format = config._f;
    config._locale = config._locale || locale_locales__getLocale(config._l);
    if (input === null || (format === undefined && input === "")) {
      return valid__createInvalid({ nullInput: true });
    }
    if (typeof input === "string") {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else if (isDate(input)) {
      config._d = input;
    } else {
      configFromInput(config);
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
      config._d = new Date();
    } else if (isDate(input)) {
      config._d = new Date(+input);
    } else if (typeof input === "string") {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (typeof input === "object") {
      configFromObject(config);
    } else if (typeof input === "number") {
      config._d = new Date(input);
    } else {
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (typeof locale === "boolean") {
      strict = locale;
      locale = undefined;
    }
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function local__createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate(
    "moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",
    function () {
      var other = local__createLocal.apply(null, arguments);
      return other < this ? this : other;
    }
  );
  var prototypeMax = deprecate(
    "moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",
    function () {
      var other = local__createLocal.apply(null, arguments);
      return other > this ? this : other;
    }
  );
  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return local__createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isBefore", args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isAfter", args);
  }
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
      years = normalizedInput.year || 0,
      quarters = normalizedInput.quarter || 0,
      months = normalizedInput.month || 0,
      weeks = normalizedInput.week || 0,
      days = normalizedInput.day || 0,
      hours = normalizedInput.hour || 0,
      minutes = normalizedInput.minute || 0,
      seconds = normalizedInput.second || 0,
      milliseconds = normalizedInput.millisecond || 0;
    this._milliseconds =
      +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
    this._days = +days + weeks * 7;
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = locale_locales__getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset();
      var sign = "+";
      if (offset < 0) {
        offset = -offset;
        sign = "-";
      }
      return (
        sign +
        zeroFill(~~(offset / 60), 2) +
        separator +
        zeroFill(~~offset % 60, 2)
      );
    });
  }
  offset("Z", ":");
  offset("ZZ", "");
  addRegexToken("Z", matchOffset);
  addRegexToken("ZZ", matchOffset);
  addParseToken(["Z", "ZZ"], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(input);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(string) {
    var matches = (string || "").match(matchOffset) || [];
    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);
    return parts[0] === "+" ? minutes : -minutes;
  }
  function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
      res = model.clone();
      diff =
        (isMoment(input) || isDate(input)
          ? +input
          : +local__createLocal(input)) - +res;
      res._d.setTime(+res._d + diff);
      utils_hooks__hooks.updateOffset(res, false);
      return res;
    } else {
      return local__createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }
  utils_hooks__hooks.updateOffset = function () {};
  function getSetOffset(input, keepLocalTime) {
    var offset = this._offset || 0,
      localAdjust;
    if (input != null) {
      if (typeof input === "string") {
        input = offsetFromString(input);
      }
      if (Math.abs(input) < 16) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, "m");
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          add_subtract__addSubtract(
            this,
            create__createDuration(input - offset, "m"),
            1,
            false
          );
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          utils_hooks__hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== "string") {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), "m");
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm) {
      this.utcOffset(this._tzm);
    } else if (typeof this._i === "string") {
      this.utcOffset(offsetFromString(this._i));
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    input = input ? local__createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return (
      this.utcOffset() > this.clone().month(0).utcOffset() ||
      this.utcOffset() > this.clone().month(5).utcOffset()
    );
  }
  function isDaylightSavingTimeShifted() {
    if (typeof this._isDSTShifted !== "undefined") {
      return this._isDSTShifted;
    }
    var c = {};
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      var other = c._isUTC
        ? create_utc__createUTC(c._a)
        : local__createLocal(c._a);
      this._isDSTShifted =
        this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return !this._isUTC;
  }
  function isUtcOffset() {
    return this._isUTC;
  }
  function isUtc() {
    return this._isUTC && this._offset === 0;
  }
  var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
  var create__isoRegex =
    /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
  function create__createDuration(input, key) {
    var duration = input,
      match = null,
      sign,
      ret,
      diffRes;
    if (isDuration(input)) {
      duration = { ms: input._milliseconds, d: input._days, M: input._months };
    } else if (typeof input === "number") {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = match[1] === "-" ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(match[MILLISECOND]) * sign,
      };
    } else if (!!(match = create__isoRegex.exec(input))) {
      sign = match[1] === "-" ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        d: parseIso(match[4], sign),
        h: parseIso(match[5], sign),
        m: parseIso(match[6], sign),
        s: parseIso(match[7], sign),
        w: parseIso(match[8], sign),
      };
    } else if (duration == null) {
      duration = {};
    } else if (
      typeof duration === "object" &&
      ("from" in duration || "to" in duration)
    ) {
      diffRes = momentsDifference(
        local__createLocal(duration.from),
        local__createLocal(duration.to)
      );
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, "_locale")) {
      ret._locale = input._locale;
    }
    return ret;
  }
  create__createDuration.fn = Duration.prototype;
  function parseIso(inp, sign) {
    var res = inp && parseFloat(inp.replace(",", "."));
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = { milliseconds: 0, months: 0 };
    res.months =
      other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, "M").isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +base.clone().add(res.months, "M");
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp;
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(
          name,
          "moment()." +
            name +
            "(period, number) is deprecated. Please use moment()." +
            name +
            "(number, period)."
        );
        tmp = val;
        val = period;
        period = tmp;
      }
      val = typeof val === "string" ? +val : val;
      dur = create__createDuration(val, period);
      add_subtract__addSubtract(this, dur, direction);
      return this;
    };
  }
  function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
      days = duration._days,
      months = duration._months;
    updateOffset = updateOffset == null ? true : updateOffset;
    if (milliseconds) {
      mom._d.setTime(+mom._d + milliseconds * isAdding);
    }
    if (days) {
      get_set__set(mom, "Date", get_set__get(mom, "Date") + days * isAdding);
    }
    if (months) {
      setMonth(mom, get_set__get(mom, "Month") + months * isAdding);
    }
    if (updateOffset) {
      utils_hooks__hooks.updateOffset(mom, days || months);
    }
  }
  var add_subtract__add = createAdder(1, "add");
  var add_subtract__subtract = createAdder(-1, "subtract");
  function moment_calendar__calendar(time, formats) {
    var now = time || local__createLocal(),
      sod = cloneWithOffset(now, this).startOf("day"),
      diff = this.diff(sod, "days", true),
      format =
        diff < -6
          ? "sameElse"
          : diff < -1
          ? "lastWeek"
          : diff < 0
          ? "lastDay"
          : diff < 1
          ? "sameDay"
          : diff < 2
          ? "nextDay"
          : diff < 7
          ? "nextWeek"
          : "sameElse";
    return this.format(
      (formats && formats[format]) ||
        this.localeData().calendar(format, this, local__createLocal(now))
    );
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var inputMs;
    units = normalizeUnits(
      typeof units !== "undefined" ? units : "millisecond"
    );
    if (units === "millisecond") {
      input = isMoment(input) ? input : local__createLocal(input);
      return +this > +input;
    } else {
      inputMs = isMoment(input) ? +input : +local__createLocal(input);
      return inputMs < +this.clone().startOf(units);
    }
  }
  function isBefore(input, units) {
    var inputMs;
    units = normalizeUnits(
      typeof units !== "undefined" ? units : "millisecond"
    );
    if (units === "millisecond") {
      input = isMoment(input) ? input : local__createLocal(input);
      return +this < +input;
    } else {
      inputMs = isMoment(input) ? +input : +local__createLocal(input);
      return +this.clone().endOf(units) < inputMs;
    }
  }
  function isBetween(from, to, units) {
    return this.isAfter(from, units) && this.isBefore(to, units);
  }
  function isSame(input, units) {
    var inputMs;
    units = normalizeUnits(units || "millisecond");
    if (units === "millisecond") {
      input = isMoment(input) ? input : local__createLocal(input);
      return +this === +input;
    } else {
      inputMs = +local__createLocal(input);
      return (
        +this.clone().startOf(units) <= inputMs &&
        inputMs <= +this.clone().endOf(units)
      );
    }
  }
  function diff(input, units, asFloat) {
    var that = cloneWithOffset(input, this),
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
      delta,
      output;
    units = normalizeUnits(units);
    if (units === "year" || units === "month" || units === "quarter") {
      output = monthDiff(this, that);
      if (units === "quarter") {
        output = output / 3;
      } else if (units === "year") {
        output = output / 12;
      }
    } else {
      delta = this - that;
      output =
        units === "second"
          ? delta / 1e3
          : units === "minute"
          ? delta / 6e4
          : units === "hour"
          ? delta / 36e5
          : units === "day"
          ? (delta - zoneDelta) / 864e5
          : units === "week"
          ? (delta - zoneDelta) / 6048e5
          : delta;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
      anchor = a.clone().add(wholeMonthDiff, "months"),
      anchor2,
      adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust);
  }
  utils_hooks__hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  function toString() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  }
  function moment_format__toISOString() {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
      if ("function" === typeof Date.prototype.toISOString) {
        return this.toDate().toISOString();
      } else {
        return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
      }
    } else {
      return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
    }
  }
  function format(inputString) {
    var output = formatMoment(
      this,
      inputString || utils_hooks__hooks.defaultFormat
    );
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    return create__createDuration({ to: this, from: time })
      .locale(this.locale())
      .humanize(!withoutSuffix);
  }
  function fromNow(withoutSuffix) {
    return this.from(local__createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    return create__createDuration({ from: this, to: time })
      .locale(this.locale())
      .humanize(!withoutSuffix);
  }
  function toNow(withoutSuffix) {
    return this.to(local__createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = locale_locales__getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate(
    "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
    function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    }
  );
  function localeData() {
    return this._locale;
  }
  function startOf(units) {
    units = normalizeUnits(units);
    switch (units) {
      case "year":
        this.month(0);
      case "quarter":
      case "month":
        this.date(1);
      case "week":
      case "isoWeek":
      case "day":
        this.hours(0);
      case "hour":
        this.minutes(0);
      case "minute":
        this.seconds(0);
      case "second":
        this.milliseconds(0);
    }
    if (units === "week") {
      this.weekday(0);
    }
    if (units === "isoWeek") {
      this.isoWeekday(1);
    }
    if (units === "quarter") {
      this.month(Math.floor(this.month() / 3) * 3);
    }
    return this;
  }
  function endOf(units) {
    units = normalizeUnits(units);
    if (units === undefined || units === "millisecond") {
      return this;
    }
    return this.startOf(units)
      .add(1, units === "isoWeek" ? "week" : units)
      .subtract(1, "ms");
  }
  function to_type__valueOf() {
    return +this._d - (this._offset || 0) * 60000;
  }
  function unix() {
    return Math.floor(+this / 1000);
  }
  function toDate() {
    return this._offset ? new Date(+this) : this._d;
  }
  function toArray() {
    var m = this;
    return [
      m.year(),
      m.month(),
      m.date(),
      m.hour(),
      m.minute(),
      m.second(),
      m.millisecond(),
    ];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds(),
    };
  }
  function moment_valid__isValid() {
    return valid__isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  addFormatToken(0, ["gg", 2], 0, function () {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ["GG", 2], 0, function () {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  addWeekYearFormatToken("gggg", "weekYear");
  addWeekYearFormatToken("ggggg", "weekYear");
  addWeekYearFormatToken("GGGG", "isoWeekYear");
  addWeekYearFormatToken("GGGGG", "isoWeekYear");
  addUnitAlias("weekYear", "gg");
  addUnitAlias("isoWeekYear", "GG");
  addRegexToken("G", matchSigned);
  addRegexToken("g", matchSigned);
  addRegexToken("GG", match1to2, match2);
  addRegexToken("gg", match1to2, match2);
  addRegexToken("GGGG", match1to4, match4);
  addRegexToken("gggg", match1to4, match4);
  addRegexToken("GGGGG", match1to6, match6);
  addRegexToken("ggggg", match1to6, match6);
  addWeekParseToken(
    ["gggg", "ggggg", "GGGG", "GGGGG"],
    function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    }
  );
  addWeekParseToken(["gg", "GG"], function (input, week, config, token) {
    week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  function weeksInYear(year, dow, doy) {
    return weekOfYear(
      local__createLocal([year, 11, 31 + dow - doy]),
      dow,
      doy
    ).week;
  }
  function getSetWeekYear(input) {
    var year = weekOfYear(
      this,
      this.localeData()._week.dow,
      this.localeData()._week.doy
    ).year;
    return input == null ? year : this.add(input - year, "y");
  }
  function getSetISOWeekYear(input) {
    var year = weekOfYear(this, 1, 4).year;
    return input == null ? year : this.add(input - year, "y");
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  addFormatToken("Q", 0, 0, "quarter");
  addUnitAlias("quarter", "Q");
  addRegexToken("Q", match1);
  addParseToken("Q", function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  function getSetQuarter(input) {
    return input == null
      ? Math.ceil((this.month() + 1) / 3)
      : this.month((input - 1) * 3 + (this.month() % 3));
  }
  addFormatToken("D", ["DD", 2], "Do", "date");
  addUnitAlias("date", "D");
  addRegexToken("D", match1to2);
  addRegexToken("DD", match1to2, match2);
  addRegexToken("Do", function (isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
  });
  addParseToken(["D", "DD"], DATE);
  addParseToken("Do", function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
  });
  var getSetDayOfMonth = makeGetSet("Date", true);
  addFormatToken("d", 0, "do", "day");
  addFormatToken("dd", 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken("ddd", 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken("dddd", 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken("e", 0, 0, "weekday");
  addFormatToken("E", 0, 0, "isoWeekday");
  addUnitAlias("day", "d");
  addUnitAlias("weekday", "e");
  addUnitAlias("isoWeekday", "E");
  addRegexToken("d", match1to2);
  addRegexToken("e", match1to2);
  addRegexToken("E", match1to2);
  addRegexToken("dd", matchWord);
  addRegexToken("ddd", matchWord);
  addRegexToken("dddd", matchWord);
  addWeekParseToken(["dd", "ddd", "dddd"], function (input, week, config) {
    var weekday = config._locale.weekdaysParse(input);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(["d", "e", "E"], function (input, week, config, token) {
    week[token] = toInt(input);
  });
  function parseWeekday(input, locale) {
    if (typeof input !== "string") {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale.weekdaysParse(input);
    if (typeof input === "number") {
      return input;
    }
    return null;
  }
  var defaultLocaleWeekdays =
    "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
  function localeWeekdays(m) {
    return this._weekdays[m.day()];
  }
  var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
  function localeWeekdaysShort(m) {
    return this._weekdaysShort[m.day()];
  }
  var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
  function localeWeekdaysMin(m) {
    return this._weekdaysMin[m.day()];
  }
  function localeWeekdaysParse(weekdayName) {
    var i, mom, regex;
    this._weekdaysParse = this._weekdaysParse || [];
    for (i = 0; i < 7; i++) {
      if (!this._weekdaysParse[i]) {
        mom = local__createLocal([2000, 1]).day(i);
        regex =
          "^" +
          this.weekdays(mom, "") +
          "|^" +
          this.weekdaysShort(mom, "") +
          "|^" +
          this.weekdaysMin(mom, "");
        this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      if (this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }
  function getSetDayOfWeek(input) {
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, "d");
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, "d");
  }
  function getSetISODayOfWeek(input) {
    return input == null
      ? this.day() || 7
      : this.day(this.day() % 7 ? input : input - 7);
  }
  addFormatToken("H", ["HH", 2], 0, "hour");
  addFormatToken("h", ["hh", 2], 0, function () {
    return this.hours() % 12 || 12;
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(
        this.hours(),
        this.minutes(),
        lowercase
      );
    });
  }
  meridiem("a", true);
  meridiem("A", false);
  addUnitAlias("hour", "h");
  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken("a", matchMeridiem);
  addRegexToken("A", matchMeridiem);
  addRegexToken("H", match1to2);
  addRegexToken("h", match1to2);
  addRegexToken("HH", match1to2, match2);
  addRegexToken("hh", match1to2, match2);
  addParseToken(["H", "HH"], HOUR);
  addParseToken(["a", "A"], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(["h", "hh"], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  function localeIsPM(input) {
    return (input + "").toLowerCase().charAt(0) === "p";
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? "pm" : "PM";
    } else {
      return isLower ? "am" : "AM";
    }
  }
  var getSetHour = makeGetSet("Hours", true);
  addFormatToken("m", ["mm", 2], 0, "minute");
  addUnitAlias("minute", "m");
  addRegexToken("m", match1to2);
  addRegexToken("mm", match1to2, match2);
  addParseToken(["m", "mm"], MINUTE);
  var getSetMinute = makeGetSet("Minutes", false);
  addFormatToken("s", ["ss", 2], 0, "second");
  addUnitAlias("second", "s");
  addRegexToken("s", match1to2);
  addRegexToken("ss", match1to2, match2);
  addParseToken(["s", "ss"], SECOND);
  var getSetSecond = makeGetSet("Seconds", false);
  addFormatToken("S", 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ["SS", 2], 0, function () {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ["SSS", 3], 0, "millisecond");
  addFormatToken(0, ["SSSS", 4], 0, function () {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ["SSSSS", 5], 0, function () {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ["SSSSSS", 6], 0, function () {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ["SSSSSSS", 7], 0, function () {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
    return this.millisecond() * 1000000;
  });
  addUnitAlias("millisecond", "ms");
  addRegexToken("S", match1to3, match1);
  addRegexToken("SS", match1to3, match2);
  addRegexToken("SSS", match1to3, match3);
  var token;
  for (token = "SSSS"; token.length <= 9; token += "S") {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(("0." + input) * 1000);
  }
  for (token = "S"; token.length <= 9; token += "S") {
    addParseToken(token, parseMs);
  }
  var getSetMillisecond = makeGetSet("Milliseconds", false);
  addFormatToken("z", 0, 0, "zoneAbbr");
  addFormatToken("zz", 0, 0, "zoneName");
  function getZoneAbbr() {
    return this._isUTC ? "UTC" : "";
  }
  function getZoneName() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  }
  var momentPrototype__proto = Moment.prototype;
  momentPrototype__proto.add = add_subtract__add;
  momentPrototype__proto.calendar = moment_calendar__calendar;
  momentPrototype__proto.clone = clone;
  momentPrototype__proto.diff = diff;
  momentPrototype__proto.endOf = endOf;
  momentPrototype__proto.format = format;
  momentPrototype__proto.from = from;
  momentPrototype__proto.fromNow = fromNow;
  momentPrototype__proto.to = to;
  momentPrototype__proto.toNow = toNow;
  momentPrototype__proto.get = getSet;
  momentPrototype__proto.invalidAt = invalidAt;
  momentPrototype__proto.isAfter = isAfter;
  momentPrototype__proto.isBefore = isBefore;
  momentPrototype__proto.isBetween = isBetween;
  momentPrototype__proto.isSame = isSame;
  momentPrototype__proto.isValid = moment_valid__isValid;
  momentPrototype__proto.lang = lang;
  momentPrototype__proto.locale = locale;
  momentPrototype__proto.localeData = localeData;
  momentPrototype__proto.max = prototypeMax;
  momentPrototype__proto.min = prototypeMin;
  momentPrototype__proto.parsingFlags = parsingFlags;
  momentPrototype__proto.set = getSet;
  momentPrototype__proto.startOf = startOf;
  momentPrototype__proto.subtract = add_subtract__subtract;
  momentPrototype__proto.toArray = toArray;
  momentPrototype__proto.toObject = toObject;
  momentPrototype__proto.toDate = toDate;
  momentPrototype__proto.toISOString = moment_format__toISOString;
  momentPrototype__proto.toJSON = moment_format__toISOString;
  momentPrototype__proto.toString = toString;
  momentPrototype__proto.unix = unix;
  momentPrototype__proto.valueOf = to_type__valueOf;
  momentPrototype__proto.year = getSetYear;
  momentPrototype__proto.isLeapYear = getIsLeapYear;
  momentPrototype__proto.weekYear = getSetWeekYear;
  momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
  momentPrototype__proto.quarter = momentPrototype__proto.quarters =
    getSetQuarter;
  momentPrototype__proto.month = getSetMonth;
  momentPrototype__proto.daysInMonth = getDaysInMonth;
  momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
  momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks =
    getSetISOWeek;
  momentPrototype__proto.weeksInYear = getWeeksInYear;
  momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
  momentPrototype__proto.date = getSetDayOfMonth;
  momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
  momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
  momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
  momentPrototype__proto.dayOfYear = getSetDayOfYear;
  momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
  momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
  momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
  momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds =
    getSetMillisecond;
  momentPrototype__proto.utcOffset = getSetOffset;
  momentPrototype__proto.utc = setOffsetToUTC;
  momentPrototype__proto.local = setOffsetToLocal;
  momentPrototype__proto.parseZone = setOffsetToParsedOffset;
  momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
  momentPrototype__proto.isDST = isDaylightSavingTime;
  momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
  momentPrototype__proto.isLocal = isLocal;
  momentPrototype__proto.isUtcOffset = isUtcOffset;
  momentPrototype__proto.isUtc = isUtc;
  momentPrototype__proto.isUTC = isUtc;
  momentPrototype__proto.zoneAbbr = getZoneAbbr;
  momentPrototype__proto.zoneName = getZoneName;
  momentPrototype__proto.dates = deprecate(
    "dates accessor is deprecated. Use date instead.",
    getSetDayOfMonth
  );
  momentPrototype__proto.months = deprecate(
    "months accessor is deprecated. Use month instead",
    getSetMonth
  );
  momentPrototype__proto.years = deprecate(
    "years accessor is deprecated. Use year instead",
    getSetYear
  );
  momentPrototype__proto.zone = deprecate(
    "moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779",
    getSetZone
  );
  var momentPrototype = momentPrototype__proto;
  function moment__createUnix(input) {
    return local__createLocal(input * 1000);
  }
  function moment__createInZone() {
    return local__createLocal.apply(null, arguments).parseZone();
  }
  var defaultCalendar = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L",
  };
  function locale_calendar__calendar(key, mom, now) {
    var output = this._calendar[key];
    return typeof output === "function" ? output.call(mom, now) : output;
  }
  var defaultLongDateFormat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A",
  };
  function longDateFormat(key) {
    var format = this._longDateFormat[key],
      formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format || !formatUpper) {
      return format;
    }
    this._longDateFormat[key] = formatUpper.replace(
      /MMMM|MM|DD|dddd/g,
      function (val) {
        return val.slice(1);
      }
    );
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = "Invalid date";
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = "%d";
  var defaultOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace("%d", number);
  }
  function preParsePostFormat(string) {
    return string;
  }
  var defaultRelativeTime = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years",
  };
  function relative__relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return typeof output === "function"
      ? output(number, withoutSuffix, string, isFuture)
      : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? "future" : "past"];
    return typeof format === "function"
      ? format(output)
      : format.replace(/%s/i, output);
  }
  function locale_set__set(config) {
    var prop, i;
    for (i in config) {
      prop = config[i];
      if (typeof prop === "function") {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
    this._ordinalParseLenient = new RegExp(
      this._ordinalParse.source + "|" + /\d{1,2}/.source
    );
  }
  var prototype__proto = Locale.prototype;
  prototype__proto._calendar = defaultCalendar;
  prototype__proto.calendar = locale_calendar__calendar;
  prototype__proto._longDateFormat = defaultLongDateFormat;
  prototype__proto.longDateFormat = longDateFormat;
  prototype__proto._invalidDate = defaultInvalidDate;
  prototype__proto.invalidDate = invalidDate;
  prototype__proto._ordinal = defaultOrdinal;
  prototype__proto.ordinal = ordinal;
  prototype__proto._ordinalParse = defaultOrdinalParse;
  prototype__proto.preparse = preParsePostFormat;
  prototype__proto.postformat = preParsePostFormat;
  prototype__proto._relativeTime = defaultRelativeTime;
  prototype__proto.relativeTime = relative__relativeTime;
  prototype__proto.pastFuture = pastFuture;
  prototype__proto.set = locale_set__set;
  prototype__proto.months = localeMonths;
  prototype__proto._months = defaultLocaleMonths;
  prototype__proto.monthsShort = localeMonthsShort;
  prototype__proto._monthsShort = defaultLocaleMonthsShort;
  prototype__proto.monthsParse = localeMonthsParse;
  prototype__proto.week = localeWeek;
  prototype__proto._week = defaultLocaleWeek;
  prototype__proto.firstDayOfYear = localeFirstDayOfYear;
  prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
  prototype__proto.weekdays = localeWeekdays;
  prototype__proto._weekdays = defaultLocaleWeekdays;
  prototype__proto.weekdaysMin = localeWeekdaysMin;
  prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
  prototype__proto.weekdaysShort = localeWeekdaysShort;
  prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
  prototype__proto.weekdaysParse = localeWeekdaysParse;
  prototype__proto.isPM = localeIsPM;
  prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
  prototype__proto.meridiem = localeMeridiem;
  function lists__get(format, index, field, setter) {
    var locale = locale_locales__getLocale();
    var utc = create_utc__createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function list(format, index, field, count, setter) {
    if (typeof format === "number") {
      index = format;
      format = undefined;
    }
    format = format || "";
    if (index != null) {
      return lists__get(format, index, field, setter);
    }
    var i;
    var out = [];
    for (i = 0; i < count; i++) {
      out[i] = lists__get(format, i, field, setter);
    }
    return out;
  }
  function lists__listMonths(format, index) {
    return list(format, index, "months", 12, "month");
  }
  function lists__listMonthsShort(format, index) {
    return list(format, index, "monthsShort", 12, "month");
  }
  function lists__listWeekdays(format, index) {
    return list(format, index, "weekdays", 7, "day");
  }
  function lists__listWeekdaysShort(format, index) {
    return list(format, index, "weekdaysShort", 7, "day");
  }
  function lists__listWeekdaysMin(format, index) {
    return list(format, index, "weekdaysMin", 7, "day");
  }
  locale_locales__getSetGlobalLocale("en", {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
        output =
          toInt((number % 100) / 10) === 1
            ? "th"
            : b === 1
            ? "st"
            : b === 2
            ? "nd"
            : b === 3
            ? "rd"
            : "th";
      return number + output;
    },
  });
  utils_hooks__hooks.lang = deprecate(
    "moment.lang is deprecated. Use moment.locale instead.",
    locale_locales__getSetGlobalLocale
  );
  utils_hooks__hooks.langData = deprecate(
    "moment.langData is deprecated. Use moment.localeData instead.",
    locale_locales__getLocale
  );
  var mathAbs = Math.abs;
  function duration_abs__abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function duration_add_subtract__addSubtract(
    duration,
    input,
    value,
    direction
  ) {
    var other = create__createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  function duration_add_subtract__add(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, 1);
  }
  function duration_add_subtract__subtract(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds, minutes, hours, years, monthsFromDays;
    if (
      !(
        (milliseconds >= 0 && days >= 0 && months >= 0) ||
        (milliseconds <= 0 && days <= 0 && months <= 0)
      )
    ) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }
    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));
    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToMonths(days) {
    return (days * 4800) / 146097;
  }
  function monthsToDays(months) {
    return (months * 146097) / 4800;
  }
  function as(units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === "month" || units === "year") {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      return units === "month" ? months : months / 12;
    } else {
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case "week":
          return days / 7 + milliseconds / 6048e5;
        case "day":
          return days + milliseconds / 864e5;
        case "hour":
          return days * 24 + milliseconds / 36e5;
        case "minute":
          return days * 1440 + milliseconds / 6e4;
        case "second":
          return days * 86400 + milliseconds / 1000;
        case "millisecond":
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error("Unknown unit " + units);
      }
    }
  }
  function duration_as__valueOf() {
    return (
      this._milliseconds +
      this._days * 864e5 +
      (this._months % 12) * 2592e6 +
      toInt(this._months / 12) * 31536e6
    );
  }
  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs("ms");
  var asSeconds = makeAs("s");
  var asMinutes = makeAs("m");
  var asHours = makeAs("h");
  var asDays = makeAs("d");
  var asWeeks = makeAs("w");
  var asMonths = makeAs("M");
  var asYears = makeAs("y");
  function duration_get__get(units) {
    units = normalizeUnits(units);
    return this[units + "s"]();
  }
  function makeGetter(name) {
    return function () {
      return this._data[name];
    };
  }
  var milliseconds = makeGetter("milliseconds");
  var seconds = makeGetter("seconds");
  var minutes = makeGetter("minutes");
  var hours = makeGetter("hours");
  var days = makeGetter("days");
  var months = makeGetter("months");
  var years = makeGetter("years");
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round;
  var thresholds = { s: 45, m: 45, h: 22, d: 26, M: 11 };
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function duration_humanize__relativeTime(
    posNegDuration,
    withoutSuffix,
    locale
  ) {
    var duration = create__createDuration(posNegDuration).abs();
    var seconds = round(duration.as("s"));
    var minutes = round(duration.as("m"));
    var hours = round(duration.as("h"));
    var days = round(duration.as("d"));
    var months = round(duration.as("M"));
    var years = round(duration.as("y"));
    var a = (seconds < thresholds.s && ["s", seconds]) ||
      (minutes === 1 && ["m"]) ||
      (minutes < thresholds.m && ["mm", minutes]) ||
      (hours === 1 && ["h"]) ||
      (hours < thresholds.h && ["hh", hours]) ||
      (days === 1 && ["d"]) ||
      (days < thresholds.d && ["dd", days]) ||
      (months === 1 && ["M"]) ||
      (months < thresholds.M && ["MM", months]) ||
      (years === 1 && ["y"]) || ["yy", years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }
  function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
  }
  function humanize(withSuffix) {
    var locale = this.localeData();
    var output = duration_humanize__relativeTime(this, !withSuffix, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var iso_string__abs = Math.abs;
  function iso_string__toISOString() {
    var seconds = iso_string__abs(this._milliseconds) / 1000;
    var days = iso_string__abs(this._days);
    var months = iso_string__abs(this._months);
    var minutes, hours, years;
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;
    years = absFloor(months / 12);
    months %= 12;
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();
    if (!total) {
      return "P0D";
    }
    return (
      (total < 0 ? "-" : "") +
      "P" +
      (Y ? Y + "Y" : "") +
      (M ? M + "M" : "") +
      (D ? D + "D" : "") +
      (h || m || s ? "T" : "") +
      (h ? h + "H" : "") +
      (m ? m + "M" : "") +
      (s ? s + "S" : "")
    );
  }
  var duration_prototype__proto = Duration.prototype;
  duration_prototype__proto.abs = duration_abs__abs;
  duration_prototype__proto.add = duration_add_subtract__add;
  duration_prototype__proto.subtract = duration_add_subtract__subtract;
  duration_prototype__proto.as = as;
  duration_prototype__proto.asMilliseconds = asMilliseconds;
  duration_prototype__proto.asSeconds = asSeconds;
  duration_prototype__proto.asMinutes = asMinutes;
  duration_prototype__proto.asHours = asHours;
  duration_prototype__proto.asDays = asDays;
  duration_prototype__proto.asWeeks = asWeeks;
  duration_prototype__proto.asMonths = asMonths;
  duration_prototype__proto.asYears = asYears;
  duration_prototype__proto.valueOf = duration_as__valueOf;
  duration_prototype__proto._bubble = bubble;
  duration_prototype__proto.get = duration_get__get;
  duration_prototype__proto.milliseconds = milliseconds;
  duration_prototype__proto.seconds = seconds;
  duration_prototype__proto.minutes = minutes;
  duration_prototype__proto.hours = hours;
  duration_prototype__proto.days = days;
  duration_prototype__proto.weeks = weeks;
  duration_prototype__proto.months = months;
  duration_prototype__proto.years = years;
  duration_prototype__proto.humanize = humanize;
  duration_prototype__proto.toISOString = iso_string__toISOString;
  duration_prototype__proto.toString = iso_string__toISOString;
  duration_prototype__proto.toJSON = iso_string__toISOString;
  duration_prototype__proto.locale = locale;
  duration_prototype__proto.localeData = localeData;
  duration_prototype__proto.toIsoString = deprecate(
    "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
    iso_string__toISOString
  );
  duration_prototype__proto.lang = lang;
  addFormatToken("X", 0, 0, "unix");
  addFormatToken("x", 0, 0, "valueOf");
  addRegexToken("x", matchSigned);
  addRegexToken("X", matchTimestamp);
  addParseToken("X", function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken("x", function (input, array, config) {
    config._d = new Date(toInt(input));
  });
  utils_hooks__hooks.version = "2.10.6";
  setHookCallback(local__createLocal);
  utils_hooks__hooks.fn = momentPrototype;
  utils_hooks__hooks.min = min;
  utils_hooks__hooks.max = max;
  utils_hooks__hooks.utc = create_utc__createUTC;
  utils_hooks__hooks.unix = moment__createUnix;
  utils_hooks__hooks.months = lists__listMonths;
  utils_hooks__hooks.isDate = isDate;
  utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
  utils_hooks__hooks.invalid = valid__createInvalid;
  utils_hooks__hooks.duration = create__createDuration;
  utils_hooks__hooks.isMoment = isMoment;
  utils_hooks__hooks.weekdays = lists__listWeekdays;
  utils_hooks__hooks.parseZone = moment__createInZone;
  utils_hooks__hooks.localeData = locale_locales__getLocale;
  utils_hooks__hooks.isDuration = isDuration;
  utils_hooks__hooks.monthsShort = lists__listMonthsShort;
  utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
  utils_hooks__hooks.defineLocale = defineLocale;
  utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
  utils_hooks__hooks.normalizeUnits = normalizeUnits;
  utils_hooks__hooks.relativeTimeThreshold =
    duration_humanize__getSetRelativeTimeThreshold;
  var _moment = utils_hooks__hooks;
  return _moment;
});
(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    var _OldCookies = window.Cookies;
    var api = (window.Cookies = factory());
    api.noConflict = function () {
      window.Cookies = _OldCookies;
      return api;
    };
  }
})(function () {
  function extend() {
    var i = 0;
    var result = {};
    for (; i < arguments.length; i++) {
      var attributes = arguments[i];
      for (var key in attributes) {
        result[key] = attributes[key];
      }
    }
    return result;
  }
  function init(converter) {
    function api(key, value, attributes) {
      var result;
      if (arguments.length > 1) {
        attributes = extend({ path: "/" }, api.defaults, attributes);
        if (typeof attributes.expires === "number") {
          var expires = new Date();
          expires.setMilliseconds(
            expires.getMilliseconds() + attributes.expires * 864e5
          );
          attributes.expires = expires;
        }
        try {
          result = JSON.stringify(value);
          if (/^[\{\[]/.test(result)) {
            value = result;
          }
        } catch (e) {}
        value = encodeURIComponent(String(value));
        value = value.replace(
          /%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,
          decodeURIComponent
        );
        key = encodeURIComponent(String(key));
        key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
        key = key.replace(/[\(\)]/g, escape);
        return (document.cookie = [
          key,
          "=",
          value,
          attributes.expires && "; expires=" + attributes.expires.toUTCString(),
          attributes.path && "; path=" + attributes.path,
          attributes.domain && "; domain=" + attributes.domain,
          attributes.secure ? "; secure" : "",
        ].join(""));
      }
      if (!key) {
        result = {};
      }
      var cookies = document.cookie ? document.cookie.split("; ") : [];
      var rdecode = /(%[0-9A-Z]{2})+/g;
      var i = 0;
      for (; i < cookies.length; i++) {
        var parts = cookies[i].split("=");
        var name = parts[0].replace(rdecode, decodeURIComponent);
        var cookie = parts.slice(1).join("=");
        if (cookie.charAt(0) === '"') {
          cookie = cookie.slice(1, -1);
        }
        try {
          cookie =
            (converter && converter(cookie, name)) ||
            cookie.replace(rdecode, decodeURIComponent);
          if (this.json) {
            try {
              cookie = JSON.parse(cookie);
            } catch (e) {}
          }
          if (key === name) {
            result = cookie;
            break;
          }
          if (!key) {
            result[name] = cookie;
          }
        } catch (e) {}
      }
      return result;
    }
    api.get = api.set = api;
    api.getJSON = function () {
      return api.apply({ json: true }, [].slice.call(arguments));
    };
    api.defaults = {};
    api.remove = function (key, attributes) {
      api(key, "", extend(attributes, { expires: -1 }));
    };
    api.withConverter = init;
    return api;
  }
  return init();
});
var SITE_LANGUAGE = "en";
var sitePlatform = "Web";
var siteLanguage = SITE_LANGUAGE == "ar" ? "Arabic" : "English";
var currentCategory = $.trim($(".dropdown_menu ul li a.current").text());
function pushHomePageViewedEvent() {
  let homePageViewedData = {
    "Referral Page": window.location.pathname,
    Platform: sitePlatform,
  };
  clevertap.event.push(clevertap_events.homePageViewed, homePageViewedData);
  console.log("Clevertap Web homePageViewed event pushed");
}
function pushCategoryViewedEvent(category) {
  let categoryViewedData = {
    "Category Name": category,
    "Referral Page": window.location.pathname,
    Store: "IN",
    Language: siteLanguage,
    Platform: sitePlatform,
  };
  clevertap.event.push(clevertap_events.categoryViewed, categoryViewedData);
  console.log("Clevertap Web CategoryViewed event pushed");
}
function pushTappedOnCartEvent() {
  let tappedOnCartData = { Platform: sitePlatform, Language: siteLanguage };
  clevertap.event.push(clevertap_events.tappedOnCart, tappedOnCartData);
}
function pushRemovedFromCartEvent() {
  let removedFromCartData = { Platform: sitePlatform, Language: siteLanguage };
  clevertap.event.push(clevertap_events.removedFromCart, removedFromCartData);
}
function pushTappedOnCheckoutCartEvent() {
  let tappedOnCheckoutCartData = {
    Platform: sitePlatform,
    Language: siteLanguage,
  };
  clevertap.event.push(
    clevertap_events.tappedOnCheckoutCart,
    tappedOnCheckoutCartData
  );
}
function pushWebsiteVistiorsEvent() {
  let websiteVistiorsData = { Platform: sitePlatform };
  clevertap.event.push(clevertap_events.websiteVistiors, websiteVistiorsData);
}
function pushTappedonMenuEvent(buttonName, subCategory, Next = "") {
  let tappedonMenuData = {
    "Button Name": buttonName,
    "Sub Category": subCategory,
    Platform: sitePlatform,
    Language: siteLanguage,
  };
  clevertap.event.push(clevertap_events.tappedOnMenu, tappedonMenuData);
}
$(document).ready(function () {
  $(".helpline-popover")
    .popover({
      trigger: "focus",
      html: true,
      placement: "bottom",
      container: $("body"),
      content: function () {
        var content = $(this).attr("data-popover-content");
        return $(content).html();
      },
    })
    .map(function () {
      $(this).data("bs.popover").tip().addClass("wrap-help-popover");
    });
  $(".helpline-popover").on("show.bs.popover", function () {
    let tappedOnHelplineData = {
      "Page Name": window.location.pathname,
      Platform: sitePlatform,
    };
    clevertap.event.push(
      clevertap_events.tappedOnHelpline,
      tappedOnHelplineData
    );
    console.log("Clevertap Web tappedOnHelpline event pushed");
  });
  $(".help-email").on("click", function () {
    clevertap.event.push(
      clevertap_events.tappedOnMail,
      clevertap_events_data.tappedOnMailWeb
    );
    console.log("Clevertap Web tappedOnMail event pushed");
  });
  $(".group-gift-link").on("click", function () {
    sessionStorage.setItem("currentCategory", currentCategory);
    sessionStorage.setItem("storeCode", "IN");
    clevertap.event.push(clevertap_events.viewedGroupGift, "");
  });
  $(".search-block .countries-select").on("change", function () {
    if (typeof GROUP_GIFT !== "undefined") {
      let tappedRegionGGData = {
        "Occasion Name": sessionStorage.getItem("groupGiftOccassion"),
        "Region Name": $(this).find("option:selected").data("country"),
      };
      clevertap.event.push(clevertap_events.tappedRegionGG, tappedRegionGGData);
    }
  });
  if (sessionStorage.getItem("activeSession") == null) {
    pushWebsiteVistiorsEvent();
    sessionStorage.setItem("activeSession", "true");
  }
});
function resetAmtExceedValidation() {
  $(".select-amount").removeClass("error");
  $(".card-amount").find("p.limitExceedAmt").addClass("hide");
}
function showNotify(icotype) {
  var giftImg = $(".first-cart .gift-img img").attr("src");
  var brandImg = $(".first-cart .brand img").attr("src");
  if ($(".first-cart .gift-img img").attr("src") == "") {
    var html = '<div class="brand-img"><img src="' + brandImg + '"/></div>';
  } else {
    var html =
      '<div class="gift-img"><img src="' +
      giftImg +
      '" /></div><div class="brand-img"><img src="' +
      brandImg +
      '"/></div>';
  }
  var $notificationAdd = $(".cart-notify-add");
  var $notificationRemove = $(".cart-notify-remove");
  var message = "";
  if (icotype == "removed") {
    message =
      '<span class="icon icon-cart"><span class="icon icon-bullet-round"><span class="icon icon-minus-1"></span></span></span> ' +
      gettext("eGift Card removed.");
  } else if (icotype == "added") {
    message =
      '<div class="gift-block">' +
      html +
      '</div><div class="info"><span class="icon icon-cart"><span class="icon icon-bullet-round"><span class="icon icon-plus-1"></span></span></span> ' +
      gettext("New eGift Card added to the cart.") +
      "</div>";
  }
  setTimeout(function () {
    if (icotype == "removed") {
      if ($notificationRemove.css("visibility") == "hidden") {
        $notificationRemove.html(message);
        $notificationRemove.addClass("open");
        resetAmtExceedValidation();
      }
    } else if (icotype == "added") {
      if ($notificationAdd.css("visibility") == "hidden") {
        $notificationAdd.html(message);
        $notificationAdd.addClass("open");
      }
    }
    setTimeout(function () {
      if (icotype == "removed") {
        $notificationRemove.removeClass("open");
      } else if (icotype == "added") {
        $notificationAdd.removeClass("open");
      }
    }, 2500);
  }, 500);
}
!(function (a, b) {
  "object" == typeof exports && "object" == typeof module
    ? (module.exports = b())
    : "function" == typeof define && define.amd
    ? define([], b)
    : "object" == typeof exports
    ? (exports.Handlebars = b())
    : (a.Handlebars = b());
})(this, function () {
  return (function (a) {
    function b(d) {
      if (c[d]) return c[d].exports;
      var e = (c[d] = { exports: {}, id: d, loaded: !1 });
      return a[d].call(e.exports, e, e.exports, b), (e.loaded = !0), e.exports;
    }
    var c = {};
    return (b.m = a), (b.c = c), (b.p = ""), b(0);
  })([
    function (a, b, c) {
      "use strict";
      function d() {
        var a = r();
        return (
          (a.compile = function (b, c) {
            return k.compile(b, c, a);
          }),
          (a.precompile = function (b, c) {
            return k.precompile(b, c, a);
          }),
          (a.AST = i["default"]),
          (a.Compiler = k.Compiler),
          (a.JavaScriptCompiler = m["default"]),
          (a.Parser = j.parser),
          (a.parse = j.parse),
          a
        );
      }
      var e = c(1)["default"];
      b.__esModule = !0;
      var f = c(2),
        g = e(f),
        h = c(21),
        i = e(h),
        j = c(22),
        k = c(27),
        l = c(28),
        m = e(l),
        n = c(25),
        o = e(n),
        p = c(20),
        q = e(p),
        r = g["default"].create,
        s = d();
      (s.create = d),
        q["default"](s),
        (s.Visitor = o["default"]),
        (s["default"] = s),
        (b["default"] = s),
        (a.exports = b["default"]);
    },
    function (a, b) {
      "use strict";
      (b["default"] = function (a) {
        return a && a.__esModule ? a : { default: a };
      }),
        (b.__esModule = !0);
    },
    function (a, b, c) {
      "use strict";
      function d() {
        var a = new h.HandlebarsEnvironment();
        return (
          n.extend(a, h),
          (a.SafeString = j["default"]),
          (a.Exception = l["default"]),
          (a.Utils = n),
          (a.escapeExpression = n.escapeExpression),
          (a.VM = p),
          (a.template = function (b) {
            return p.template(b, a);
          }),
          a
        );
      }
      var e = c(3)["default"],
        f = c(1)["default"];
      b.__esModule = !0;
      var g = c(4),
        h = e(g),
        i = c(18),
        j = f(i),
        k = c(6),
        l = f(k),
        m = c(5),
        n = e(m),
        o = c(19),
        p = e(o),
        q = c(20),
        r = f(q),
        s = d();
      (s.create = d),
        r["default"](s),
        (s["default"] = s),
        (b["default"] = s),
        (a.exports = b["default"]);
    },
    function (a, b) {
      "use strict";
      (b["default"] = function (a) {
        if (a && a.__esModule) return a;
        var b = {};
        if (null != a)
          for (var c in a)
            Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);
        return (b["default"] = a), b;
      }),
        (b.__esModule = !0);
    },
    function (a, b, c) {
      "use strict";
      function d(a, b, c) {
        (this.helpers = a || {}),
          (this.partials = b || {}),
          (this.decorators = c || {}),
          i.registerDefaultHelpers(this),
          j.registerDefaultDecorators(this);
      }
      var e = c(1)["default"];
      (b.__esModule = !0), (b.HandlebarsEnvironment = d);
      var f = c(5),
        g = c(6),
        h = e(g),
        i = c(7),
        j = c(15),
        k = c(17),
        l = e(k),
        m = "4.0.5";
      b.VERSION = m;
      var n = 7;
      b.COMPILER_REVISION = n;
      var o = {
        1: "<= 1.0.rc.2",
        2: "== 1.0.0-rc.3",
        3: "== 1.0.0-rc.4",
        4: "== 1.x.x",
        5: "== 2.0.0-alpha.x",
        6: ">= 2.0.0-beta.1",
        7: ">= 4.0.0",
      };
      b.REVISION_CHANGES = o;
      var p = "[object Object]";
      d.prototype = {
        constructor: d,
        logger: l["default"],
        log: l["default"].log,
        registerHelper: function (a, b) {
          if (f.toString.call(a) === p) {
            if (b)
              throw new h["default"]("Arg not supported with multiple helpers");
            f.extend(this.helpers, a);
          } else this.helpers[a] = b;
        },
        unregisterHelper: function (a) {
          delete this.helpers[a];
        },
        registerPartial: function (a, b) {
          if (f.toString.call(a) === p) f.extend(this.partials, a);
          else {
            if ("undefined" == typeof b)
              throw new h["default"](
                'Attempting to register a partial called "' +
                  a +
                  '" as undefined'
              );
            this.partials[a] = b;
          }
        },
        unregisterPartial: function (a) {
          delete this.partials[a];
        },
        registerDecorator: function (a, b) {
          if (f.toString.call(a) === p) {
            if (b)
              throw new h["default"](
                "Arg not supported with multiple decorators"
              );
            f.extend(this.decorators, a);
          } else this.decorators[a] = b;
        },
        unregisterDecorator: function (a) {
          delete this.decorators[a];
        },
      };
      var q = l["default"].log;
      (b.log = q), (b.createFrame = f.createFrame), (b.logger = l["default"]);
    },
    function (a, b) {
      "use strict";
      function c(a) {
        return k[a];
      }
      function d(a) {
        for (var b = 1; b < arguments.length; b++)
          for (var c in arguments[b])
            Object.prototype.hasOwnProperty.call(arguments[b], c) &&
              (a[c] = arguments[b][c]);
        return a;
      }
      function e(a, b) {
        for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
        return -1;
      }
      function f(a) {
        if ("string" != typeof a) {
          if (a && a.toHTML) return a.toHTML();
          if (null == a) return "";
          if (!a) return a + "";
          a = "" + a;
        }
        return m.test(a) ? a.replace(l, c) : a;
      }
      function g(a) {
        return a || 0 === a ? (p(a) && 0 === a.length ? !0 : !1) : !0;
      }
      function h(a) {
        var b = d({}, a);
        return (b._parent = a), b;
      }
      function i(a, b) {
        return (a.path = b), a;
      }
      function j(a, b) {
        return (a ? a + "." : "") + b;
      }
      (b.__esModule = !0),
        (b.extend = d),
        (b.indexOf = e),
        (b.escapeExpression = f),
        (b.isEmpty = g),
        (b.createFrame = h),
        (b.blockParams = i),
        (b.appendContextPath = j);
      var k = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#x27;",
          "`": "&#x60;",
          "=": "&#x3D;",
        },
        l = /[&<>"'`=]/g,
        m = /[&<>"'`=]/,
        n = Object.prototype.toString;
      b.toString = n;
      var o = function (a) {
        return "function" == typeof a;
      };
      o(/x/) &&
        (b.isFunction = o =
          function (a) {
            return "function" == typeof a && "[object Function]" === n.call(a);
          }),
        (b.isFunction = o);
      var p =
        Array.isArray ||
        function (a) {
          return a && "object" == typeof a
            ? "[object Array]" === n.call(a)
            : !1;
        };
      b.isArray = p;
    },
    function (a, b) {
      "use strict";
      function c(a, b) {
        var e = b && b.loc,
          f = void 0,
          g = void 0;
        e &&
          ((f = e.start.line),
          (g = e.start.column),
          (a += " - " + f + ":" + g));
        for (
          var h = Error.prototype.constructor.call(this, a), i = 0;
          i < d.length;
          i++
        )
          this[d[i]] = h[d[i]];
        Error.captureStackTrace && Error.captureStackTrace(this, c),
          e && ((this.lineNumber = f), (this.column = g));
      }
      b.__esModule = !0;
      var d = [
        "description",
        "fileName",
        "lineNumber",
        "message",
        "name",
        "number",
        "stack",
      ];
      (c.prototype = new Error()),
        (b["default"] = c),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      function d(a) {
        g["default"](a),
          i["default"](a),
          k["default"](a),
          m["default"](a),
          o["default"](a),
          q["default"](a),
          s["default"](a);
      }
      var e = c(1)["default"];
      (b.__esModule = !0), (b.registerDefaultHelpers = d);
      var f = c(8),
        g = e(f),
        h = c(9),
        i = e(h),
        j = c(10),
        k = e(j),
        l = c(11),
        m = e(l),
        n = c(12),
        o = e(n),
        p = c(13),
        q = e(p),
        r = c(14),
        s = e(r);
    },
    function (a, b, c) {
      "use strict";
      b.__esModule = !0;
      var d = c(5);
      (b["default"] = function (a) {
        a.registerHelper("blockHelperMissing", function (b, c) {
          var e = c.inverse,
            f = c.fn;
          if (b === !0) return f(this);
          if (b === !1 || null == b) return e(this);
          if (d.isArray(b))
            return b.length > 0
              ? (c.ids && (c.ids = [c.name]), a.helpers.each(b, c))
              : e(this);
          if (c.data && c.ids) {
            var g = d.createFrame(c.data);
            (g.contextPath = d.appendContextPath(c.data.contextPath, c.name)),
              (c = { data: g });
          }
          return f(b, c);
        });
      }),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      var d = c(1)["default"];
      b.__esModule = !0;
      var e = c(5),
        f = c(6),
        g = d(f);
      (b["default"] = function (a) {
        a.registerHelper("each", function (a, b) {
          function c(b, c, f) {
            j &&
              ((j.key = b),
              (j.index = c),
              (j.first = 0 === c),
              (j.last = !!f),
              k && (j.contextPath = k + b)),
              (i += d(a[b], {
                data: j,
                blockParams: e.blockParams([a[b], b], [k + b, null]),
              }));
          }
          if (!b) throw new g["default"]("Must pass iterator to #each");
          var d = b.fn,
            f = b.inverse,
            h = 0,
            i = "",
            j = void 0,
            k = void 0;
          if (
            (b.data &&
              b.ids &&
              (k = e.appendContextPath(b.data.contextPath, b.ids[0]) + "."),
            e.isFunction(a) && (a = a.call(this)),
            b.data && (j = e.createFrame(b.data)),
            a && "object" == typeof a)
          )
            if (e.isArray(a))
              for (var l = a.length; l > h; h++)
                h in a && c(h, h, h === a.length - 1);
            else {
              var m = void 0;
              for (var n in a)
                a.hasOwnProperty(n) &&
                  (void 0 !== m && c(m, h - 1), (m = n), h++);
              void 0 !== m && c(m, h - 1, !0);
            }
          return 0 === h && (i = f(this)), i;
        });
      }),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      var d = c(1)["default"];
      b.__esModule = !0;
      var e = c(6),
        f = d(e);
      (b["default"] = function (a) {
        a.registerHelper("helperMissing", function () {
          if (1 !== arguments.length)
            throw new f["default"](
              'Missing helper: "' + arguments[arguments.length - 1].name + '"'
            );
        });
      }),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      b.__esModule = !0;
      var d = c(5);
      (b["default"] = function (a) {
        a.registerHelper("if", function (a, b) {
          return (
            d.isFunction(a) && (a = a.call(this)),
            (!b.hash.includeZero && !a) || d.isEmpty(a)
              ? b.inverse(this)
              : b.fn(this)
          );
        }),
          a.registerHelper("unless", function (b, c) {
            return a.helpers["if"].call(this, b, {
              fn: c.inverse,
              inverse: c.fn,
              hash: c.hash,
            });
          });
      }),
        (a.exports = b["default"]);
    },
    function (a, b) {
      "use strict";
      (b.__esModule = !0),
        (b["default"] = function (a) {
          a.registerHelper("log", function () {
            for (
              var b = [void 0], c = arguments[arguments.length - 1], d = 0;
              d < arguments.length - 1;
              d++
            )
              b.push(arguments[d]);
            var e = 1;
            null != c.hash.level
              ? (e = c.hash.level)
              : c.data && null != c.data.level && (e = c.data.level),
              (b[0] = e),
              a.log.apply(a, b);
          });
        }),
        (a.exports = b["default"]);
    },
    function (a, b) {
      "use strict";
      (b.__esModule = !0),
        (b["default"] = function (a) {
          a.registerHelper("lookup", function (a, b) {
            return a && a[b];
          });
        }),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      b.__esModule = !0;
      var d = c(5);
      (b["default"] = function (a) {
        a.registerHelper("with", function (a, b) {
          d.isFunction(a) && (a = a.call(this));
          var c = b.fn;
          if (d.isEmpty(a)) return b.inverse(this);
          var e = b.data;
          return (
            b.data &&
              b.ids &&
              ((e = d.createFrame(b.data)),
              (e.contextPath = d.appendContextPath(
                b.data.contextPath,
                b.ids[0]
              ))),
            c(a, {
              data: e,
              blockParams: d.blockParams([a], [e && e.contextPath]),
            })
          );
        });
      }),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      function d(a) {
        g["default"](a);
      }
      var e = c(1)["default"];
      (b.__esModule = !0), (b.registerDefaultDecorators = d);
      var f = c(16),
        g = e(f);
    },
    function (a, b, c) {
      "use strict";
      b.__esModule = !0;
      var d = c(5);
      (b["default"] = function (a) {
        a.registerDecorator("inline", function (a, b, c, e) {
          var f = a;
          return (
            b.partials ||
              ((b.partials = {}),
              (f = function (e, f) {
                var g = c.partials;
                c.partials = d.extend({}, g, b.partials);
                var h = a(e, f);
                return (c.partials = g), h;
              })),
            (b.partials[e.args[0]] = e.fn),
            f
          );
        });
      }),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      b.__esModule = !0;
      var d = c(5),
        e = {
          methodMap: ["debug", "info", "warn", "error"],
          level: "info",
          lookupLevel: function (a) {
            if ("string" == typeof a) {
              var b = d.indexOf(e.methodMap, a.toLowerCase());
              a = b >= 0 ? b : parseInt(a, 10);
            }
            return a;
          },
          log: function (a) {
            if (
              ((a = e.lookupLevel(a)),
              "undefined" != typeof console && e.lookupLevel(e.level) <= a)
            ) {
              var b = e.methodMap[a];
              console[b] || (b = "log");
              for (
                var c = arguments.length, d = Array(c > 1 ? c - 1 : 0), f = 1;
                c > f;
                f++
              )
                d[f - 1] = arguments[f];
              console[b].apply(console, d);
            }
          },
        };
      (b["default"] = e), (a.exports = b["default"]);
    },
    function (a, b) {
      "use strict";
      function c(a) {
        this.string = a;
      }
      (b.__esModule = !0),
        (c.prototype.toString = c.prototype.toHTML =
          function () {
            return "" + this.string;
          }),
        (b["default"] = c),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      function d(a) {
        var b = (a && a[0]) || 1,
          c = r.COMPILER_REVISION;
        if (b !== c) {
          if (c > b) {
            var d = r.REVISION_CHANGES[c],
              e = r.REVISION_CHANGES[b];
            throw new q["default"](
              "Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" +
                d +
                ") or downgrade your runtime to an older version (" +
                e +
                ")."
            );
          }
          throw new q["default"](
            "Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" +
              a[1] +
              ")."
          );
        }
      }
      function e(a, b) {
        function c(c, d, e) {
          e.hash && ((d = o.extend({}, d, e.hash)), e.ids && (e.ids[0] = !0)),
            (c = b.VM.resolvePartial.call(this, c, d, e));
          var f = b.VM.invokePartial.call(this, c, d, e);
          if (
            (null == f &&
              b.compile &&
              ((e.partials[e.name] = b.compile(c, a.compilerOptions, b)),
              (f = e.partials[e.name](d, e))),
            null != f)
          ) {
            if (e.indent) {
              for (
                var g = f.split("\n"), h = 0, i = g.length;
                i > h && (g[h] || h + 1 !== i);
                h++
              )
                g[h] = e.indent + g[h];
              f = g.join("\n");
            }
            return f;
          }
          throw new q["default"](
            "The partial " +
              e.name +
              " could not be compiled when running in runtime-only mode"
          );
        }
        function d(b) {
          function c(b) {
            return "" + a.main(e, b, e.helpers, e.partials, g, i, h);
          }
          var f =
              arguments.length <= 1 || void 0 === arguments[1]
                ? {}
                : arguments[1],
            g = f.data;
          d._setup(f), !f.partial && a.useData && (g = j(b, g));
          var h = void 0,
            i = a.useBlockParams ? [] : void 0;
          return (
            a.useDepths &&
              (h = f.depths
                ? b !== f.depths[0]
                  ? [b].concat(f.depths)
                  : f.depths
                : [b]),
            (c = k(a.main, c, e, f.depths || [], g, i))(b, f)
          );
        }
        if (!b) throw new q["default"]("No environment passed to template");
        if (!a || !a.main)
          throw new q["default"]("Unknown template object: " + typeof a);
        (a.main.decorator = a.main_d), b.VM.checkRevision(a.compiler);
        var e = {
          strict: function (a, b) {
            if (!(b in a))
              throw new q["default"]('"' + b + '" not defined in ' + a);
            return a[b];
          },
          lookup: function (a, b) {
            for (var c = a.length, d = 0; c > d; d++)
              if (a[d] && null != a[d][b]) return a[d][b];
          },
          lambda: function (a, b) {
            return "function" == typeof a ? a.call(b) : a;
          },
          escapeExpression: o.escapeExpression,
          invokePartial: c,
          fn: function (b) {
            var c = a[b];
            return (c.decorator = a[b + "_d"]), c;
          },
          programs: [],
          program: function (a, b, c, d, e) {
            var g = this.programs[a],
              h = this.fn(a);
            return (
              b || e || d || c
                ? (g = f(this, a, h, b, c, d, e))
                : g || (g = this.programs[a] = f(this, a, h)),
              g
            );
          },
          data: function (a, b) {
            for (; a && b--; ) a = a._parent;
            return a;
          },
          merge: function (a, b) {
            var c = a || b;
            return a && b && a !== b && (c = o.extend({}, b, a)), c;
          },
          noop: b.VM.noop,
          compilerInfo: a.compiler,
        };
        return (
          (d.isTop = !0),
          (d._setup = function (c) {
            c.partial
              ? ((e.helpers = c.helpers),
                (e.partials = c.partials),
                (e.decorators = c.decorators))
              : ((e.helpers = e.merge(c.helpers, b.helpers)),
                a.usePartial && (e.partials = e.merge(c.partials, b.partials)),
                (a.usePartial || a.useDecorators) &&
                  (e.decorators = e.merge(c.decorators, b.decorators)));
          }),
          (d._child = function (b, c, d, g) {
            if (a.useBlockParams && !d)
              throw new q["default"]("must pass block params");
            if (a.useDepths && !g)
              throw new q["default"]("must pass parent depths");
            return f(e, b, a[b], c, 0, d, g);
          }),
          d
        );
      }
      function f(a, b, c, d, e, f, g) {
        function h(b) {
          var e =
              arguments.length <= 1 || void 0 === arguments[1]
                ? {}
                : arguments[1],
            h = g;
          return (
            g && b !== g[0] && (h = [b].concat(g)),
            c(
              a,
              b,
              a.helpers,
              a.partials,
              e.data || d,
              f && [e.blockParams].concat(f),
              h
            )
          );
        }
        return (
          (h = k(c, h, a, g, d, f)),
          (h.program = b),
          (h.depth = g ? g.length : 0),
          (h.blockParams = e || 0),
          h
        );
      }
      function g(a, b, c) {
        return (
          a
            ? a.call || c.name || ((c.name = a), (a = c.partials[a]))
            : (a =
                "@partial-block" === c.name
                  ? c.data["partial-block"]
                  : c.partials[c.name]),
          a
        );
      }
      function h(a, b, c) {
        (c.partial = !0),
          c.ids && (c.data.contextPath = c.ids[0] || c.data.contextPath);
        var d = void 0;
        if (
          (c.fn &&
            c.fn !== i &&
            ((c.data = r.createFrame(c.data)),
            (d = c.data["partial-block"] = c.fn),
            d.partials && (c.partials = o.extend({}, c.partials, d.partials))),
          void 0 === a && d && (a = d),
          void 0 === a)
        )
          throw new q["default"](
            "The partial " + c.name + " could not be found"
          );
        return a instanceof Function ? a(b, c) : void 0;
      }
      function i() {
        return "";
      }
      function j(a, b) {
        return (
          (b && "root" in b) || ((b = b ? r.createFrame(b) : {}), (b.root = a)),
          b
        );
      }
      function k(a, b, c, d, e, f) {
        if (a.decorator) {
          var g = {};
          (b = a.decorator(b, g, c, d && d[0], e, f, d)), o.extend(b, g);
        }
        return b;
      }
      var l = c(3)["default"],
        m = c(1)["default"];
      (b.__esModule = !0),
        (b.checkRevision = d),
        (b.template = e),
        (b.wrapProgram = f),
        (b.resolvePartial = g),
        (b.invokePartial = h),
        (b.noop = i);
      var n = c(5),
        o = l(n),
        p = c(6),
        q = m(p),
        r = c(4);
    },
    function (a, b) {
      (function (c) {
        "use strict";
        (b.__esModule = !0),
          (b["default"] = function (a) {
            var b = "undefined" != typeof c ? c : window,
              d = b.Handlebars;
            a.noConflict = function () {
              return b.Handlebars === a && (b.Handlebars = d), a;
            };
          }),
          (a.exports = b["default"]);
      }).call(
        b,
        (function () {
          return this;
        })()
      );
    },
    function (a, b) {
      "use strict";
      b.__esModule = !0;
      var c = {
        helpers: {
          helperExpression: function (a) {
            return (
              "SubExpression" === a.type ||
              (("MustacheStatement" === a.type ||
                "BlockStatement" === a.type) &&
                !!((a.params && a.params.length) || a.hash))
            );
          },
          scopedId: function (a) {
            return /^\.|this\b/.test(a.original);
          },
          simpleId: function (a) {
            return 1 === a.parts.length && !c.helpers.scopedId(a) && !a.depth;
          },
        },
      };
      (b["default"] = c), (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      function d(a, b) {
        if ("Program" === a.type) return a;
        (h["default"].yy = n),
          (n.locInfo = function (a) {
            return new n.SourceLocation(b && b.srcName, a);
          });
        var c = new j["default"](b);
        return c.accept(h["default"].parse(a));
      }
      var e = c(1)["default"],
        f = c(3)["default"];
      (b.__esModule = !0), (b.parse = d);
      var g = c(23),
        h = e(g),
        i = c(24),
        j = e(i),
        k = c(26),
        l = f(k),
        m = c(5);
      b.parser = h["default"];
      var n = {};
      m.extend(n, l);
    },
    function (a, b) {
      "use strict";
      var c = (function () {
        function a() {
          this.yy = {};
        }
        var b = {
            trace: function () {},
            yy: {},
            symbols_: {
              error: 2,
              root: 3,
              program: 4,
              EOF: 5,
              program_repetition0: 6,
              statement: 7,
              mustache: 8,
              block: 9,
              rawBlock: 10,
              partial: 11,
              partialBlock: 12,
              content: 13,
              COMMENT: 14,
              CONTENT: 15,
              openRawBlock: 16,
              rawBlock_repetition_plus0: 17,
              END_RAW_BLOCK: 18,
              OPEN_RAW_BLOCK: 19,
              helperName: 20,
              openRawBlock_repetition0: 21,
              openRawBlock_option0: 22,
              CLOSE_RAW_BLOCK: 23,
              openBlock: 24,
              block_option0: 25,
              closeBlock: 26,
              openInverse: 27,
              block_option1: 28,
              OPEN_BLOCK: 29,
              openBlock_repetition0: 30,
              openBlock_option0: 31,
              openBlock_option1: 32,
              CLOSE: 33,
              OPEN_INVERSE: 34,
              openInverse_repetition0: 35,
              openInverse_option0: 36,
              openInverse_option1: 37,
              openInverseChain: 38,
              OPEN_INVERSE_CHAIN: 39,
              openInverseChain_repetition0: 40,
              openInverseChain_option0: 41,
              openInverseChain_option1: 42,
              inverseAndProgram: 43,
              INVERSE: 44,
              inverseChain: 45,
              inverseChain_option0: 46,
              OPEN_ENDBLOCK: 47,
              OPEN: 48,
              mustache_repetition0: 49,
              mustache_option0: 50,
              OPEN_UNESCAPED: 51,
              mustache_repetition1: 52,
              mustache_option1: 53,
              CLOSE_UNESCAPED: 54,
              OPEN_PARTIAL: 55,
              partialName: 56,
              partial_repetition0: 57,
              partial_option0: 58,
              openPartialBlock: 59,
              OPEN_PARTIAL_BLOCK: 60,
              openPartialBlock_repetition0: 61,
              openPartialBlock_option0: 62,
              param: 63,
              sexpr: 64,
              OPEN_SEXPR: 65,
              sexpr_repetition0: 66,
              sexpr_option0: 67,
              CLOSE_SEXPR: 68,
              hash: 69,
              hash_repetition_plus0: 70,
              hashSegment: 71,
              ID: 72,
              EQUALS: 73,
              blockParams: 74,
              OPEN_BLOCK_PARAMS: 75,
              blockParams_repetition_plus0: 76,
              CLOSE_BLOCK_PARAMS: 77,
              path: 78,
              dataName: 79,
              STRING: 80,
              NUMBER: 81,
              BOOLEAN: 82,
              UNDEFINED: 83,
              NULL: 84,
              DATA: 85,
              pathSegments: 86,
              SEP: 87,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              5: "EOF",
              14: "COMMENT",
              15: "CONTENT",
              18: "END_RAW_BLOCK",
              19: "OPEN_RAW_BLOCK",
              23: "CLOSE_RAW_BLOCK",
              29: "OPEN_BLOCK",
              33: "CLOSE",
              34: "OPEN_INVERSE",
              39: "OPEN_INVERSE_CHAIN",
              44: "INVERSE",
              47: "OPEN_ENDBLOCK",
              48: "OPEN",
              51: "OPEN_UNESCAPED",
              54: "CLOSE_UNESCAPED",
              55: "OPEN_PARTIAL",
              60: "OPEN_PARTIAL_BLOCK",
              65: "OPEN_SEXPR",
              68: "CLOSE_SEXPR",
              72: "ID",
              73: "EQUALS",
              75: "OPEN_BLOCK_PARAMS",
              77: "CLOSE_BLOCK_PARAMS",
              80: "STRING",
              81: "NUMBER",
              82: "BOOLEAN",
              83: "UNDEFINED",
              84: "NULL",
              85: "DATA",
              87: "SEP",
            },
            productions_: [
              0,
              [3, 2],
              [4, 1],
              [7, 1],
              [7, 1],
              [7, 1],
              [7, 1],
              [7, 1],
              [7, 1],
              [7, 1],
              [13, 1],
              [10, 3],
              [16, 5],
              [9, 4],
              [9, 4],
              [24, 6],
              [27, 6],
              [38, 6],
              [43, 2],
              [45, 3],
              [45, 1],
              [26, 3],
              [8, 5],
              [8, 5],
              [11, 5],
              [12, 3],
              [59, 5],
              [63, 1],
              [63, 1],
              [64, 5],
              [69, 1],
              [71, 3],
              [74, 3],
              [20, 1],
              [20, 1],
              [20, 1],
              [20, 1],
              [20, 1],
              [20, 1],
              [20, 1],
              [56, 1],
              [56, 1],
              [79, 2],
              [78, 1],
              [86, 3],
              [86, 1],
              [6, 0],
              [6, 2],
              [17, 1],
              [17, 2],
              [21, 0],
              [21, 2],
              [22, 0],
              [22, 1],
              [25, 0],
              [25, 1],
              [28, 0],
              [28, 1],
              [30, 0],
              [30, 2],
              [31, 0],
              [31, 1],
              [32, 0],
              [32, 1],
              [35, 0],
              [35, 2],
              [36, 0],
              [36, 1],
              [37, 0],
              [37, 1],
              [40, 0],
              [40, 2],
              [41, 0],
              [41, 1],
              [42, 0],
              [42, 1],
              [46, 0],
              [46, 1],
              [49, 0],
              [49, 2],
              [50, 0],
              [50, 1],
              [52, 0],
              [52, 2],
              [53, 0],
              [53, 1],
              [57, 0],
              [57, 2],
              [58, 0],
              [58, 1],
              [61, 0],
              [61, 2],
              [62, 0],
              [62, 1],
              [66, 0],
              [66, 2],
              [67, 0],
              [67, 1],
              [70, 1],
              [70, 2],
              [76, 1],
              [76, 2],
            ],
            performAction: function (a, b, c, d, e, f, g) {
              var h = f.length - 1;
              switch (e) {
                case 1:
                  return f[h - 1];
                case 2:
                  this.$ = d.prepareProgram(f[h]);
                  break;
                case 3:
                  this.$ = f[h];
                  break;
                case 4:
                  this.$ = f[h];
                  break;
                case 5:
                  this.$ = f[h];
                  break;
                case 6:
                  this.$ = f[h];
                  break;
                case 7:
                  this.$ = f[h];
                  break;
                case 8:
                  this.$ = f[h];
                  break;
                case 9:
                  this.$ = {
                    type: "CommentStatement",
                    value: d.stripComment(f[h]),
                    strip: d.stripFlags(f[h], f[h]),
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 10:
                  this.$ = {
                    type: "ContentStatement",
                    original: f[h],
                    value: f[h],
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 11:
                  this.$ = d.prepareRawBlock(f[h - 2], f[h - 1], f[h], this._$);
                  break;
                case 12:
                  this.$ = { path: f[h - 3], params: f[h - 2], hash: f[h - 1] };
                  break;
                case 13:
                  this.$ = d.prepareBlock(
                    f[h - 3],
                    f[h - 2],
                    f[h - 1],
                    f[h],
                    !1,
                    this._$
                  );
                  break;
                case 14:
                  this.$ = d.prepareBlock(
                    f[h - 3],
                    f[h - 2],
                    f[h - 1],
                    f[h],
                    !0,
                    this._$
                  );
                  break;
                case 15:
                  this.$ = {
                    open: f[h - 5],
                    path: f[h - 4],
                    params: f[h - 3],
                    hash: f[h - 2],
                    blockParams: f[h - 1],
                    strip: d.stripFlags(f[h - 5], f[h]),
                  };
                  break;
                case 16:
                  this.$ = {
                    path: f[h - 4],
                    params: f[h - 3],
                    hash: f[h - 2],
                    blockParams: f[h - 1],
                    strip: d.stripFlags(f[h - 5], f[h]),
                  };
                  break;
                case 17:
                  this.$ = {
                    path: f[h - 4],
                    params: f[h - 3],
                    hash: f[h - 2],
                    blockParams: f[h - 1],
                    strip: d.stripFlags(f[h - 5], f[h]),
                  };
                  break;
                case 18:
                  this.$ = {
                    strip: d.stripFlags(f[h - 1], f[h - 1]),
                    program: f[h],
                  };
                  break;
                case 19:
                  var i = d.prepareBlock(
                      f[h - 2],
                      f[h - 1],
                      f[h],
                      f[h],
                      !1,
                      this._$
                    ),
                    j = d.prepareProgram([i], f[h - 1].loc);
                  (j.chained = !0),
                    (this.$ = { strip: f[h - 2].strip, program: j, chain: !0 });
                  break;
                case 20:
                  this.$ = f[h];
                  break;
                case 21:
                  this.$ = {
                    path: f[h - 1],
                    strip: d.stripFlags(f[h - 2], f[h]),
                  };
                  break;
                case 22:
                  this.$ = d.prepareMustache(
                    f[h - 3],
                    f[h - 2],
                    f[h - 1],
                    f[h - 4],
                    d.stripFlags(f[h - 4], f[h]),
                    this._$
                  );
                  break;
                case 23:
                  this.$ = d.prepareMustache(
                    f[h - 3],
                    f[h - 2],
                    f[h - 1],
                    f[h - 4],
                    d.stripFlags(f[h - 4], f[h]),
                    this._$
                  );
                  break;
                case 24:
                  this.$ = {
                    type: "PartialStatement",
                    name: f[h - 3],
                    params: f[h - 2],
                    hash: f[h - 1],
                    indent: "",
                    strip: d.stripFlags(f[h - 4], f[h]),
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 25:
                  this.$ = d.preparePartialBlock(
                    f[h - 2],
                    f[h - 1],
                    f[h],
                    this._$
                  );
                  break;
                case 26:
                  this.$ = {
                    path: f[h - 3],
                    params: f[h - 2],
                    hash: f[h - 1],
                    strip: d.stripFlags(f[h - 4], f[h]),
                  };
                  break;
                case 27:
                  this.$ = f[h];
                  break;
                case 28:
                  this.$ = f[h];
                  break;
                case 29:
                  this.$ = {
                    type: "SubExpression",
                    path: f[h - 3],
                    params: f[h - 2],
                    hash: f[h - 1],
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 30:
                  this.$ = {
                    type: "Hash",
                    pairs: f[h],
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 31:
                  this.$ = {
                    type: "HashPair",
                    key: d.id(f[h - 2]),
                    value: f[h],
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 32:
                  this.$ = d.id(f[h - 1]);
                  break;
                case 33:
                  this.$ = f[h];
                  break;
                case 34:
                  this.$ = f[h];
                  break;
                case 35:
                  this.$ = {
                    type: "StringLiteral",
                    value: f[h],
                    original: f[h],
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 36:
                  this.$ = {
                    type: "NumberLiteral",
                    value: Number(f[h]),
                    original: Number(f[h]),
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 37:
                  this.$ = {
                    type: "BooleanLiteral",
                    value: "true" === f[h],
                    original: "true" === f[h],
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 38:
                  this.$ = {
                    type: "UndefinedLiteral",
                    original: void 0,
                    value: void 0,
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 39:
                  this.$ = {
                    type: "NullLiteral",
                    original: null,
                    value: null,
                    loc: d.locInfo(this._$),
                  };
                  break;
                case 40:
                  this.$ = f[h];
                  break;
                case 41:
                  this.$ = f[h];
                  break;
                case 42:
                  this.$ = d.preparePath(!0, f[h], this._$);
                  break;
                case 43:
                  this.$ = d.preparePath(!1, f[h], this._$);
                  break;
                case 44:
                  f[h - 2].push({
                    part: d.id(f[h]),
                    original: f[h],
                    separator: f[h - 1],
                  }),
                    (this.$ = f[h - 2]);
                  break;
                case 45:
                  this.$ = [{ part: d.id(f[h]), original: f[h] }];
                  break;
                case 46:
                  this.$ = [];
                  break;
                case 47:
                  f[h - 1].push(f[h]);
                  break;
                case 48:
                  this.$ = [f[h]];
                  break;
                case 49:
                  f[h - 1].push(f[h]);
                  break;
                case 50:
                  this.$ = [];
                  break;
                case 51:
                  f[h - 1].push(f[h]);
                  break;
                case 58:
                  this.$ = [];
                  break;
                case 59:
                  f[h - 1].push(f[h]);
                  break;
                case 64:
                  this.$ = [];
                  break;
                case 65:
                  f[h - 1].push(f[h]);
                  break;
                case 70:
                  this.$ = [];
                  break;
                case 71:
                  f[h - 1].push(f[h]);
                  break;
                case 78:
                  this.$ = [];
                  break;
                case 79:
                  f[h - 1].push(f[h]);
                  break;
                case 82:
                  this.$ = [];
                  break;
                case 83:
                  f[h - 1].push(f[h]);
                  break;
                case 86:
                  this.$ = [];
                  break;
                case 87:
                  f[h - 1].push(f[h]);
                  break;
                case 90:
                  this.$ = [];
                  break;
                case 91:
                  f[h - 1].push(f[h]);
                  break;
                case 94:
                  this.$ = [];
                  break;
                case 95:
                  f[h - 1].push(f[h]);
                  break;
                case 98:
                  this.$ = [f[h]];
                  break;
                case 99:
                  f[h - 1].push(f[h]);
                  break;
                case 100:
                  this.$ = [f[h]];
                  break;
                case 101:
                  f[h - 1].push(f[h]);
              }
            },
            table: [
              {
                3: 1,
                4: 2,
                5: [2, 46],
                6: 3,
                14: [2, 46],
                15: [2, 46],
                19: [2, 46],
                29: [2, 46],
                34: [2, 46],
                48: [2, 46],
                51: [2, 46],
                55: [2, 46],
                60: [2, 46],
              },
              { 1: [3] },
              { 5: [1, 4] },
              {
                5: [2, 2],
                7: 5,
                8: 6,
                9: 7,
                10: 8,
                11: 9,
                12: 10,
                13: 11,
                14: [1, 12],
                15: [1, 20],
                16: 17,
                19: [1, 23],
                24: 15,
                27: 16,
                29: [1, 21],
                34: [1, 22],
                39: [2, 2],
                44: [2, 2],
                47: [2, 2],
                48: [1, 13],
                51: [1, 14],
                55: [1, 18],
                59: 19,
                60: [1, 24],
              },
              { 1: [2, 1] },
              {
                5: [2, 47],
                14: [2, 47],
                15: [2, 47],
                19: [2, 47],
                29: [2, 47],
                34: [2, 47],
                39: [2, 47],
                44: [2, 47],
                47: [2, 47],
                48: [2, 47],
                51: [2, 47],
                55: [2, 47],
                60: [2, 47],
              },
              {
                5: [2, 3],
                14: [2, 3],
                15: [2, 3],
                19: [2, 3],
                29: [2, 3],
                34: [2, 3],
                39: [2, 3],
                44: [2, 3],
                47: [2, 3],
                48: [2, 3],
                51: [2, 3],
                55: [2, 3],
                60: [2, 3],
              },
              {
                5: [2, 4],
                14: [2, 4],
                15: [2, 4],
                19: [2, 4],
                29: [2, 4],
                34: [2, 4],
                39: [2, 4],
                44: [2, 4],
                47: [2, 4],
                48: [2, 4],
                51: [2, 4],
                55: [2, 4],
                60: [2, 4],
              },
              {
                5: [2, 5],
                14: [2, 5],
                15: [2, 5],
                19: [2, 5],
                29: [2, 5],
                34: [2, 5],
                39: [2, 5],
                44: [2, 5],
                47: [2, 5],
                48: [2, 5],
                51: [2, 5],
                55: [2, 5],
                60: [2, 5],
              },
              {
                5: [2, 6],
                14: [2, 6],
                15: [2, 6],
                19: [2, 6],
                29: [2, 6],
                34: [2, 6],
                39: [2, 6],
                44: [2, 6],
                47: [2, 6],
                48: [2, 6],
                51: [2, 6],
                55: [2, 6],
                60: [2, 6],
              },
              {
                5: [2, 7],
                14: [2, 7],
                15: [2, 7],
                19: [2, 7],
                29: [2, 7],
                34: [2, 7],
                39: [2, 7],
                44: [2, 7],
                47: [2, 7],
                48: [2, 7],
                51: [2, 7],
                55: [2, 7],
                60: [2, 7],
              },
              {
                5: [2, 8],
                14: [2, 8],
                15: [2, 8],
                19: [2, 8],
                29: [2, 8],
                34: [2, 8],
                39: [2, 8],
                44: [2, 8],
                47: [2, 8],
                48: [2, 8],
                51: [2, 8],
                55: [2, 8],
                60: [2, 8],
              },
              {
                5: [2, 9],
                14: [2, 9],
                15: [2, 9],
                19: [2, 9],
                29: [2, 9],
                34: [2, 9],
                39: [2, 9],
                44: [2, 9],
                47: [2, 9],
                48: [2, 9],
                51: [2, 9],
                55: [2, 9],
                60: [2, 9],
              },
              {
                20: 25,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 36,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                4: 37,
                6: 3,
                14: [2, 46],
                15: [2, 46],
                19: [2, 46],
                29: [2, 46],
                34: [2, 46],
                39: [2, 46],
                44: [2, 46],
                47: [2, 46],
                48: [2, 46],
                51: [2, 46],
                55: [2, 46],
                60: [2, 46],
              },
              {
                4: 38,
                6: 3,
                14: [2, 46],
                15: [2, 46],
                19: [2, 46],
                29: [2, 46],
                34: [2, 46],
                44: [2, 46],
                47: [2, 46],
                48: [2, 46],
                51: [2, 46],
                55: [2, 46],
                60: [2, 46],
              },
              { 13: 40, 15: [1, 20], 17: 39 },
              {
                20: 42,
                56: 41,
                64: 43,
                65: [1, 44],
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                4: 45,
                6: 3,
                14: [2, 46],
                15: [2, 46],
                19: [2, 46],
                29: [2, 46],
                34: [2, 46],
                47: [2, 46],
                48: [2, 46],
                51: [2, 46],
                55: [2, 46],
                60: [2, 46],
              },
              {
                5: [2, 10],
                14: [2, 10],
                15: [2, 10],
                18: [2, 10],
                19: [2, 10],
                29: [2, 10],
                34: [2, 10],
                39: [2, 10],
                44: [2, 10],
                47: [2, 10],
                48: [2, 10],
                51: [2, 10],
                55: [2, 10],
                60: [2, 10],
              },
              {
                20: 46,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 47,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 48,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 42,
                56: 49,
                64: 43,
                65: [1, 44],
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                33: [2, 78],
                49: 50,
                65: [2, 78],
                72: [2, 78],
                80: [2, 78],
                81: [2, 78],
                82: [2, 78],
                83: [2, 78],
                84: [2, 78],
                85: [2, 78],
              },
              {
                23: [2, 33],
                33: [2, 33],
                54: [2, 33],
                65: [2, 33],
                68: [2, 33],
                72: [2, 33],
                75: [2, 33],
                80: [2, 33],
                81: [2, 33],
                82: [2, 33],
                83: [2, 33],
                84: [2, 33],
                85: [2, 33],
              },
              {
                23: [2, 34],
                33: [2, 34],
                54: [2, 34],
                65: [2, 34],
                68: [2, 34],
                72: [2, 34],
                75: [2, 34],
                80: [2, 34],
                81: [2, 34],
                82: [2, 34],
                83: [2, 34],
                84: [2, 34],
                85: [2, 34],
              },
              {
                23: [2, 35],
                33: [2, 35],
                54: [2, 35],
                65: [2, 35],
                68: [2, 35],
                72: [2, 35],
                75: [2, 35],
                80: [2, 35],
                81: [2, 35],
                82: [2, 35],
                83: [2, 35],
                84: [2, 35],
                85: [2, 35],
              },
              {
                23: [2, 36],
                33: [2, 36],
                54: [2, 36],
                65: [2, 36],
                68: [2, 36],
                72: [2, 36],
                75: [2, 36],
                80: [2, 36],
                81: [2, 36],
                82: [2, 36],
                83: [2, 36],
                84: [2, 36],
                85: [2, 36],
              },
              {
                23: [2, 37],
                33: [2, 37],
                54: [2, 37],
                65: [2, 37],
                68: [2, 37],
                72: [2, 37],
                75: [2, 37],
                80: [2, 37],
                81: [2, 37],
                82: [2, 37],
                83: [2, 37],
                84: [2, 37],
                85: [2, 37],
              },
              {
                23: [2, 38],
                33: [2, 38],
                54: [2, 38],
                65: [2, 38],
                68: [2, 38],
                72: [2, 38],
                75: [2, 38],
                80: [2, 38],
                81: [2, 38],
                82: [2, 38],
                83: [2, 38],
                84: [2, 38],
                85: [2, 38],
              },
              {
                23: [2, 39],
                33: [2, 39],
                54: [2, 39],
                65: [2, 39],
                68: [2, 39],
                72: [2, 39],
                75: [2, 39],
                80: [2, 39],
                81: [2, 39],
                82: [2, 39],
                83: [2, 39],
                84: [2, 39],
                85: [2, 39],
              },
              {
                23: [2, 43],
                33: [2, 43],
                54: [2, 43],
                65: [2, 43],
                68: [2, 43],
                72: [2, 43],
                75: [2, 43],
                80: [2, 43],
                81: [2, 43],
                82: [2, 43],
                83: [2, 43],
                84: [2, 43],
                85: [2, 43],
                87: [1, 51],
              },
              { 72: [1, 35], 86: 52 },
              {
                23: [2, 45],
                33: [2, 45],
                54: [2, 45],
                65: [2, 45],
                68: [2, 45],
                72: [2, 45],
                75: [2, 45],
                80: [2, 45],
                81: [2, 45],
                82: [2, 45],
                83: [2, 45],
                84: [2, 45],
                85: [2, 45],
                87: [2, 45],
              },
              {
                52: 53,
                54: [2, 82],
                65: [2, 82],
                72: [2, 82],
                80: [2, 82],
                81: [2, 82],
                82: [2, 82],
                83: [2, 82],
                84: [2, 82],
                85: [2, 82],
              },
              {
                25: 54,
                38: 56,
                39: [1, 58],
                43: 57,
                44: [1, 59],
                45: 55,
                47: [2, 54],
              },
              { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] },
              { 13: 63, 15: [1, 20], 18: [1, 62] },
              { 15: [2, 48], 18: [2, 48] },
              {
                33: [2, 86],
                57: 64,
                65: [2, 86],
                72: [2, 86],
                80: [2, 86],
                81: [2, 86],
                82: [2, 86],
                83: [2, 86],
                84: [2, 86],
                85: [2, 86],
              },
              {
                33: [2, 40],
                65: [2, 40],
                72: [2, 40],
                80: [2, 40],
                81: [2, 40],
                82: [2, 40],
                83: [2, 40],
                84: [2, 40],
                85: [2, 40],
              },
              {
                33: [2, 41],
                65: [2, 41],
                72: [2, 41],
                80: [2, 41],
                81: [2, 41],
                82: [2, 41],
                83: [2, 41],
                84: [2, 41],
                85: [2, 41],
              },
              {
                20: 65,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              { 26: 66, 47: [1, 67] },
              {
                30: 68,
                33: [2, 58],
                65: [2, 58],
                72: [2, 58],
                75: [2, 58],
                80: [2, 58],
                81: [2, 58],
                82: [2, 58],
                83: [2, 58],
                84: [2, 58],
                85: [2, 58],
              },
              {
                33: [2, 64],
                35: 69,
                65: [2, 64],
                72: [2, 64],
                75: [2, 64],
                80: [2, 64],
                81: [2, 64],
                82: [2, 64],
                83: [2, 64],
                84: [2, 64],
                85: [2, 64],
              },
              {
                21: 70,
                23: [2, 50],
                65: [2, 50],
                72: [2, 50],
                80: [2, 50],
                81: [2, 50],
                82: [2, 50],
                83: [2, 50],
                84: [2, 50],
                85: [2, 50],
              },
              {
                33: [2, 90],
                61: 71,
                65: [2, 90],
                72: [2, 90],
                80: [2, 90],
                81: [2, 90],
                82: [2, 90],
                83: [2, 90],
                84: [2, 90],
                85: [2, 90],
              },
              {
                20: 75,
                33: [2, 80],
                50: 72,
                63: 73,
                64: 76,
                65: [1, 44],
                69: 74,
                70: 77,
                71: 78,
                72: [1, 79],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              { 72: [1, 80] },
              {
                23: [2, 42],
                33: [2, 42],
                54: [2, 42],
                65: [2, 42],
                68: [2, 42],
                72: [2, 42],
                75: [2, 42],
                80: [2, 42],
                81: [2, 42],
                82: [2, 42],
                83: [2, 42],
                84: [2, 42],
                85: [2, 42],
                87: [1, 51],
              },
              {
                20: 75,
                53: 81,
                54: [2, 84],
                63: 82,
                64: 76,
                65: [1, 44],
                69: 83,
                70: 77,
                71: 78,
                72: [1, 79],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              { 26: 84, 47: [1, 67] },
              { 47: [2, 55] },
              {
                4: 85,
                6: 3,
                14: [2, 46],
                15: [2, 46],
                19: [2, 46],
                29: [2, 46],
                34: [2, 46],
                39: [2, 46],
                44: [2, 46],
                47: [2, 46],
                48: [2, 46],
                51: [2, 46],
                55: [2, 46],
                60: [2, 46],
              },
              { 47: [2, 20] },
              {
                20: 86,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                4: 87,
                6: 3,
                14: [2, 46],
                15: [2, 46],
                19: [2, 46],
                29: [2, 46],
                34: [2, 46],
                47: [2, 46],
                48: [2, 46],
                51: [2, 46],
                55: [2, 46],
                60: [2, 46],
              },
              { 26: 88, 47: [1, 67] },
              { 47: [2, 57] },
              {
                5: [2, 11],
                14: [2, 11],
                15: [2, 11],
                19: [2, 11],
                29: [2, 11],
                34: [2, 11],
                39: [2, 11],
                44: [2, 11],
                47: [2, 11],
                48: [2, 11],
                51: [2, 11],
                55: [2, 11],
                60: [2, 11],
              },
              { 15: [2, 49], 18: [2, 49] },
              {
                20: 75,
                33: [2, 88],
                58: 89,
                63: 90,
                64: 76,
                65: [1, 44],
                69: 91,
                70: 77,
                71: 78,
                72: [1, 79],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                65: [2, 94],
                66: 92,
                68: [2, 94],
                72: [2, 94],
                80: [2, 94],
                81: [2, 94],
                82: [2, 94],
                83: [2, 94],
                84: [2, 94],
                85: [2, 94],
              },
              {
                5: [2, 25],
                14: [2, 25],
                15: [2, 25],
                19: [2, 25],
                29: [2, 25],
                34: [2, 25],
                39: [2, 25],
                44: [2, 25],
                47: [2, 25],
                48: [2, 25],
                51: [2, 25],
                55: [2, 25],
                60: [2, 25],
              },
              {
                20: 93,
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 75,
                31: 94,
                33: [2, 60],
                63: 95,
                64: 76,
                65: [1, 44],
                69: 96,
                70: 77,
                71: 78,
                72: [1, 79],
                75: [2, 60],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 75,
                33: [2, 66],
                36: 97,
                63: 98,
                64: 76,
                65: [1, 44],
                69: 99,
                70: 77,
                71: 78,
                72: [1, 79],
                75: [2, 66],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 75,
                22: 100,
                23: [2, 52],
                63: 101,
                64: 76,
                65: [1, 44],
                69: 102,
                70: 77,
                71: 78,
                72: [1, 79],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                20: 75,
                33: [2, 92],
                62: 103,
                63: 104,
                64: 76,
                65: [1, 44],
                69: 105,
                70: 77,
                71: 78,
                72: [1, 79],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              { 33: [1, 106] },
              {
                33: [2, 79],
                65: [2, 79],
                72: [2, 79],
                80: [2, 79],
                81: [2, 79],
                82: [2, 79],
                83: [2, 79],
                84: [2, 79],
                85: [2, 79],
              },
              { 33: [2, 81] },
              {
                23: [2, 27],
                33: [2, 27],
                54: [2, 27],
                65: [2, 27],
                68: [2, 27],
                72: [2, 27],
                75: [2, 27],
                80: [2, 27],
                81: [2, 27],
                82: [2, 27],
                83: [2, 27],
                84: [2, 27],
                85: [2, 27],
              },
              {
                23: [2, 28],
                33: [2, 28],
                54: [2, 28],
                65: [2, 28],
                68: [2, 28],
                72: [2, 28],
                75: [2, 28],
                80: [2, 28],
                81: [2, 28],
                82: [2, 28],
                83: [2, 28],
                84: [2, 28],
                85: [2, 28],
              },
              {
                23: [2, 30],
                33: [2, 30],
                54: [2, 30],
                68: [2, 30],
                71: 107,
                72: [1, 108],
                75: [2, 30],
              },
              {
                23: [2, 98],
                33: [2, 98],
                54: [2, 98],
                68: [2, 98],
                72: [2, 98],
                75: [2, 98],
              },
              {
                23: [2, 45],
                33: [2, 45],
                54: [2, 45],
                65: [2, 45],
                68: [2, 45],
                72: [2, 45],
                73: [1, 109],
                75: [2, 45],
                80: [2, 45],
                81: [2, 45],
                82: [2, 45],
                83: [2, 45],
                84: [2, 45],
                85: [2, 45],
                87: [2, 45],
              },
              {
                23: [2, 44],
                33: [2, 44],
                54: [2, 44],
                65: [2, 44],
                68: [2, 44],
                72: [2, 44],
                75: [2, 44],
                80: [2, 44],
                81: [2, 44],
                82: [2, 44],
                83: [2, 44],
                84: [2, 44],
                85: [2, 44],
                87: [2, 44],
              },
              { 54: [1, 110] },
              {
                54: [2, 83],
                65: [2, 83],
                72: [2, 83],
                80: [2, 83],
                81: [2, 83],
                82: [2, 83],
                83: [2, 83],
                84: [2, 83],
                85: [2, 83],
              },
              { 54: [2, 85] },
              {
                5: [2, 13],
                14: [2, 13],
                15: [2, 13],
                19: [2, 13],
                29: [2, 13],
                34: [2, 13],
                39: [2, 13],
                44: [2, 13],
                47: [2, 13],
                48: [2, 13],
                51: [2, 13],
                55: [2, 13],
                60: [2, 13],
              },
              {
                38: 56,
                39: [1, 58],
                43: 57,
                44: [1, 59],
                45: 112,
                46: 111,
                47: [2, 76],
              },
              {
                33: [2, 70],
                40: 113,
                65: [2, 70],
                72: [2, 70],
                75: [2, 70],
                80: [2, 70],
                81: [2, 70],
                82: [2, 70],
                83: [2, 70],
                84: [2, 70],
                85: [2, 70],
              },
              { 47: [2, 18] },
              {
                5: [2, 14],
                14: [2, 14],
                15: [2, 14],
                19: [2, 14],
                29: [2, 14],
                34: [2, 14],
                39: [2, 14],
                44: [2, 14],
                47: [2, 14],
                48: [2, 14],
                51: [2, 14],
                55: [2, 14],
                60: [2, 14],
              },
              { 33: [1, 114] },
              {
                33: [2, 87],
                65: [2, 87],
                72: [2, 87],
                80: [2, 87],
                81: [2, 87],
                82: [2, 87],
                83: [2, 87],
                84: [2, 87],
                85: [2, 87],
              },
              { 33: [2, 89] },
              {
                20: 75,
                63: 116,
                64: 76,
                65: [1, 44],
                67: 115,
                68: [2, 96],
                69: 117,
                70: 77,
                71: 78,
                72: [1, 79],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              { 33: [1, 118] },
              { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] },
              {
                33: [2, 59],
                65: [2, 59],
                72: [2, 59],
                75: [2, 59],
                80: [2, 59],
                81: [2, 59],
                82: [2, 59],
                83: [2, 59],
                84: [2, 59],
                85: [2, 59],
              },
              { 33: [2, 61], 75: [2, 61] },
              { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] },
              {
                33: [2, 65],
                65: [2, 65],
                72: [2, 65],
                75: [2, 65],
                80: [2, 65],
                81: [2, 65],
                82: [2, 65],
                83: [2, 65],
                84: [2, 65],
                85: [2, 65],
              },
              { 33: [2, 67], 75: [2, 67] },
              { 23: [1, 124] },
              {
                23: [2, 51],
                65: [2, 51],
                72: [2, 51],
                80: [2, 51],
                81: [2, 51],
                82: [2, 51],
                83: [2, 51],
                84: [2, 51],
                85: [2, 51],
              },
              { 23: [2, 53] },
              { 33: [1, 125] },
              {
                33: [2, 91],
                65: [2, 91],
                72: [2, 91],
                80: [2, 91],
                81: [2, 91],
                82: [2, 91],
                83: [2, 91],
                84: [2, 91],
                85: [2, 91],
              },
              { 33: [2, 93] },
              {
                5: [2, 22],
                14: [2, 22],
                15: [2, 22],
                19: [2, 22],
                29: [2, 22],
                34: [2, 22],
                39: [2, 22],
                44: [2, 22],
                47: [2, 22],
                48: [2, 22],
                51: [2, 22],
                55: [2, 22],
                60: [2, 22],
              },
              {
                23: [2, 99],
                33: [2, 99],
                54: [2, 99],
                68: [2, 99],
                72: [2, 99],
                75: [2, 99],
              },
              { 73: [1, 109] },
              {
                20: 75,
                63: 126,
                64: 76,
                65: [1, 44],
                72: [1, 35],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                5: [2, 23],
                14: [2, 23],
                15: [2, 23],
                19: [2, 23],
                29: [2, 23],
                34: [2, 23],
                39: [2, 23],
                44: [2, 23],
                47: [2, 23],
                48: [2, 23],
                51: [2, 23],
                55: [2, 23],
                60: [2, 23],
              },
              { 47: [2, 19] },
              { 47: [2, 77] },
              {
                20: 75,
                33: [2, 72],
                41: 127,
                63: 128,
                64: 76,
                65: [1, 44],
                69: 129,
                70: 77,
                71: 78,
                72: [1, 79],
                75: [2, 72],
                78: 26,
                79: 27,
                80: [1, 28],
                81: [1, 29],
                82: [1, 30],
                83: [1, 31],
                84: [1, 32],
                85: [1, 34],
                86: 33,
              },
              {
                5: [2, 24],
                14: [2, 24],
                15: [2, 24],
                19: [2, 24],
                29: [2, 24],
                34: [2, 24],
                39: [2, 24],
                44: [2, 24],
                47: [2, 24],
                48: [2, 24],
                51: [2, 24],
                55: [2, 24],
                60: [2, 24],
              },
              { 68: [1, 130] },
              {
                65: [2, 95],
                68: [2, 95],
                72: [2, 95],
                80: [2, 95],
                81: [2, 95],
                82: [2, 95],
                83: [2, 95],
                84: [2, 95],
                85: [2, 95],
              },
              { 68: [2, 97] },
              {
                5: [2, 21],
                14: [2, 21],
                15: [2, 21],
                19: [2, 21],
                29: [2, 21],
                34: [2, 21],
                39: [2, 21],
                44: [2, 21],
                47: [2, 21],
                48: [2, 21],
                51: [2, 21],
                55: [2, 21],
                60: [2, 21],
              },
              { 33: [1, 131] },
              { 33: [2, 63] },
              { 72: [1, 133], 76: 132 },
              { 33: [1, 134] },
              { 33: [2, 69] },
              { 15: [2, 12] },
              {
                14: [2, 26],
                15: [2, 26],
                19: [2, 26],
                29: [2, 26],
                34: [2, 26],
                47: [2, 26],
                48: [2, 26],
                51: [2, 26],
                55: [2, 26],
                60: [2, 26],
              },
              {
                23: [2, 31],
                33: [2, 31],
                54: [2, 31],
                68: [2, 31],
                72: [2, 31],
                75: [2, 31],
              },
              { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] },
              {
                33: [2, 71],
                65: [2, 71],
                72: [2, 71],
                75: [2, 71],
                80: [2, 71],
                81: [2, 71],
                82: [2, 71],
                83: [2, 71],
                84: [2, 71],
                85: [2, 71],
              },
              { 33: [2, 73], 75: [2, 73] },
              {
                23: [2, 29],
                33: [2, 29],
                54: [2, 29],
                65: [2, 29],
                68: [2, 29],
                72: [2, 29],
                75: [2, 29],
                80: [2, 29],
                81: [2, 29],
                82: [2, 29],
                83: [2, 29],
                84: [2, 29],
                85: [2, 29],
              },
              {
                14: [2, 15],
                15: [2, 15],
                19: [2, 15],
                29: [2, 15],
                34: [2, 15],
                39: [2, 15],
                44: [2, 15],
                47: [2, 15],
                48: [2, 15],
                51: [2, 15],
                55: [2, 15],
                60: [2, 15],
              },
              { 72: [1, 138], 77: [1, 137] },
              { 72: [2, 100], 77: [2, 100] },
              {
                14: [2, 16],
                15: [2, 16],
                19: [2, 16],
                29: [2, 16],
                34: [2, 16],
                44: [2, 16],
                47: [2, 16],
                48: [2, 16],
                51: [2, 16],
                55: [2, 16],
                60: [2, 16],
              },
              { 33: [1, 139] },
              { 33: [2, 75] },
              { 33: [2, 32] },
              { 72: [2, 101], 77: [2, 101] },
              {
                14: [2, 17],
                15: [2, 17],
                19: [2, 17],
                29: [2, 17],
                34: [2, 17],
                39: [2, 17],
                44: [2, 17],
                47: [2, 17],
                48: [2, 17],
                51: [2, 17],
                55: [2, 17],
                60: [2, 17],
              },
            ],
            defaultActions: {
              4: [2, 1],
              55: [2, 55],
              57: [2, 20],
              61: [2, 57],
              74: [2, 81],
              83: [2, 85],
              87: [2, 18],
              91: [2, 89],
              102: [2, 53],
              105: [2, 93],
              111: [2, 19],
              112: [2, 77],
              117: [2, 97],
              120: [2, 63],
              123: [2, 69],
              124: [2, 12],
              136: [2, 75],
              137: [2, 32],
            },
            parseError: function (a, b) {
              throw new Error(a);
            },
            parse: function (a) {
              function b() {
                var a;
                return (
                  (a = c.lexer.lex() || 1),
                  "number" != typeof a && (a = c.symbols_[a] || a),
                  a
                );
              }
              var c = this,
                d = [0],
                e = [null],
                f = [],
                g = this.table,
                h = "",
                i = 0,
                j = 0,
                k = 0;
              this.lexer.setInput(a),
                (this.lexer.yy = this.yy),
                (this.yy.lexer = this.lexer),
                (this.yy.parser = this),
                "undefined" == typeof this.lexer.yylloc &&
                  (this.lexer.yylloc = {});
              var l = this.lexer.yylloc;
              f.push(l);
              var m = this.lexer.options && this.lexer.options.ranges;
              "function" == typeof this.yy.parseError &&
                (this.parseError = this.yy.parseError);
              for (var n, o, p, q, r, s, t, u, v, w = {}; ; ) {
                if (
                  ((p = d[d.length - 1]),
                  this.defaultActions[p]
                    ? (q = this.defaultActions[p])
                    : ((null === n || "undefined" == typeof n) && (n = b()),
                      (q = g[p] && g[p][n])),
                  "undefined" == typeof q || !q.length || !q[0])
                ) {
                  var x = "";
                  if (!k) {
                    v = [];
                    for (s in g[p])
                      this.terminals_[s] &&
                        s > 2 &&
                        v.push("'" + this.terminals_[s] + "'");
                    (x = this.lexer.showPosition
                      ? "Parse error on line " +
                        (i + 1) +
                        ":\n" +
                        this.lexer.showPosition() +
                        "\nExpecting " +
                        v.join(", ") +
                        ", got '" +
                        (this.terminals_[n] || n) +
                        "'"
                      : "Parse error on line " +
                        (i + 1) +
                        ": Unexpected " +
                        (1 == n
                          ? "end of input"
                          : "'" + (this.terminals_[n] || n) + "'")),
                      this.parseError(x, {
                        text: this.lexer.match,
                        token: this.terminals_[n] || n,
                        line: this.lexer.yylineno,
                        loc: l,
                        expected: v,
                      });
                  }
                }
                if (q[0] instanceof Array && q.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      p +
                      ", token: " +
                      n
                  );
                switch (q[0]) {
                  case 1:
                    d.push(n),
                      e.push(this.lexer.yytext),
                      f.push(this.lexer.yylloc),
                      d.push(q[1]),
                      (n = null),
                      o
                        ? ((n = o), (o = null))
                        : ((j = this.lexer.yyleng),
                          (h = this.lexer.yytext),
                          (i = this.lexer.yylineno),
                          (l = this.lexer.yylloc),
                          k > 0 && k--);
                    break;
                  case 2:
                    if (
                      ((t = this.productions_[q[1]][1]),
                      (w.$ = e[e.length - t]),
                      (w._$ = {
                        first_line: f[f.length - (t || 1)].first_line,
                        last_line: f[f.length - 1].last_line,
                        first_column: f[f.length - (t || 1)].first_column,
                        last_column: f[f.length - 1].last_column,
                      }),
                      m &&
                        (w._$.range = [
                          f[f.length - (t || 1)].range[0],
                          f[f.length - 1].range[1],
                        ]),
                      (r = this.performAction.call(
                        w,
                        h,
                        j,
                        i,
                        this.yy,
                        q[1],
                        e,
                        f
                      )),
                      "undefined" != typeof r)
                    )
                      return r;
                    t &&
                      ((d = d.slice(0, -1 * t * 2)),
                      (e = e.slice(0, -1 * t)),
                      (f = f.slice(0, -1 * t))),
                      d.push(this.productions_[q[1]][0]),
                      e.push(w.$),
                      f.push(w._$),
                      (u = g[d[d.length - 2]][d[d.length - 1]]),
                      d.push(u);
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            },
          },
          c = (function () {
            var a = {
              EOF: 1,
              parseError: function (a, b) {
                if (!this.yy.parser) throw new Error(a);
                this.yy.parser.parseError(a, b);
              },
              setInput: function (a) {
                return (
                  (this._input = a),
                  (this._more = this._less = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              },
              input: function () {
                var a = this._input[0];
                (this.yytext += a),
                  this.yyleng++,
                  this.offset++,
                  (this.match += a),
                  (this.matched += a);
                var b = a.match(/(?:\r\n?|\n).*/g);
                return (
                  b
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  a
                );
              },
              unput: function (a) {
                var b = a.length,
                  c = a.split(/(?:\r\n?|\n)/g);
                (this._input = a + this._input),
                  (this.yytext = this.yytext.substr(
                    0,
                    this.yytext.length - b - 1
                  )),
                  (this.offset -= b);
                var d = this.match.split(/(?:\r\n?|\n)/g);
                (this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1
                  )),
                  c.length - 1 && (this.yylineno -= c.length - 1);
                var e = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: c
                      ? (c.length === d.length ? this.yylloc.first_column : 0) +
                        d[d.length - c.length].length -
                        c[0].length
                      : this.yylloc.first_column - b,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [e[0], e[0] + this.yyleng - b]),
                  this
                );
              },
              more: function () {
                return (this._more = !0), this;
              },
              less: function (a) {
                this.unput(this.match.slice(a));
              },
              pastInput: function () {
                var a = this.matched.substr(
                  0,
                  this.matched.length - this.match.length
                );
                return (
                  (a.length > 20 ? "..." : "") +
                  a.substr(-20).replace(/\n/g, "")
                );
              },
              upcomingInput: function () {
                var a = this.match;
                return (
                  a.length < 20 && (a += this._input.substr(0, 20 - a.length)),
                  (a.substr(0, 20) + (a.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    ""
                  )
                );
              },
              showPosition: function () {
                var a = this.pastInput(),
                  b = new Array(a.length + 1).join("-");
                return a + this.upcomingInput() + "\n" + b + "^";
              },
              next: function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var a, b, c, d, e;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (
                  var f = this._currentRules(), g = 0;
                  g < f.length &&
                  ((c = this._input.match(this.rules[f[g]])),
                  !c ||
                    (b && !(c[0].length > b[0].length)) ||
                    ((b = c), (d = g), this.options.flex));
                  g++
                );
                return b
                  ? ((e = b[0].match(/(?:\r\n?|\n).*/g)),
                    e && (this.yylineno += e.length),
                    (this.yylloc = {
                      first_line: this.yylloc.last_line,
                      last_line: this.yylineno + 1,
                      first_column: this.yylloc.last_column,
                      last_column: e
                        ? e[e.length - 1].length -
                          e[e.length - 1].match(/\r?\n?/)[0].length
                        : this.yylloc.last_column + b[0].length,
                    }),
                    (this.yytext += b[0]),
                    (this.match += b[0]),
                    (this.matches = b),
                    (this.yyleng = this.yytext.length),
                    this.options.ranges &&
                      (this.yylloc.range = [
                        this.offset,
                        (this.offset += this.yyleng),
                      ]),
                    (this._more = !1),
                    (this._input = this._input.slice(b[0].length)),
                    (this.matched += b[0]),
                    (a = this.performAction.call(
                      this,
                      this.yy,
                      this,
                      f[d],
                      this.conditionStack[this.conditionStack.length - 1]
                    )),
                    this.done && this._input && (this.done = !1),
                    a ? a : void 0)
                  : "" === this._input
                  ? this.EOF
                  : this.parseError(
                      "Lexical error on line " +
                        (this.yylineno + 1) +
                        ". Unrecognized text.\n" +
                        this.showPosition(),
                      { text: "", token: null, line: this.yylineno }
                    );
              },
              lex: function () {
                var a = this.next();
                return "undefined" != typeof a ? a : this.lex();
              },
              begin: function (a) {
                this.conditionStack.push(a);
              },
              popState: function () {
                return this.conditionStack.pop();
              },
              _currentRules: function () {
                return this.conditions[
                  this.conditionStack[this.conditionStack.length - 1]
                ].rules;
              },
              topState: function () {
                return this.conditionStack[this.conditionStack.length - 2];
              },
              pushState: function (a) {
                this.begin(a);
              },
            };
            return (
              (a.options = {}),
              (a.performAction = function (a, b, c, d) {
                function e(a, c) {
                  return (b.yytext = b.yytext.substr(a, b.yyleng - c));
                }
                switch (c) {
                  case 0:
                    if (
                      ("\\\\" === b.yytext.slice(-2)
                        ? (e(0, 1), this.begin("mu"))
                        : "\\" === b.yytext.slice(-1)
                        ? (e(0, 1), this.begin("emu"))
                        : this.begin("mu"),
                      b.yytext)
                    )
                      return 15;
                    break;
                  case 1:
                    return 15;
                  case 2:
                    return this.popState(), 15;
                  case 3:
                    return this.begin("raw"), 15;
                  case 4:
                    return (
                      this.popState(),
                      "raw" ===
                      this.conditionStack[this.conditionStack.length - 1]
                        ? 15
                        : ((b.yytext = b.yytext.substr(5, b.yyleng - 9)),
                          "END_RAW_BLOCK")
                    );
                  case 5:
                    return 15;
                  case 6:
                    return this.popState(), 14;
                  case 7:
                    return 65;
                  case 8:
                    return 68;
                  case 9:
                    return 19;
                  case 10:
                    return this.popState(), this.begin("raw"), 23;
                  case 11:
                    return 55;
                  case 12:
                    return 60;
                  case 13:
                    return 29;
                  case 14:
                    return 47;
                  case 15:
                    return this.popState(), 44;
                  case 16:
                    return this.popState(), 44;
                  case 17:
                    return 34;
                  case 18:
                    return 39;
                  case 19:
                    return 51;
                  case 20:
                    return 48;
                  case 21:
                    this.unput(b.yytext), this.popState(), this.begin("com");
                    break;
                  case 22:
                    return this.popState(), 14;
                  case 23:
                    return 48;
                  case 24:
                    return 73;
                  case 25:
                    return 72;
                  case 26:
                    return 72;
                  case 27:
                    return 87;
                  case 28:
                    break;
                  case 29:
                    return this.popState(), 54;
                  case 30:
                    return this.popState(), 33;
                  case 31:
                    return (b.yytext = e(1, 2).replace(/\\"/g, '"')), 80;
                  case 32:
                    return (b.yytext = e(1, 2).replace(/\\'/g, "'")), 80;
                  case 33:
                    return 85;
                  case 34:
                    return 82;
                  case 35:
                    return 82;
                  case 36:
                    return 83;
                  case 37:
                    return 84;
                  case 38:
                    return 81;
                  case 39:
                    return 75;
                  case 40:
                    return 77;
                  case 41:
                    return 72;
                  case 42:
                    return (
                      (b.yytext = b.yytext.replace(/\\([\\\]])/g, "$1")), 72
                    );
                  case 43:
                    return "INVALID";
                  case 44:
                    return 5;
                }
              }),
              (a.rules = [
                /^(?:[^\x00]*?(?=(\{\{)))/,
                /^(?:[^\x00]+)/,
                /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/,
                /^(?:\{\{\{\{(?=[^\/]))/,
                /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/,
                /^(?:[^\x00]*?(?=(\{\{\{\{)))/,
                /^(?:[\s\S]*?--(~)?\}\})/,
                /^(?:\()/,
                /^(?:\))/,
                /^(?:\{\{\{\{)/,
                /^(?:\}\}\}\})/,
                /^(?:\{\{(~)?>)/,
                /^(?:\{\{(~)?#>)/,
                /^(?:\{\{(~)?#\*?)/,
                /^(?:\{\{(~)?\/)/,
                /^(?:\{\{(~)?\^\s*(~)?\}\})/,
                /^(?:\{\{(~)?\s*else\s*(~)?\}\})/,
                /^(?:\{\{(~)?\^)/,
                /^(?:\{\{(~)?\s*else\b)/,
                /^(?:\{\{(~)?\{)/,
                /^(?:\{\{(~)?&)/,
                /^(?:\{\{(~)?!--)/,
                /^(?:\{\{(~)?![\s\S]*?\}\})/,
                /^(?:\{\{(~)?\*?)/,
                /^(?:=)/,
                /^(?:\.\.)/,
                /^(?:\.(?=([=~}\s\/.)|])))/,
                /^(?:[\/.])/,
                /^(?:\s+)/,
                /^(?:\}(~)?\}\})/,
                /^(?:(~)?\}\})/,
                /^(?:"(\\["]|[^"])*")/,
                /^(?:'(\\[']|[^'])*')/,
                /^(?:@)/,
                /^(?:true(?=([~}\s)])))/,
                /^(?:false(?=([~}\s)])))/,
                /^(?:undefined(?=([~}\s)])))/,
                /^(?:null(?=([~}\s)])))/,
                /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/,
                /^(?:as\s+\|)/,
                /^(?:\|)/,
                /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/,
                /^(?:\[(\\\]|[^\]])*\])/,
                /^(?:.)/,
                /^(?:$)/,
              ]),
              (a.conditions = {
                mu: {
                  rules: [
                    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
                    23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
                    38, 39, 40, 41, 42, 43, 44,
                  ],
                  inclusive: !1,
                },
                emu: { rules: [2], inclusive: !1 },
                com: { rules: [6], inclusive: !1 },
                raw: { rules: [3, 4, 5], inclusive: !1 },
                INITIAL: { rules: [0, 1, 44], inclusive: !0 },
              }),
              a
            );
          })();
        return (b.lexer = c), (a.prototype = b), (b.Parser = a), new a();
      })();
      (b.__esModule = !0), (b["default"] = c);
    },
    function (a, b, c) {
      "use strict";
      function d() {
        var a =
          arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];
        this.options = a;
      }
      function e(a, b, c) {
        void 0 === b && (b = a.length);
        var d = a[b - 1],
          e = a[b - 2];
        return d
          ? "ContentStatement" === d.type
            ? (e || !c ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(d.original)
            : void 0
          : c;
      }
      function f(a, b, c) {
        void 0 === b && (b = -1);
        var d = a[b + 1],
          e = a[b + 2];
        return d
          ? "ContentStatement" === d.type
            ? (e || !c ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(d.original)
            : void 0
          : c;
      }
      function g(a, b, c) {
        var d = a[null == b ? 0 : b + 1];
        if (d && "ContentStatement" === d.type && (c || !d.rightStripped)) {
          var e = d.value;
          (d.value = d.value.replace(c ? /^\s+/ : /^[ \t]*\r?\n?/, "")),
            (d.rightStripped = d.value !== e);
        }
      }
      function h(a, b, c) {
        var d = a[null == b ? a.length - 1 : b - 1];
        if (d && "ContentStatement" === d.type && (c || !d.leftStripped)) {
          var e = d.value;
          return (
            (d.value = d.value.replace(c ? /\s+$/ : /[ \t]+$/, "")),
            (d.leftStripped = d.value !== e),
            d.leftStripped
          );
        }
      }
      var i = c(1)["default"];
      b.__esModule = !0;
      var j = c(25),
        k = i(j);
      (d.prototype = new k["default"]()),
        (d.prototype.Program = function (a) {
          var b = !this.options.ignoreStandalone,
            c = !this.isRootSeen;
          this.isRootSeen = !0;
          for (var d = a.body, i = 0, j = d.length; j > i; i++) {
            var k = d[i],
              l = this.accept(k);
            if (l) {
              var m = e(d, i, c),
                n = f(d, i, c),
                o = l.openStandalone && m,
                p = l.closeStandalone && n,
                q = l.inlineStandalone && m && n;
              l.close && g(d, i, !0),
                l.open && h(d, i, !0),
                b &&
                  q &&
                  (g(d, i),
                  h(d, i) &&
                    "PartialStatement" === k.type &&
                    (k.indent = /([ \t]+$)/.exec(d[i - 1].original)[1])),
                b && o && (g((k.program || k.inverse).body), h(d, i)),
                b && p && (g(d, i), h((k.inverse || k.program).body));
            }
          }
          return a;
        }),
        (d.prototype.BlockStatement =
          d.prototype.DecoratorBlock =
          d.prototype.PartialBlockStatement =
            function (a) {
              this.accept(a.program), this.accept(a.inverse);
              var b = a.program || a.inverse,
                c = a.program && a.inverse,
                d = c,
                i = c;
              if (c && c.chained)
                for (d = c.body[0].program; i.chained; )
                  i = i.body[i.body.length - 1].program;
              var j = {
                open: a.openStrip.open,
                close: a.closeStrip.close,
                openStandalone: f(b.body),
                closeStandalone: e((d || b).body),
              };
              if ((a.openStrip.close && g(b.body, null, !0), c)) {
                var k = a.inverseStrip;
                k.open && h(b.body, null, !0),
                  k.close && g(d.body, null, !0),
                  a.closeStrip.open && h(i.body, null, !0),
                  !this.options.ignoreStandalone &&
                    e(b.body) &&
                    f(d.body) &&
                    (h(b.body), g(d.body));
              } else a.closeStrip.open && h(b.body, null, !0);
              return j;
            }),
        (d.prototype.Decorator = d.prototype.MustacheStatement =
          function (a) {
            return a.strip;
          }),
        (d.prototype.PartialStatement = d.prototype.CommentStatement =
          function (a) {
            var b = a.strip || {};
            return { inlineStandalone: !0, open: b.open, close: b.close };
          }),
        (b["default"] = d),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      function d() {
        this.parents = [];
      }
      function e(a) {
        this.acceptRequired(a, "path"),
          this.acceptArray(a.params),
          this.acceptKey(a, "hash");
      }
      function f(a) {
        e.call(this, a),
          this.acceptKey(a, "program"),
          this.acceptKey(a, "inverse");
      }
      function g(a) {
        this.acceptRequired(a, "name"),
          this.acceptArray(a.params),
          this.acceptKey(a, "hash");
      }
      var h = c(1)["default"];
      b.__esModule = !0;
      var i = c(6),
        j = h(i);
      (d.prototype = {
        constructor: d,
        mutating: !1,
        acceptKey: function (a, b) {
          var c = this.accept(a[b]);
          if (this.mutating) {
            if (c && !d.prototype[c.type])
              throw new j["default"](
                'Unexpected node type "' +
                  c.type +
                  '" found when accepting ' +
                  b +
                  " on " +
                  a.type
              );
            a[b] = c;
          }
        },
        acceptRequired: function (a, b) {
          if ((this.acceptKey(a, b), !a[b]))
            throw new j["default"](a.type + " requires " + b);
        },
        acceptArray: function (a) {
          for (var b = 0, c = a.length; c > b; b++)
            this.acceptKey(a, b), a[b] || (a.splice(b, 1), b--, c--);
        },
        accept: function (a) {
          if (a) {
            if (!this[a.type])
              throw new j["default"]("Unknown type: " + a.type, a);
            this.current && this.parents.unshift(this.current),
              (this.current = a);
            var b = this[a.type](a);
            return (
              (this.current = this.parents.shift()),
              !this.mutating || b ? b : b !== !1 ? a : void 0
            );
          }
        },
        Program: function (a) {
          this.acceptArray(a.body);
        },
        MustacheStatement: e,
        Decorator: e,
        BlockStatement: f,
        DecoratorBlock: f,
        PartialStatement: g,
        PartialBlockStatement: function (a) {
          g.call(this, a), this.acceptKey(a, "program");
        },
        ContentStatement: function () {},
        CommentStatement: function () {},
        SubExpression: e,
        PathExpression: function () {},
        StringLiteral: function () {},
        NumberLiteral: function () {},
        BooleanLiteral: function () {},
        UndefinedLiteral: function () {},
        NullLiteral: function () {},
        Hash: function (a) {
          this.acceptArray(a.pairs);
        },
        HashPair: function (a) {
          this.acceptRequired(a, "value");
        },
      }),
        (b["default"] = d),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      function d(a, b) {
        if (((b = b.path ? b.path.original : b), a.path.original !== b)) {
          var c = { loc: a.path.loc };
          throw new q["default"](a.path.original + " doesn't match " + b, c);
        }
      }
      function e(a, b) {
        (this.source = a),
          (this.start = { line: b.first_line, column: b.first_column }),
          (this.end = { line: b.last_line, column: b.last_column });
      }
      function f(a) {
        return /^\[.*\]$/.test(a) ? a.substr(1, a.length - 2) : a;
      }
      function g(a, b) {
        return {
          open: "~" === a.charAt(2),
          close: "~" === b.charAt(b.length - 3),
        };
      }
      function h(a) {
        return a.replace(/^\{\{~?\!-?-?/, "").replace(/-?-?~?\}\}$/, "");
      }
      function i(a, b, c) {
        c = this.locInfo(c);
        for (
          var d = a ? "@" : "", e = [], f = 0, g = "", h = 0, i = b.length;
          i > h;
          h++
        ) {
          var j = b[h].part,
            k = b[h].original !== j;
          if (
            ((d += (b[h].separator || "") + j),
            k || (".." !== j && "." !== j && "this" !== j))
          )
            e.push(j);
          else {
            if (e.length > 0)
              throw new q["default"]("Invalid path: " + d, { loc: c });
            ".." === j && (f++, (g += "../"));
          }
        }
        return {
          type: "PathExpression",
          data: a,
          depth: f,
          parts: e,
          original: d,
          loc: c,
        };
      }
      function j(a, b, c, d, e, f) {
        var g = d.charAt(3) || d.charAt(2),
          h = "{" !== g && "&" !== g,
          i = /\*/.test(d);
        return {
          type: i ? "Decorator" : "MustacheStatement",
          path: a,
          params: b,
          hash: c,
          escaped: h,
          strip: e,
          loc: this.locInfo(f),
        };
      }
      function k(a, b, c, e) {
        d(a, c), (e = this.locInfo(e));
        var f = { type: "Program", body: b, strip: {}, loc: e };
        return {
          type: "BlockStatement",
          path: a.path,
          params: a.params,
          hash: a.hash,
          program: f,
          openStrip: {},
          inverseStrip: {},
          closeStrip: {},
          loc: e,
        };
      }
      function l(a, b, c, e, f, g) {
        e && e.path && d(a, e);
        var h = /\*/.test(a.open);
        b.blockParams = a.blockParams;
        var i = void 0,
          j = void 0;
        if (c) {
          if (h)
            throw new q["default"]("Unexpected inverse block on decorator", c);
          c.chain && (c.program.body[0].closeStrip = e.strip),
            (j = c.strip),
            (i = c.program);
        }
        return (
          f && ((f = i), (i = b), (b = f)),
          {
            type: h ? "DecoratorBlock" : "BlockStatement",
            path: a.path,
            params: a.params,
            hash: a.hash,
            program: b,
            inverse: i,
            openStrip: a.strip,
            inverseStrip: j,
            closeStrip: e && e.strip,
            loc: this.locInfo(g),
          }
        );
      }
      function m(a, b) {
        if (!b && a.length) {
          var c = a[0].loc,
            d = a[a.length - 1].loc;
          c &&
            d &&
            (b = {
              source: c.source,
              start: { line: c.start.line, column: c.start.column },
              end: { line: d.end.line, column: d.end.column },
            });
        }
        return { type: "Program", body: a, strip: {}, loc: b };
      }
      function n(a, b, c, e) {
        return (
          d(a, c),
          {
            type: "PartialBlockStatement",
            name: a.path,
            params: a.params,
            hash: a.hash,
            program: b,
            openStrip: a.strip,
            closeStrip: c && c.strip,
            loc: this.locInfo(e),
          }
        );
      }
      var o = c(1)["default"];
      (b.__esModule = !0),
        (b.SourceLocation = e),
        (b.id = f),
        (b.stripFlags = g),
        (b.stripComment = h),
        (b.preparePath = i),
        (b.prepareMustache = j),
        (b.prepareRawBlock = k),
        (b.prepareBlock = l),
        (b.prepareProgram = m),
        (b.preparePartialBlock = n);
      var p = c(6),
        q = o(p);
    },
    function (a, b, c) {
      "use strict";
      function d() {}
      function e(a, b, c) {
        if (null == a || ("string" != typeof a && "Program" !== a.type))
          throw new k["default"](
            "You must pass a string or Handlebars AST to Handlebars.precompile. You passed " +
              a
          );
        (b = b || {}),
          "data" in b || (b.data = !0),
          b.compat && (b.useDepths = !0);
        var d = c.parse(a, b),
          e = new c.Compiler().compile(d, b);
        return new c.JavaScriptCompiler().compile(e, b);
      }
      function f(a, b, c) {
        function d() {
          var d = c.parse(a, b),
            e = new c.Compiler().compile(d, b),
            f = new c.JavaScriptCompiler().compile(e, b, void 0, !0);
          return c.template(f);
        }
        function e(a, b) {
          return f || (f = d()), f.call(this, a, b);
        }
        if (
          (void 0 === b && (b = {}),
          null == a || ("string" != typeof a && "Program" !== a.type))
        )
          throw new k["default"](
            "You must pass a string or Handlebars AST to Handlebars.compile. You passed " +
              a
          );
        "data" in b || (b.data = !0), b.compat && (b.useDepths = !0);
        var f = void 0;
        return (
          (e._setup = function (a) {
            return f || (f = d()), f._setup(a);
          }),
          (e._child = function (a, b, c, e) {
            return f || (f = d()), f._child(a, b, c, e);
          }),
          e
        );
      }
      function g(a, b) {
        if (a === b) return !0;
        if (l.isArray(a) && l.isArray(b) && a.length === b.length) {
          for (var c = 0; c < a.length; c++) if (!g(a[c], b[c])) return !1;
          return !0;
        }
      }
      function h(a) {
        if (!a.path.parts) {
          var b = a.path;
          a.path = {
            type: "PathExpression",
            data: !1,
            depth: 0,
            parts: [b.original + ""],
            original: b.original + "",
            loc: b.loc,
          };
        }
      }
      var i = c(1)["default"];
      (b.__esModule = !0),
        (b.Compiler = d),
        (b.precompile = e),
        (b.compile = f);
      var j = c(6),
        k = i(j),
        l = c(5),
        m = c(21),
        n = i(m),
        o = [].slice;
      d.prototype = {
        compiler: d,
        equals: function (a) {
          var b = this.opcodes.length;
          if (a.opcodes.length !== b) return !1;
          for (var c = 0; b > c; c++) {
            var d = this.opcodes[c],
              e = a.opcodes[c];
            if (d.opcode !== e.opcode || !g(d.args, e.args)) return !1;
          }
          b = this.children.length;
          for (var c = 0; b > c; c++)
            if (!this.children[c].equals(a.children[c])) return !1;
          return !0;
        },
        guid: 0,
        compile: function (a, b) {
          (this.sourceNode = []),
            (this.opcodes = []),
            (this.children = []),
            (this.options = b),
            (this.stringParams = b.stringParams),
            (this.trackIds = b.trackIds),
            (b.blockParams = b.blockParams || []);
          var c = b.knownHelpers;
          if (
            ((b.knownHelpers = {
              helperMissing: !0,
              blockHelperMissing: !0,
              each: !0,
              if: !0,
              unless: !0,
              with: !0,
              log: !0,
              lookup: !0,
            }),
            c)
          )
            for (var d in c) d in c && (b.knownHelpers[d] = c[d]);
          return this.accept(a);
        },
        compileProgram: function (a) {
          var b = new this.compiler(),
            c = b.compile(a, this.options),
            d = this.guid++;
          return (
            (this.usePartial = this.usePartial || c.usePartial),
            (this.children[d] = c),
            (this.useDepths = this.useDepths || c.useDepths),
            d
          );
        },
        accept: function (a) {
          if (!this[a.type])
            throw new k["default"]("Unknown type: " + a.type, a);
          this.sourceNode.unshift(a);
          var b = this[a.type](a);
          return this.sourceNode.shift(), b;
        },
        Program: function (a) {
          this.options.blockParams.unshift(a.blockParams);
          for (var b = a.body, c = b.length, d = 0; c > d; d++)
            this.accept(b[d]);
          return (
            this.options.blockParams.shift(),
            (this.isSimple = 1 === c),
            (this.blockParams = a.blockParams ? a.blockParams.length : 0),
            this
          );
        },
        BlockStatement: function (a) {
          h(a);
          var b = a.program,
            c = a.inverse;
          (b = b && this.compileProgram(b)), (c = c && this.compileProgram(c));
          var d = this.classifySexpr(a);
          "helper" === d
            ? this.helperSexpr(a, b, c)
            : "simple" === d
            ? (this.simpleSexpr(a),
              this.opcode("pushProgram", b),
              this.opcode("pushProgram", c),
              this.opcode("emptyHash"),
              this.opcode("blockValue", a.path.original))
            : (this.ambiguousSexpr(a, b, c),
              this.opcode("pushProgram", b),
              this.opcode("pushProgram", c),
              this.opcode("emptyHash"),
              this.opcode("ambiguousBlockValue")),
            this.opcode("append");
        },
        DecoratorBlock: function (a) {
          var b = a.program && this.compileProgram(a.program),
            c = this.setupFullMustacheParams(a, b, void 0),
            d = a.path;
          (this.useDecorators = !0),
            this.opcode("registerDecorator", c.length, d.original);
        },
        PartialStatement: function (a) {
          this.usePartial = !0;
          var b = a.program;
          b && (b = this.compileProgram(a.program));
          var c = a.params;
          if (c.length > 1)
            throw new k["default"](
              "Unsupported number of partial arguments: " + c.length,
              a
            );
          c.length ||
            (this.options.explicitPartialContext
              ? this.opcode("pushLiteral", "undefined")
              : c.push({ type: "PathExpression", parts: [], depth: 0 }));
          var d = a.name.original,
            e = "SubExpression" === a.name.type;
          e && this.accept(a.name),
            this.setupFullMustacheParams(a, b, void 0, !0);
          var f = a.indent || "";
          this.options.preventIndent &&
            f &&
            (this.opcode("appendContent", f), (f = "")),
            this.opcode("invokePartial", e, d, f),
            this.opcode("append");
        },
        PartialBlockStatement: function (a) {
          this.PartialStatement(a);
        },
        MustacheStatement: function (a) {
          this.SubExpression(a),
            a.escaped && !this.options.noEscape
              ? this.opcode("appendEscaped")
              : this.opcode("append");
        },
        Decorator: function (a) {
          this.DecoratorBlock(a);
        },
        ContentStatement: function (a) {
          a.value && this.opcode("appendContent", a.value);
        },
        CommentStatement: function () {},
        SubExpression: function (a) {
          h(a);
          var b = this.classifySexpr(a);
          "simple" === b
            ? this.simpleSexpr(a)
            : "helper" === b
            ? this.helperSexpr(a)
            : this.ambiguousSexpr(a);
        },
        ambiguousSexpr: function (a, b, c) {
          var d = a.path,
            e = d.parts[0],
            f = null != b || null != c;
          this.opcode("getContext", d.depth),
            this.opcode("pushProgram", b),
            this.opcode("pushProgram", c),
            (d.strict = !0),
            this.accept(d),
            this.opcode("invokeAmbiguous", e, f);
        },
        simpleSexpr: function (a) {
          var b = a.path;
          (b.strict = !0), this.accept(b), this.opcode("resolvePossibleLambda");
        },
        helperSexpr: function (a, b, c) {
          var d = this.setupFullMustacheParams(a, b, c),
            e = a.path,
            f = e.parts[0];
          if (this.options.knownHelpers[f])
            this.opcode("invokeKnownHelper", d.length, f);
          else {
            if (this.options.knownHelpersOnly)
              throw new k["default"](
                "You specified knownHelpersOnly, but used the unknown helper " +
                  f,
                a
              );
            (e.strict = !0),
              (e.falsy = !0),
              this.accept(e),
              this.opcode(
                "invokeHelper",
                d.length,
                e.original,
                n["default"].helpers.simpleId(e)
              );
          }
        },
        PathExpression: function (a) {
          this.addDepth(a.depth), this.opcode("getContext", a.depth);
          var b = a.parts[0],
            c = n["default"].helpers.scopedId(a),
            d = !a.depth && !c && this.blockParamIndex(b);
          d
            ? this.opcode("lookupBlockParam", d, a.parts)
            : b
            ? a.data
              ? ((this.options.data = !0),
                this.opcode("lookupData", a.depth, a.parts, a.strict))
              : this.opcode("lookupOnContext", a.parts, a.falsy, a.strict, c)
            : this.opcode("pushContext");
        },
        StringLiteral: function (a) {
          this.opcode("pushString", a.value);
        },
        NumberLiteral: function (a) {
          this.opcode("pushLiteral", a.value);
        },
        BooleanLiteral: function (a) {
          this.opcode("pushLiteral", a.value);
        },
        UndefinedLiteral: function () {
          this.opcode("pushLiteral", "undefined");
        },
        NullLiteral: function () {
          this.opcode("pushLiteral", "null");
        },
        Hash: function (a) {
          var b = a.pairs,
            c = 0,
            d = b.length;
          for (this.opcode("pushHash"); d > c; c++) this.pushParam(b[c].value);
          for (; c--; ) this.opcode("assignToHash", b[c].key);
          this.opcode("popHash");
        },
        opcode: function (a) {
          this.opcodes.push({
            opcode: a,
            args: o.call(arguments, 1),
            loc: this.sourceNode[0].loc,
          });
        },
        addDepth: function (a) {
          a && (this.useDepths = !0);
        },
        classifySexpr: function (a) {
          var b = n["default"].helpers.simpleId(a.path),
            c = b && !!this.blockParamIndex(a.path.parts[0]),
            d = !c && n["default"].helpers.helperExpression(a),
            e = !c && (d || b);
          if (e && !d) {
            var f = a.path.parts[0],
              g = this.options;
            g.knownHelpers[f] ? (d = !0) : g.knownHelpersOnly && (e = !1);
          }
          return d ? "helper" : e ? "ambiguous" : "simple";
        },
        pushParams: function (a) {
          for (var b = 0, c = a.length; c > b; b++) this.pushParam(a[b]);
        },
        pushParam: function (a) {
          var b = null != a.value ? a.value : a.original || "";
          if (this.stringParams)
            b.replace &&
              (b = b.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".")),
              a.depth && this.addDepth(a.depth),
              this.opcode("getContext", a.depth || 0),
              this.opcode("pushStringParam", b, a.type),
              "SubExpression" === a.type && this.accept(a);
          else {
            if (this.trackIds) {
              var c = void 0;
              if (
                (!a.parts ||
                  n["default"].helpers.scopedId(a) ||
                  a.depth ||
                  (c = this.blockParamIndex(a.parts[0])),
                c)
              ) {
                var d = a.parts.slice(1).join(".");
                this.opcode("pushId", "BlockParam", c, d);
              } else
                (b = a.original || b),
                  b.replace &&
                    (b = b
                      .replace(/^this(?:\.|$)/, "")
                      .replace(/^\.\//, "")
                      .replace(/^\.$/, "")),
                  this.opcode("pushId", a.type, b);
            }
            this.accept(a);
          }
        },
        setupFullMustacheParams: function (a, b, c, d) {
          var e = a.params;
          return (
            this.pushParams(e),
            this.opcode("pushProgram", b),
            this.opcode("pushProgram", c),
            a.hash ? this.accept(a.hash) : this.opcode("emptyHash", d),
            e
          );
        },
        blockParamIndex: function (a) {
          for (var b = 0, c = this.options.blockParams.length; c > b; b++) {
            var d = this.options.blockParams[b],
              e = d && l.indexOf(d, a);
            if (d && e >= 0) return [b, e];
          }
        },
      };
    },
    function (a, b, c) {
      "use strict";
      function d(a) {
        this.value = a;
      }
      function e() {}
      function f(a, b, c, d) {
        var e = b.popStack(),
          f = 0,
          g = c.length;
        for (a && g--; g > f; f++) e = b.nameLookup(e, c[f], d);
        return a
          ? [
              b.aliasable("container.strict"),
              "(",
              e,
              ", ",
              b.quotedString(c[f]),
              ")",
            ]
          : e;
      }
      var g = c(1)["default"];
      b.__esModule = !0;
      var h = c(4),
        i = c(6),
        j = g(i),
        k = c(5),
        l = c(29),
        m = g(l);
      (e.prototype = {
        nameLookup: function (a, b) {
          return e.isValidJavaScriptVariableName(b)
            ? [a, ".", b]
            : [a, "[", JSON.stringify(b), "]"];
        },
        depthedLookup: function (a) {
          return [this.aliasable("container.lookup"), '(depths, "', a, '")'];
        },
        compilerInfo: function () {
          var a = h.COMPILER_REVISION,
            b = h.REVISION_CHANGES[a];
          return [a, b];
        },
        appendToBuffer: function (a, b, c) {
          return (
            k.isArray(a) || (a = [a]),
            (a = this.source.wrap(a, b)),
            this.environment.isSimple
              ? ["return ", a, ";"]
              : c
              ? ["buffer += ", a, ";"]
              : ((a.appendToBuffer = !0), a)
          );
        },
        initializeBuffer: function () {
          return this.quotedString("");
        },
        compile: function (a, b, c, d) {
          (this.environment = a),
            (this.options = b),
            (this.stringParams = this.options.stringParams),
            (this.trackIds = this.options.trackIds),
            (this.precompile = !d),
            (this.name = this.environment.name),
            (this.isChild = !!c),
            (this.context = c || {
              decorators: [],
              programs: [],
              environments: [],
            }),
            this.preamble(),
            (this.stackSlot = 0),
            (this.stackVars = []),
            (this.aliases = {}),
            (this.registers = { list: [] }),
            (this.hashes = []),
            (this.compileStack = []),
            (this.inlineStack = []),
            (this.blockParams = []),
            this.compileChildren(a, b),
            (this.useDepths =
              this.useDepths ||
              a.useDepths ||
              a.useDecorators ||
              this.options.compat),
            (this.useBlockParams = this.useBlockParams || a.useBlockParams);
          var e = a.opcodes,
            f = void 0,
            g = void 0,
            h = void 0,
            i = void 0;
          for (h = 0, i = e.length; i > h; h++)
            (f = e[h]),
              (this.source.currentLocation = f.loc),
              (g = g || f.loc),
              this[f.opcode].apply(this, f.args);
          if (
            ((this.source.currentLocation = g),
            this.pushSource(""),
            this.stackSlot ||
              this.inlineStack.length ||
              this.compileStack.length)
          )
            throw new j["default"](
              "Compile completed with content left on stack"
            );
          this.decorators.isEmpty()
            ? (this.decorators = void 0)
            : ((this.useDecorators = !0),
              this.decorators.prepend(
                "var decorators = container.decorators;\n"
              ),
              this.decorators.push("return fn;"),
              d
                ? (this.decorators = Function.apply(this, [
                    "fn",
                    "props",
                    "container",
                    "depth0",
                    "data",
                    "blockParams",
                    "depths",
                    this.decorators.merge(),
                  ]))
                : (this.decorators.prepend(
                    "function(fn, props, container, depth0, data, blockParams, depths) {\n"
                  ),
                  this.decorators.push("}\n"),
                  (this.decorators = this.decorators.merge())));
          var k = this.createFunctionContext(d);
          if (this.isChild) return k;
          var l = { compiler: this.compilerInfo(), main: k };
          this.decorators &&
            ((l.main_d = this.decorators), (l.useDecorators = !0));
          var m = this.context,
            n = m.programs,
            o = m.decorators;
          for (h = 0, i = n.length; i > h; h++)
            n[h] &&
              ((l[h] = n[h]),
              o[h] && ((l[h + "_d"] = o[h]), (l.useDecorators = !0)));
          return (
            this.environment.usePartial && (l.usePartial = !0),
            this.options.data && (l.useData = !0),
            this.useDepths && (l.useDepths = !0),
            this.useBlockParams && (l.useBlockParams = !0),
            this.options.compat && (l.compat = !0),
            d
              ? (l.compilerOptions = this.options)
              : ((l.compiler = JSON.stringify(l.compiler)),
                (this.source.currentLocation = {
                  start: { line: 1, column: 0 },
                }),
                (l = this.objectLiteral(l)),
                b.srcName
                  ? ((l = l.toStringWithSourceMap({ file: b.destName })),
                    (l.map = l.map && l.map.toString()))
                  : (l = l.toString())),
            l
          );
        },
        preamble: function () {
          (this.lastContext = 0),
            (this.source = new m["default"](this.options.srcName)),
            (this.decorators = new m["default"](this.options.srcName));
        },
        createFunctionContext: function (a) {
          var b = "",
            c = this.stackVars.concat(this.registers.list);
          c.length > 0 && (b += ", " + c.join(", "));
          var d = 0;
          for (var e in this.aliases) {
            var f = this.aliases[e];
            this.aliases.hasOwnProperty(e) &&
              f.children &&
              f.referenceCount > 1 &&
              ((b += ", alias" + ++d + "=" + e), (f.children[0] = "alias" + d));
          }
          var g = ["container", "depth0", "helpers", "partials", "data"];
          (this.useBlockParams || this.useDepths) && g.push("blockParams"),
            this.useDepths && g.push("depths");
          var h = this.mergeSource(b);
          return a
            ? (g.push(h), Function.apply(this, g))
            : this.source.wrap(["function(", g.join(","), ") {\n  ", h, "}"]);
        },
        mergeSource: function (a) {
          var b = this.environment.isSimple,
            c = !this.forceBuffer,
            d = void 0,
            e = void 0,
            f = void 0,
            g = void 0;
          return (
            this.source.each(function (a) {
              a.appendToBuffer
                ? (f ? a.prepend("  + ") : (f = a), (g = a))
                : (f &&
                    (e ? f.prepend("buffer += ") : (d = !0),
                    g.add(";"),
                    (f = g = void 0)),
                  (e = !0),
                  b || (c = !1));
            }),
            c
              ? f
                ? (f.prepend("return "), g.add(";"))
                : e || this.source.push('return "";')
              : ((a += ", buffer = " + (d ? "" : this.initializeBuffer())),
                f
                  ? (f.prepend("return buffer + "), g.add(";"))
                  : this.source.push("return buffer;")),
            a &&
              this.source.prepend("var " + a.substring(2) + (d ? "" : ";\n")),
            this.source.merge()
          );
        },
        blockValue: function (a) {
          var b = this.aliasable("helpers.blockHelperMissing"),
            c = [this.contextName(0)];
          this.setupHelperArgs(a, 0, c);
          var d = this.popStack();
          c.splice(1, 0, d), this.push(this.source.functionCall(b, "call", c));
        },
        ambiguousBlockValue: function () {
          var a = this.aliasable("helpers.blockHelperMissing"),
            b = [this.contextName(0)];
          this.setupHelperArgs("", 0, b, !0), this.flushInline();
          var c = this.topStack();
          b.splice(1, 0, c),
            this.pushSource([
              "if (!",
              this.lastHelper,
              ") { ",
              c,
              " = ",
              this.source.functionCall(a, "call", b),
              "}",
            ]);
        },
        appendContent: function (a) {
          this.pendingContent
            ? (a = this.pendingContent + a)
            : (this.pendingLocation = this.source.currentLocation),
            (this.pendingContent = a);
        },
        append: function () {
          if (this.isInline())
            this.replaceStack(function (a) {
              return [" != null ? ", a, ' : ""'];
            }),
              this.pushSource(this.appendToBuffer(this.popStack()));
          else {
            var a = this.popStack();
            this.pushSource([
              "if (",
              a,
              " != null) { ",
              this.appendToBuffer(a, void 0, !0),
              " }",
            ]),
              this.environment.isSimple &&
                this.pushSource([
                  "else { ",
                  this.appendToBuffer("''", void 0, !0),
                  " }",
                ]);
          }
        },
        appendEscaped: function () {
          this.pushSource(
            this.appendToBuffer([
              this.aliasable("container.escapeExpression"),
              "(",
              this.popStack(),
              ")",
            ])
          );
        },
        getContext: function (a) {
          this.lastContext = a;
        },
        pushContext: function () {
          this.pushStackLiteral(this.contextName(this.lastContext));
        },
        lookupOnContext: function (a, b, c, d) {
          var e = 0;
          d || !this.options.compat || this.lastContext
            ? this.pushContext()
            : this.push(this.depthedLookup(a[e++])),
            this.resolvePath("context", a, e, b, c);
        },
        lookupBlockParam: function (a, b) {
          (this.useBlockParams = !0),
            this.push(["blockParams[", a[0], "][", a[1], "]"]),
            this.resolvePath("context", b, 1);
        },
        lookupData: function (a, b, c) {
          a
            ? this.pushStackLiteral("container.data(data, " + a + ")")
            : this.pushStackLiteral("data"),
            this.resolvePath("data", b, 0, !0, c);
        },
        resolvePath: function (a, b, c, d, e) {
          var g = this;
          if (this.options.strict || this.options.assumeObjects)
            return void this.push(f(this.options.strict && e, this, b, a));
          for (var h = b.length; h > c; c++)
            this.replaceStack(function (e) {
              var f = g.nameLookup(e, b[c], a);
              return d ? [" && ", f] : [" != null ? ", f, " : ", e];
            });
        },
        resolvePossibleLambda: function () {
          this.push([
            this.aliasable("container.lambda"),
            "(",
            this.popStack(),
            ", ",
            this.contextName(0),
            ")",
          ]);
        },
        pushStringParam: function (a, b) {
          this.pushContext(),
            this.pushString(b),
            "SubExpression" !== b &&
              ("string" == typeof a
                ? this.pushString(a)
                : this.pushStackLiteral(a));
        },
        emptyHash: function (a) {
          this.trackIds && this.push("{}"),
            this.stringParams && (this.push("{}"), this.push("{}")),
            this.pushStackLiteral(a ? "undefined" : "{}");
        },
        pushHash: function () {
          this.hash && this.hashes.push(this.hash),
            (this.hash = { values: [], types: [], contexts: [], ids: [] });
        },
        popHash: function () {
          var a = this.hash;
          (this.hash = this.hashes.pop()),
            this.trackIds && this.push(this.objectLiteral(a.ids)),
            this.stringParams &&
              (this.push(this.objectLiteral(a.contexts)),
              this.push(this.objectLiteral(a.types))),
            this.push(this.objectLiteral(a.values));
        },
        pushString: function (a) {
          this.pushStackLiteral(this.quotedString(a));
        },
        pushLiteral: function (a) {
          this.pushStackLiteral(a);
        },
        pushProgram: function (a) {
          null != a
            ? this.pushStackLiteral(this.programExpression(a))
            : this.pushStackLiteral(null);
        },
        registerDecorator: function (a, b) {
          var c = this.nameLookup("decorators", b, "decorator"),
            d = this.setupHelperArgs(b, a);
          this.decorators.push([
            "fn = ",
            this.decorators.functionCall(c, "", [
              "fn",
              "props",
              "container",
              d,
            ]),
            " || fn;",
          ]);
        },
        invokeHelper: function (a, b, c) {
          var d = this.popStack(),
            e = this.setupHelper(a, b),
            f = c ? [e.name, " || "] : "",
            g = ["("].concat(f, d);
          this.options.strict ||
            g.push(" || ", this.aliasable("helpers.helperMissing")),
            g.push(")"),
            this.push(this.source.functionCall(g, "call", e.callParams));
        },
        invokeKnownHelper: function (a, b) {
          var c = this.setupHelper(a, b);
          this.push(this.source.functionCall(c.name, "call", c.callParams));
        },
        invokeAmbiguous: function (a, b) {
          this.useRegister("helper");
          var c = this.popStack();
          this.emptyHash();
          var d = this.setupHelper(0, a, b),
            e = (this.lastHelper = this.nameLookup("helpers", a, "helper")),
            f = ["(", "(helper = ", e, " || ", c, ")"];
          this.options.strict ||
            ((f[0] = "(helper = "),
            f.push(
              " != null ? helper : ",
              this.aliasable("helpers.helperMissing")
            )),
            this.push([
              "(",
              f,
              d.paramsInit ? ["),(", d.paramsInit] : [],
              "),",
              "(typeof helper === ",
              this.aliasable('"function"'),
              " ? ",
              this.source.functionCall("helper", "call", d.callParams),
              " : helper))",
            ]);
        },
        invokePartial: function (a, b, c) {
          var d = [],
            e = this.setupParams(b, 1, d);
          a && ((b = this.popStack()), delete e.name),
            c && (e.indent = JSON.stringify(c)),
            (e.helpers = "helpers"),
            (e.partials = "partials"),
            (e.decorators = "container.decorators"),
            a
              ? d.unshift(b)
              : d.unshift(this.nameLookup("partials", b, "partial")),
            this.options.compat && (e.depths = "depths"),
            (e = this.objectLiteral(e)),
            d.push(e),
            this.push(
              this.source.functionCall("container.invokePartial", "", d)
            );
        },
        assignToHash: function (a) {
          var b = this.popStack(),
            c = void 0,
            d = void 0,
            e = void 0;
          this.trackIds && (e = this.popStack()),
            this.stringParams && ((d = this.popStack()), (c = this.popStack()));
          var f = this.hash;
          c && (f.contexts[a] = c),
            d && (f.types[a] = d),
            e && (f.ids[a] = e),
            (f.values[a] = b);
        },
        pushId: function (a, b, c) {
          "BlockParam" === a
            ? this.pushStackLiteral(
                "blockParams[" +
                  b[0] +
                  "].path[" +
                  b[1] +
                  "]" +
                  (c ? " + " + JSON.stringify("." + c) : "")
              )
            : "PathExpression" === a
            ? this.pushString(b)
            : "SubExpression" === a
            ? this.pushStackLiteral("true")
            : this.pushStackLiteral("null");
        },
        compiler: e,
        compileChildren: function (a, b) {
          for (
            var c = a.children, d = void 0, e = void 0, f = 0, g = c.length;
            g > f;
            f++
          ) {
            (d = c[f]), (e = new this.compiler());
            var h = this.matchExistingProgram(d);
            null == h
              ? (this.context.programs.push(""),
                (h = this.context.programs.length),
                (d.index = h),
                (d.name = "program" + h),
                (this.context.programs[h] = e.compile(
                  d,
                  b,
                  this.context,
                  !this.precompile
                )),
                (this.context.decorators[h] = e.decorators),
                (this.context.environments[h] = d),
                (this.useDepths = this.useDepths || e.useDepths),
                (this.useBlockParams = this.useBlockParams || e.useBlockParams))
              : ((d.index = h),
                (d.name = "program" + h),
                (this.useDepths = this.useDepths || d.useDepths),
                (this.useBlockParams =
                  this.useBlockParams || d.useBlockParams));
          }
        },
        matchExistingProgram: function (a) {
          for (var b = 0, c = this.context.environments.length; c > b; b++) {
            var d = this.context.environments[b];
            if (d && d.equals(a)) return b;
          }
        },
        programExpression: function (a) {
          var b = this.environment.children[a],
            c = [b.index, "data", b.blockParams];
          return (
            (this.useBlockParams || this.useDepths) && c.push("blockParams"),
            this.useDepths && c.push("depths"),
            "container.program(" + c.join(", ") + ")"
          );
        },
        useRegister: function (a) {
          this.registers[a] ||
            ((this.registers[a] = !0), this.registers.list.push(a));
        },
        push: function (a) {
          return (
            a instanceof d || (a = this.source.wrap(a)),
            this.inlineStack.push(a),
            a
          );
        },
        pushStackLiteral: function (a) {
          this.push(new d(a));
        },
        pushSource: function (a) {
          this.pendingContent &&
            (this.source.push(
              this.appendToBuffer(
                this.source.quotedString(this.pendingContent),
                this.pendingLocation
              )
            ),
            (this.pendingContent = void 0)),
            a && this.source.push(a);
        },
        replaceStack: function (a) {
          var b = ["("],
            c = void 0,
            e = void 0,
            f = void 0;
          if (!this.isInline())
            throw new j["default"]("replaceStack on non-inline");
          var g = this.popStack(!0);
          if (g instanceof d) (c = [g.value]), (b = ["(", c]), (f = !0);
          else {
            e = !0;
            var h = this.incrStack();
            (b = ["((", this.push(h), " = ", g, ")"]), (c = this.topStack());
          }
          var i = a.call(this, c);
          f || this.popStack(),
            e && this.stackSlot--,
            this.push(b.concat(i, ")"));
        },
        incrStack: function () {
          return (
            this.stackSlot++,
            this.stackSlot > this.stackVars.length &&
              this.stackVars.push("stack" + this.stackSlot),
            this.topStackName()
          );
        },
        topStackName: function () {
          return "stack" + this.stackSlot;
        },
        flushInline: function () {
          var a = this.inlineStack;
          this.inlineStack = [];
          for (var b = 0, c = a.length; c > b; b++) {
            var e = a[b];
            if (e instanceof d) this.compileStack.push(e);
            else {
              var f = this.incrStack();
              this.pushSource([f, " = ", e, ";"]), this.compileStack.push(f);
            }
          }
        },
        isInline: function () {
          return this.inlineStack.length;
        },
        popStack: function (a) {
          var b = this.isInline(),
            c = (b ? this.inlineStack : this.compileStack).pop();
          if (!a && c instanceof d) return c.value;
          if (!b) {
            if (!this.stackSlot) throw new j["default"]("Invalid stack pop");
            this.stackSlot--;
          }
          return c;
        },
        topStack: function () {
          var a = this.isInline() ? this.inlineStack : this.compileStack,
            b = a[a.length - 1];
          return b instanceof d ? b.value : b;
        },
        contextName: function (a) {
          return this.useDepths && a ? "depths[" + a + "]" : "depth" + a;
        },
        quotedString: function (a) {
          return this.source.quotedString(a);
        },
        objectLiteral: function (a) {
          return this.source.objectLiteral(a);
        },
        aliasable: function (a) {
          var b = this.aliases[a];
          return b
            ? (b.referenceCount++, b)
            : ((b = this.aliases[a] = this.source.wrap(a)),
              (b.aliasable = !0),
              (b.referenceCount = 1),
              b);
        },
        setupHelper: function (a, b, c) {
          var d = [],
            e = this.setupHelperArgs(b, a, d, c),
            f = this.nameLookup("helpers", b, "helper"),
            g = this.aliasable(
              this.contextName(0) +
                " != null ? " +
                this.contextName(0) +
                " : {}"
            );
          return {
            params: d,
            paramsInit: e,
            name: f,
            callParams: [g].concat(d),
          };
        },
        setupParams: function (a, b, c) {
          var d = {},
            e = [],
            f = [],
            g = [],
            h = !c,
            i = void 0;
          h && (c = []),
            (d.name = this.quotedString(a)),
            (d.hash = this.popStack()),
            this.trackIds && (d.hashIds = this.popStack()),
            this.stringParams &&
              ((d.hashTypes = this.popStack()),
              (d.hashContexts = this.popStack()));
          var j = this.popStack(),
            k = this.popStack();
          (k || j) &&
            ((d.fn = k || "container.noop"),
            (d.inverse = j || "container.noop"));
          for (var l = b; l--; )
            (i = this.popStack()),
              (c[l] = i),
              this.trackIds && (g[l] = this.popStack()),
              this.stringParams &&
                ((f[l] = this.popStack()), (e[l] = this.popStack()));
          return (
            h && (d.args = this.source.generateArray(c)),
            this.trackIds && (d.ids = this.source.generateArray(g)),
            this.stringParams &&
              ((d.types = this.source.generateArray(f)),
              (d.contexts = this.source.generateArray(e))),
            this.options.data && (d.data = "data"),
            this.useBlockParams && (d.blockParams = "blockParams"),
            d
          );
        },
        setupHelperArgs: function (a, b, c, d) {
          var e = this.setupParams(a, b, c);
          return (
            (e = this.objectLiteral(e)),
            d
              ? (this.useRegister("options"),
                c.push("options"),
                ["options=", e])
              : c
              ? (c.push(e), "")
              : e
          );
        },
      }),
        (function () {
          for (
            var a =
                "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(
                  " "
                ),
              b = (e.RESERVED_WORDS = {}),
              c = 0,
              d = a.length;
            d > c;
            c++
          )
            b[a[c]] = !0;
        })(),
        (e.isValidJavaScriptVariableName = function (a) {
          return !e.RESERVED_WORDS[a] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(a);
        }),
        (b["default"] = e),
        (a.exports = b["default"]);
    },
    function (a, b, c) {
      "use strict";
      function d(a, b, c) {
        if (f.isArray(a)) {
          for (var d = [], e = 0, g = a.length; g > e; e++)
            d.push(b.wrap(a[e], c));
          return d;
        }
        return "boolean" == typeof a || "number" == typeof a ? a + "" : a;
      }
      function e(a) {
        (this.srcFile = a), (this.source = []);
      }
      b.__esModule = !0;
      var f = c(5),
        g = void 0;
      try {
      } catch (h) {}
      g ||
        ((g = function (a, b, c, d) {
          (this.src = ""), d && this.add(d);
        }),
        (g.prototype = {
          add: function (a) {
            f.isArray(a) && (a = a.join("")), (this.src += a);
          },
          prepend: function (a) {
            f.isArray(a) && (a = a.join("")), (this.src = a + this.src);
          },
          toStringWithSourceMap: function () {
            return { code: this.toString() };
          },
          toString: function () {
            return this.src;
          },
        })),
        (e.prototype = {
          isEmpty: function () {
            return !this.source.length;
          },
          prepend: function (a, b) {
            this.source.unshift(this.wrap(a, b));
          },
          push: function (a, b) {
            this.source.push(this.wrap(a, b));
          },
          merge: function () {
            var a = this.empty();
            return (
              this.each(function (b) {
                a.add(["  ", b, "\n"]);
              }),
              a
            );
          },
          each: function (a) {
            for (var b = 0, c = this.source.length; c > b; b++)
              a(this.source[b]);
          },
          empty: function () {
            var a = this.currentLocation || { start: {} };
            return new g(a.start.line, a.start.column, this.srcFile);
          },
          wrap: function (a) {
            var b =
              arguments.length <= 1 || void 0 === arguments[1]
                ? this.currentLocation || { start: {} }
                : arguments[1];
            return a instanceof g
              ? a
              : ((a = d(a, this, b)),
                new g(b.start.line, b.start.column, this.srcFile, a));
          },
          functionCall: function (a, b, c) {
            return (
              (c = this.generateList(c)),
              this.wrap([a, b ? "." + b + "(" : "(", c, ")"])
            );
          },
          quotedString: function (a) {
            return (
              '"' +
              (a + "")
                .replace(/\\/g, "\\\\")
                .replace(/"/g, '\\"')
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/\u2028/g, "\\u2028")
                .replace(/\u2029/g, "\\u2029") +
              '"'
            );
          },
          objectLiteral: function (a) {
            var b = [];
            for (var c in a)
              if (a.hasOwnProperty(c)) {
                var e = d(a[c], this);
                "undefined" !== e && b.push([this.quotedString(c), ":", e]);
              }
            var f = this.generateList(b);
            return f.prepend("{"), f.add("}"), f;
          },
          generateList: function (a) {
            for (var b = this.empty(), c = 0, e = a.length; e > c; c++)
              c && b.add(","), b.add(d(a[c], this));
            return b;
          },
          generateArray: function (a) {
            var b = this.generateList(a);
            return b.prepend("["), b.add("]"), b;
          },
        }),
        (b["default"] = e),
        (a.exports = b["default"]);
    },
  ]);
});
var formatNumber = function (value) {
  value = parseFloat(value).toFixed(2);
  var parts = value.toString().split(".");
  parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  if (parts[1] == "00") {
    return parts[0];
  }
  return parts.join(".");
};
Handlebars.registerHelper("formatNumber", function (value) {
  return formatNumber(value);
});
Handlebars.registerHelper("zeroindex", function (index, count) {
  if (count != 0) {
    return index + parseFloat(count);
  } else {
    return index + parseFloat(cartIndexFrom);
  }
});
Handlebars.registerHelper("sum", function () {
  var sum = 0,
    v;
  for (var i = 0; i < arguments.length; i++) {
    v = parseFloat(arguments[i]);
    if (!isNaN(v)) sum += v;
  }
  value = parseFloat(sum).toFixed(2);
  var parts = value.toString().split(".");
  parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  if (parts[1] == "00") {
    return parts[0];
  }
  return parts.join(".");
});
Handlebars.registerHelper("if_gt_zero", function (value, options) {
  if (value > 0) {
    return options.fn(this);
  }
  return options.inverse(this);
});
Handlebars.registerHelper("counter", function (index) {
  if ($(".cart-content").hasClass("first-cart")) {
    return index + 2;
  } else {
    return index + 1;
  }
});
Handlebars.registerHelper("if_eq", function (a, b, opts) {
  if (a == b) {
    return opts.fn(this);
  } else {
    return opts.inverse(this);
  }
});
// if (typeof window.cart == "undefined") {
//   window.cart = new Cart("/india/sales/social/cart/");
// }
// window.cart.addObserver(function (cart) {
//   if (typeof cart.items !== "undefined" && cart.items.length) {
//     $("a.cart").tooltip("destroy");
//     $("a.cart sup").show();
//     $(".wrap-cart-block").show();
//     var items_template = Handlebars.compile($("#g-cart-item-template").html());
//     cart.trans_text = {
//       print_at_home: gettext("Print at Home"),
//       print_at_work: gettext("Print at Work"),
//       delivery_by: gettext("Delivery By"),
//       remove: gettext("Remove"),
//       new: gettext("New"),
//       edit: gettext("Edit"),
//       email: gettext("Email"),
//       sms: gettext("SMS"),
//     };
//     var items_html = items_template(cart);
//     $("#cart-block").empty().append(items_html);
//     var self = cart;
//     $("body")
//       .off("click")
//       .on("click", "#btn-g-checkout, .cart-checkout", function (e) {
//         e.preventDefault();
//         $.ajax({
//           url: self.create_invoice_url,
//           type: "POST",
//           data: { csrfmiddlewaretoken: Cookies.get("csrftoken") },
//         }).done(function (data) {
//           if (e.target && e.target.id === "btn-g-checkout") {
//             pushTappedOnCheckoutCartEvent();
//           } else {
//             pushTappedOnCartEvent();
//           }
//           window.location = "" + data.invoice.url;
//         });
//       });
//     var totals_template = Handlebars.compile(
//       $("#g-cart-totals-template").html()
//     );
//     var totals_data = {
//       trans_text: {
//         no_of_egift_cards: gettext("#No of eGift Cards"),
//         total_amount: gettext("Total Amount"),
//         checkout: gettext("Checkout"),
//       },
//       currency: cart.currency,
//       amount: parseFloat(cart.amount),
//     };
//     var totals_html = totals_template(totals_data);
//     $("#cart-footer").empty().append(totals_html);
//   } else {
//     $("a.cart")
//       .attr("title", gettext("Your cart is empty!"))
//       .tooltip("fixTitle");
//     $(".wrap-cart-block").hide();
//     $("#cart-block, #cart-footer").empty();
//     var num_items = 0;
//     if (typeof cart.items !== "undefined") {
//       num_items = cart.items.length;
//     }
//     $("a.cart sup").hide();
//   }
// });
// $(document).ready(function () {
//   if (!window.cart.loaded) {
//     window.cart.update();
//   }
// });
(function ($) {
  $(".wrap-cart-block").on(
    "click",
    ".cart-block .sm-view a.remove",
    function (e) {
      e.preventDefault();
      $(".side-scroller .sm-view").popover("hide");
      $(".overlay-loader").show();
      $.ajax({
        url: $(this).data("remove-url"),
        type: "POST",
        data: { csrfmiddlewaretoken: Cookies.get("csrftoken") },
      }).done(function (data) {
        pushRemovedFromCartEvent();
        window.cart.update();
        showNotify("removed");
        if (typeof window.checkout != "undefined") {
          $.ajax({
            url: window.cart.create_invoice_url,
            type: "POST",
            data: { csrfmiddlewaretoken: Cookies.get("csrftoken") },
          }).done(function (data) {
            var invoice_url = "" + data.invoice.url;
            invoiceValidateUrl = "" + data.invoice.invoice_validate_url;
            $.ajax({ url: invoice_url }).done(function (data) {
              $(".overlay-loader").hide();
              $.extend(window.checkout, data);
              window.checkout.updatePaymentForms();
              window.history.replaceState(
                {},
                $(document).attr("title"),
                invoice_url
              );
            });
          });
        } else {
          $(".overlay-loader").hide();
        }
      });
    }
  );
  $("ul.nav li.dropdown").hover(
    function () {
      $(this)
        .addClass("open")
        .find(".dropdown-menu")
        .first()
        .addClass("dropdown-menu-open");
    },
    function () {
      $(this)
        .removeClass("open")
        .find(".dropdown-menu")
        .first()
        .removeClass("dropdown-menu-open");
    }
  );
})(jQuery);
$.fn.circleType = function (a) {
  var c = { dir: 1, position: "relative" };
  return "function" != typeof $.fn.lettering
    ? (console.log("Lettering.js is required"), void 0)
    : this.each(function () {
        a && $.extend(c, a);
        var h,
          i,
          b = this,
          d = 180 / Math.PI,
          e = parseInt($(b).css("font-size"), 10),
          f = parseInt($(b).css("line-height"), 10) || e,
          g = b.innerHTML.replace(/^\s+|\s+$/g, "").replace(/\s/g, "&nbsp;");
        (b.innerHTML = g),
          $(b).lettering(),
          (b.style.position = c.position),
          (h = b.getElementsByTagName("span")),
          (i = Math.floor(h.length / 2));
        var j = function () {
            var g,
              j,
              k,
              m,
              n,
              o,
              p,
              q,
              a = 0,
              i = 0;
            for (g = 0; g < h.length; g++) a += h[g].offsetWidth;
            for (
              j = a / Math.PI / 2 + f,
                c.fluid && !c.fitText
                  ? (c.radius = Math.max(b.offsetWidth / 2, j))
                  : c.radius || (c.radius = j),
                k =
                  -1 === c.dir
                    ? "center " + (-c.radius + f) / e + "em"
                    : "center " + c.radius / e + "em",
                m = c.radius - f,
                g = 0;
              g < h.length;
              g++
            )
              (n = h[g]),
                (i += (n.offsetWidth / 2 / m) * d),
                (n.rot = i),
                (i += (n.offsetWidth / 2 / m) * d);
            for (g = 0; g < h.length; g++)
              (n = h[g]),
                (o = n.style),
                (p = (-i * c.dir) / 2 + n.rot * c.dir),
                (q = "rotate(" + p + "deg)"),
                (o.position = "absolute"),
                (o.left = "50%"),
                (o.marginLeft = -(n.offsetWidth / 2) / e + "em"),
                (o.webkitTransform = q),
                (o.MozTransform = q),
                (o.OTransform = q),
                (o.msTransform = q),
                (o.transform = q),
                (o.webkitTransformOrigin = k),
                (o.MozTransformOrigin = k),
                (o.OTransformOrigin = k),
                (o.msTransformOrigin = k),
                (o.transformOrigin = k),
                -1 === c.dir && (o.bottom = 0);
            c.fitText &&
              ("function" != typeof $.fn.fitText
                ? console.log(
                    "FitText.js is required when using the fitText option"
                  )
                : ($(b).fitText(),
                  $(window).resize(function () {
                    l();
                  }))),
              l(),
              "function" == typeof c.callback && c.callback.apply(b);
          },
          k = function (a) {
            var b = document.documentElement,
              c = a.getBoundingClientRect();
            return {
              top: c.top + window.pageYOffset - b.clientTop,
              left: c.left + window.pageXOffset - b.clientLeft,
              height: c.height,
            };
          },
          l = function () {
            var d,
              a = k(h[i]),
              c = k(h[0]);
            (d =
              a.top < c.top
                ? c.top - a.top + c.height
                : a.top - c.top + c.height),
              (b.style.height = d + "px");
          };
        c.fluid &&
          !c.fitText &&
          $(window).resize(function () {
            j();
          }),
          "complete" !== document.readyState
            ? ((b.style.visibility = "hidden"),
              $(window).load(function () {
                (b.style.visibility = "visible"), j();
              }))
            : j();
      });
};
(function ($) {
  function injector(t, splitter, klass, after) {
    var text = t.text(),
      a = text.split(splitter),
      inject = "";
    if (a.length) {
      $(a).each(function (i, item) {
        inject +=
          '<span class="' +
          klass +
          (i + 1) +
          '" aria-hidden="true">' +
          item +
          "</span>" +
          after;
      });
      t.attr("aria-label", text).empty().append(inject);
    }
  }
  var methods = {
    init: function () {
      return this.each(function () {
        injector($(this), "", "char", "");
      });
    },
    words: function () {
      return this.each(function () {
        injector($(this), " ", "word", " ");
      });
    },
    lines: function () {
      return this.each(function () {
        var r = "eefec303079ad17405c889e092e105b0";
        injector($(this).children("br").replaceWith(r).end(), r, "line", "");
      });
    },
  };
  $.fn.lettering = function (method) {
    if (method && methods[method]) {
      return methods[method].apply(this, [].slice.call(arguments, 1));
    } else if (method === "letters" || !method) {
      return methods.init.apply(this, [].slice.call(arguments, 0));
    }
    $.error("Method " + method + " does not exist on jQuery.lettering");
    return this;
  };
})(jQuery);
function autoPlayYouTubeModal() {
  var trigger = $("body").find('[data-toggle="modal"]');
  trigger.click(function () {
    var theModal = $(this).data("target"),
      videoSRC = $(this).attr("data-theVideo"),
      videoSRCauto = videoSRC;
    $(theModal + " iframe").attr("src", videoSRCauto);
    $(theModal + " button.close").click(function () {
      $(theModal + " iframe").attr("src", "");
    });
  });
  $("#videoModal").on("hidden.bs.modal", function () {
    $("#videoModal iframe").attr("src", "");
  });
}
// autoPlayYouTubeModal();
// $(document).ready(function () {
//   $("#blend-text").circleType({ radius: 153 });
//   $(
//     "a.birthday-mini-banner, a.spotlight-banner-home, a.scroller, a.buygift-top-home, a.popular-occasions-home, a.homepage-banner"
//   ).click(function (e) {
//     e.preventDefault();
//     $($(this).data("goto")).goTo();
//   });
//   $(window).bind("hashchange", function () {
//     if (window.location.hash.match(/#_scroll_.*/i)) {
//       $(window.location.hash).goTo();
//       return;
//     }
//   });
//   $(window).trigger("hashchange");
//   $("body").popover("destroy");
//   $(".popme").hover(function () {
//     $("body").popover("destroy");
//     var popimage = $(this).data("img");
//     var popoverTemplate = [
//       '<div class="popover small-popover">',
//       '<div class="arrow"></div>',
//       '<div class="popover-content">',
//       "</div>",
//       "</div>",
//     ].join("");
//     var content = [
//       '<img src="' + popimage + '" width="477" height="376" alt="" title="" />',
//     ].join("");
//     var current_lang_code = "{{ lang_code }}";
//     if (current_lang_code && current_lang_code == "ar") {
//       $("body").popover({
//         selector: "[rel=popover]",
//         trigger: "hover",
//         content: content,
//         template: popoverTemplate,
//         placement: "left",
//         html: true,
//       });
//     } else {
//       $("body").popover({
//         selector: "[rel=popover]",
//         trigger: "hover",
//         content: content,
//         template: popoverTemplate,
//         placement: "right",
//         html: true,
//       });
//     }
//   });
//   $(".popup").hover(function () {
//     $("body").popover("destroy");
//     var popimage = $(this).data("img");
//     var popoverTemplate = [
//       '<div class="popover right-popover">',
//       '<div class="arrow"></div>',
//       '<div class="popover-content">',
//       "</div>",
//       "</div>",
//     ].join("");
//     var content = [
//       '<img src="' + popimage + '" width="361" height="522" alt="" title="" />',
//     ].join("");
//     $("body").popover({
//       selector: "[rel=popover]",
//       trigger: "hover",
//       content: content,
//       template: popoverTemplate,
//       placement: "right",
//       html: true,
//     });
//   });
//   $(".sharethis").on("click", function (e) {
//     e.preventDefault();
//     $(".overlay-share").stop().fadeIn(300);
//   });
//   $("a.close-share").on("click", function (e) {
//     e.preventDefault();
//     $(".overlay-share").fadeOut();
//   });
//   var $pop = $(".share-popup"),
//     notHov = 1;
//   $pop.hover(function () {
//     notHov ^= 1;
//   });
//   $(".overlay-share").on("mouseup keyup", function (e) {
//     if (notHov || e.which == 27) {
//       $(".overlay-share").fadeOut();
//     }
//   });
// });
$(document).ready(function () {
  $(document).on("click", ".start-gifting", function () {
    clevertap.event.push(
      clevertap_events.startGifting,
      clevertap_events_data.startGiftingWeb
    );
    console.log("Clevertap Web startGifting event pushed");
  });


  $(".overlay-loader").show();
  $("#carousel-homepage .carousel-inner").on(
    "click",
    "a.homepage-banner",
    function (e) {
      e.preventDefault();
      $($(this).data("goto")).goTo();
    }
  );
});
function pushTappedOnbannerEvent(tileName) {
  let tappedOnbannerData = { Platform: sitePlatform, "Tile Name": tileName };
  clevertap.event.push(clevertap_events.tappedOnbanner, tappedOnbannerData);
}

(function (c, d) {
  var b = "2.9999.8";
  if (c.support === d) {
    c.support = { opacity: !c.browser.msie };
  }
  function g(t) {
    if (c.fn.cycle.debug) {
      f(t);
    }
  }
  function f() {
    if (window.console && console.log) {
      console.log("[cycle] " + Array.prototype.join.call(arguments, " "));
    }
  }
  c.expr[":"].paused = function (s) {
    return s.cyclePause;
  };
  c.fn.cycle = function (t, s) {
    var u = { s: this.selector, c: this.context };
    if (this.length === 0 && t != "stop") {
      if (!c.isReady && u.s) {
        f("DOM not ready, queuing slideshow");
        c(function () {
          c(u.s, u.c).cycle(t, s);
        });
        return this;
      }
      f(
        "terminating; zero elements found by selector" +
          (c.isReady ? "" : " (DOM not ready)")
      );
      return this;
    }
    return this.each(function () {
      var y = l(this, t, s);
      if (y === false) {
        return;
      }
      y.updateActivePagerLink =
        y.updateActivePagerLink || c.fn.cycle.updateActivePagerLink;
      if (this.cycleTimeout) {
        clearTimeout(this.cycleTimeout);
      }
      this.cycleTimeout = this.cyclePause = 0;
      this.cycleStop = 0;
      var z = c(this);
      var A = y.slideExpr ? c(y.slideExpr, this) : z.children();
      var w = A.get();
      if (w.length < 2) {
        f("terminating; too few slides: " + w.length);
        return;
      }
      var v = q(z, A, w, y, u);
      if (v === false) {
        return;
      }
      var x = v.continuous
        ? 10
        : m(w[v.currSlide], w[v.nextSlide], v, !v.backwards);
      if (x) {
        x += v.delay || 0;
        if (x < 10) {
          x = 10;
        }
        g("first timeout: " + x);
        this.cycleTimeout = setTimeout(function () {
          n(w, v, 0, !y.backwards);
        }, x);
      }
    });
  };
  function k(s, v, u) {
    var w = c(s).data("cycle.opts");
    if (!w) {
      return;
    }
    var t = !!s.cyclePause;
    if (t && w.paused) {
      w.paused(s, w, v, u);
    } else {
      if (!t && w.resumed) {
        w.resumed(s, w, v, u);
      }
    }
  }
  function l(s, v, t) {
    if (s.cycleStop === d) {
      s.cycleStop = 0;
    }
    if (v === d || v === null) {
      v = {};
    }
    if (v.constructor == String) {
      switch (v) {
        case "destroy":
        case "stop":
          var x = c(s).data("cycle.opts");
          if (!x) {
            return false;
          }
          s.cycleStop++;
          if (s.cycleTimeout) {
            clearTimeout(s.cycleTimeout);
          }
          s.cycleTimeout = 0;
          if (x.elements) {
            c(x.elements).stop();
          }
          c(s).removeData("cycle.opts");
          if (v == "destroy") {
            r(s, x);
          }
          return false;
        case "toggle":
          s.cyclePause = s.cyclePause === 1 ? 0 : 1;
          w(s.cyclePause, t, s);
          k(s);
          return false;
        case "pause":
          s.cyclePause = 1;
          k(s);
          return false;
        case "resume":
          s.cyclePause = 0;
          w(false, t, s);
          k(s);
          return false;
        case "prev":
        case "next":
          x = c(s).data("cycle.opts");
          if (!x) {
            f('options not found, "prev/next" ignored');
            return false;
          }
          c.fn.cycle[v](x);
          return false;
        default:
          v = { fx: v };
      }
      return v;
    } else {
      if (v.constructor == Number) {
        var u = v;
        v = c(s).data("cycle.opts");
        if (!v) {
          f("options not found, can not advance slide");
          return false;
        }
        if (u < 0 || u >= v.elements.length) {
          f("invalid slide index: " + u);
          return false;
        }
        v.nextSlide = u;
        if (s.cycleTimeout) {
          clearTimeout(s.cycleTimeout);
          s.cycleTimeout = 0;
        }
        if (typeof t == "string") {
          v.oneTimeFx = t;
        }
        n(v.elements, v, 1, u >= v.currSlide);
        return false;
      }
    }
    return v;
    function w(z, A, y) {
      if (!z && A === true) {
        var B = c(y).data("cycle.opts");
        if (!B) {
          f("options not found, can not resume");
          return false;
        }
        if (y.cycleTimeout) {
          clearTimeout(y.cycleTimeout);
          y.cycleTimeout = 0;
        }
        n(B.elements, B, 1, !B.backwards);
      }
    }
  }
  function e(s, t) {
    if (!c.support.opacity && t.cleartype && s.style.filter) {
      try {
        s.style.removeAttribute("filter");
      } catch (u) {}
    }
  }
  function r(s, t) {
    if (t.next) {
      c(t.next).unbind(t.prevNextEvent);
    }
    if (t.prev) {
      c(t.prev).unbind(t.prevNextEvent);
    }
    if (t.pager || t.pagerAnchorBuilder) {
      c.each(t.pagerAnchors || [], function () {
        this.unbind().remove();
      });
    }
    t.pagerAnchors = null;
    c(s).unbind("mouseenter.cycle mouseleave.cycle");
    if (t.destroy) {
      t.destroy(t);
    }
  }
  function q(C, Q, z, y, J) {
    var s;
    var H = c.extend(
      {},
      c.fn.cycle.defaults,
      y || {},
      c.metadata ? C.metadata() : c.meta ? C.data() : {}
    );
    var F = c.isFunction(C.data) ? C.data(H.metaAttr) : null;
    if (F) {
      H = c.extend(H, F);
    }
    if (H.autostop) {
      H.countdown = H.autostopCount || z.length;
    }
    var u = C[0];
    C.data("cycle.opts", H);
    H.$cont = C;
    H.stopCount = u.cycleStop;
    H.elements = z;
    H.before = H.before ? [H.before] : [];
    H.after = H.after ? [H.after] : [];
    if (!c.support.opacity && H.cleartype) {
      H.after.push(function () {
        e(this, H);
      });
    }
    if (H.continuous) {
      H.after.push(function () {
        n(z, H, 0, !H.backwards);
      });
    }
    i(H);
    if (!c.support.opacity && H.cleartype && !H.cleartypeNoBg) {
      a(Q);
    }
    if (C.css("position") == "static") {
      C.css("position", "relative");
    }
    if (H.width) {
      C.width(H.width);
    }
    if (H.height && H.height != "auto") {
      C.height(H.height);
    }
    if (H.startingSlide !== d) {
      H.startingSlide = parseInt(H.startingSlide, 10);
      if (H.startingSlide >= z.length || H.startSlide < 0) {
        H.startingSlide = 0;
      } else {
        s = true;
      }
    } else {
      if (H.backwards) {
        H.startingSlide = z.length - 1;
      } else {
        H.startingSlide = 0;
      }
    }
    if (H.random) {
      H.randomMap = [];
      for (var O = 0; O < z.length; O++) {
        H.randomMap.push(O);
      }
      H.randomMap.sort(function (S, w) {
        return Math.random() - 0.5;
      });
      if (s) {
        for (var M = 0; M < z.length; M++) {
          if (H.startingSlide == H.randomMap[M]) {
            H.randomIndex = M;
          }
        }
      } else {
        H.randomIndex = 1;
        H.startingSlide = H.randomMap[1];
      }
    } else {
      if (H.startingSlide >= z.length) {
        H.startingSlide = 0;
      }
    }
    H.currSlide = H.startingSlide || 0;
    var B = H.startingSlide;
    Q.css({ position: "absolute", top: 0, left: 0 })
      .hide()
      .each(function (w) {
        var S;
        if (H.backwards) {
          S = B ? (w <= B ? z.length + (w - B) : B - w) : z.length - w;
        } else {
          S = B ? (w >= B ? z.length - (w - B) : B - w) : z.length - w;
        }
        c(this).css("z-index", S);
      });
    c(z[B]).css("opacity", 1).show();
    e(z[B], H);
    if (H.fit) {
      if (!H.aspect) {
        if (H.width) {
          Q.width(H.width);
        }
        if (H.height && H.height != "auto") {
          Q.height(H.height);
        }
      } else {
        Q.each(function () {
          var S = c(this);
          var w = H.aspect === true ? S.width() / S.height() : H.aspect;
          if (H.width && S.width() != H.width) {
            S.width(H.width);
            S.height(H.width / w);
          }
          if (H.height && S.height() < H.height) {
            S.height(H.height);
            S.width(H.height * w);
          }
        });
      }
    }
    if (H.center && (!H.fit || H.aspect)) {
      Q.each(function () {
        var w = c(this);
        w.css({
          "margin-left": H.width ? (H.width - w.width()) / 2 + "px" : 0,
          "margin-top": H.height ? (H.height - w.height()) / 2 + "px" : 0,
        });
      });
    }
    if (H.center && !H.fit && !H.slideResize) {
      Q.each(function () {
        var w = c(this);
        w.css({
          "margin-left": H.width ? (H.width - w.width()) / 2 + "px" : 0,
          "margin-top": H.height ? (H.height - w.height()) / 2 + "px" : 0,
        });
      });
    }
    var I = (H.containerResize || H.containerResizeHeight) && !C.innerHeight();
    if (I) {
      var A = 0,
        G = 0;
      for (var L = 0; L < z.length; L++) {
        var t = c(z[L]),
          R = t[0],
          E = t.outerWidth(),
          P = t.outerHeight();
        if (!E) {
          E = R.offsetWidth || R.width || t.attr("width");
        }
        if (!P) {
          P = R.offsetHeight || R.height || t.attr("height");
        }
        A = E > A ? E : A;
        G = P > G ? P : G;
      }
      if (H.containerResize && A > 0 && G > 0) {
        C.css({ width: A + "px", height: G + "px" });
      }
      if (H.containerResizeHeight && G > 0) {
        C.css({ height: G + "px" });
      }
    }
    var x = false;
    if (H.pause) {
      C.bind("mouseenter.cycle", function () {
        x = true;
        this.cyclePause++;
        k(u, true);
      }).bind("mouseleave.cycle", function () {
        if (x) {
          this.cyclePause--;
        }
        k(u, true);
      });
    }
    if (o(H) === false) {
      return false;
    }
    var v = false;
    y.requeueAttempts = y.requeueAttempts || 0;
    Q.each(function () {
      var U = c(this);
      this.cycleH =
        H.fit && H.height
          ? H.height
          : U.height() ||
            this.offsetHeight ||
            this.height ||
            U.attr("height") ||
            0;
      this.cycleW =
        H.fit && H.width
          ? H.width
          : U.width() || this.offsetWidth || this.width || U.attr("width") || 0;
      if (U.is("img")) {
        var S =
          c.browser.msie &&
          this.cycleW == 28 &&
          this.cycleH == 30 &&
          !this.complete;
        var V =
          c.browser.mozilla &&
          this.cycleW == 34 &&
          this.cycleH == 19 &&
          !this.complete;
        var T =
          c.browser.opera &&
          ((this.cycleW == 42 && this.cycleH == 19) ||
            (this.cycleW == 37 && this.cycleH == 17)) &&
          !this.complete;
        var w = this.cycleH === 0 && this.cycleW === 0 && !this.complete;
        if (S || V || T || w) {
          if (J.s && H.requeueOnImageNotLoaded && ++y.requeueAttempts < 100) {
            f(
              y.requeueAttempts,
              " - img slide not loaded, requeuing slideshow: ",
              this.src,
              this.cycleW,
              this.cycleH
            );
            setTimeout(function () {
              c(J.s, J.c).cycle(y);
            }, H.requeueTimeout);
            v = true;
            return false;
          } else {
            f(
              "could not determine size of image: " + this.src,
              this.cycleW,
              this.cycleH
            );
          }
        }
      }
      return true;
    });
    if (v) {
      return false;
    }
    H.cssBefore = H.cssBefore || {};
    H.cssAfter = H.cssAfter || {};
    H.cssFirst = H.cssFirst || {};
    H.animIn = H.animIn || {};
    H.animOut = H.animOut || {};
    Q.not(":eq(" + B + ")").css(H.cssBefore);
    c(Q[B]).css(H.cssFirst);
    if (H.timeout) {
      H.timeout = parseInt(H.timeout, 10);
      if (H.speed.constructor == String) {
        H.speed = c.fx.speeds[H.speed] || parseInt(H.speed, 10);
      }
      if (!H.sync) {
        H.speed = H.speed / 2;
      }
      var K = H.fx == "none" ? 0 : H.fx == "shuffle" ? 500 : 250;
      while (H.timeout - H.speed < K) {
        H.timeout += H.speed;
      }
    }
    if (H.easing) {
      H.easeIn = H.easeOut = H.easing;
    }
    if (!H.speedIn) {
      H.speedIn = H.speed;
    }
    if (!H.speedOut) {
      H.speedOut = H.speed;
    }
    H.slideCount = z.length;
    H.currSlide = H.lastSlide = B;
    if (H.random) {
      if (++H.randomIndex == z.length) {
        H.randomIndex = 0;
      }
      H.nextSlide = H.randomMap[H.randomIndex];
    } else {
      if (H.backwards) {
        H.nextSlide =
          H.startingSlide === 0 ? z.length - 1 : H.startingSlide - 1;
      } else {
        H.nextSlide = H.startingSlide >= z.length - 1 ? 0 : H.startingSlide + 1;
      }
    }
    if (!H.multiFx) {
      var N = c.fn.cycle.transitions[H.fx];
      if (c.isFunction(N)) {
        N(C, Q, H);
      } else {
        if (H.fx != "custom" && !H.multiFx) {
          f("unknown transition: " + H.fx, "; slideshow terminating");
          return false;
        }
      }
    }
    var D = Q[B];
    if (!H.skipInitializationCallbacks) {
      if (H.before.length) {
        H.before[0].apply(D, [D, D, H, true]);
      }
      if (H.after.length) {
        H.after[0].apply(D, [D, D, H, true]);
      }
    }
    if (H.next) {
      c(H.next).bind(H.prevNextEvent, function () {
        return h(H, 1);
      });
    }
    if (H.prev) {
      c(H.prev).bind(H.prevNextEvent, function () {
        return h(H, 0);
      });
    }
    if (H.pager || H.pagerAnchorBuilder) {
      p(z, H);
    }
    j(H, z);
    return H;
  }
  function i(s) {
    s.original = { before: [], after: [] };
    s.original.cssBefore = c.extend({}, s.cssBefore);
    s.original.cssAfter = c.extend({}, s.cssAfter);
    s.original.animIn = c.extend({}, s.animIn);
    s.original.animOut = c.extend({}, s.animOut);
    c.each(s.before, function () {
      s.original.before.push(this);
    });
    c.each(s.after, function () {
      s.original.after.push(this);
    });
  }
  function o(y) {
    var w,
      u,
      t = c.fn.cycle.transitions;
    if (y.fx.indexOf(",") > 0) {
      y.multiFx = true;
      y.fxs = y.fx.replace(/\s*/g, "").split(",");
      for (w = 0; w < y.fxs.length; w++) {
        var x = y.fxs[w];
        u = t[x];
        if (!u || !t.hasOwnProperty(x) || !c.isFunction(u)) {
          f("discarding unknown transition: ", x);
          y.fxs.splice(w, 1);
          w--;
        }
      }
      if (!y.fxs.length) {
        f("No valid transitions named; slideshow terminating.");
        return false;
      }
    } else {
      if (y.fx == "all") {
        y.multiFx = true;
        y.fxs = [];
        for (var z in t) {
          if (t.hasOwnProperty(z)) {
            u = t[z];
            if (t.hasOwnProperty(z) && c.isFunction(u)) {
              y.fxs.push(z);
            }
          }
        }
      }
    }
    if (y.multiFx && y.randomizeEffects) {
      var v = Math.floor(Math.random() * 20) + 30;
      for (w = 0; w < v; w++) {
        var s = Math.floor(Math.random() * y.fxs.length);
        y.fxs.push(y.fxs.splice(s, 1)[0]);
      }
      g("randomized fx sequence: ", y.fxs);
    }
    return true;
  }
  function j(t, s) {
    t.addSlide = function (v, w) {
      var u = c(v),
        x = u[0];
      if (!t.autostopCount) {
        t.countdown++;
      }
      s[w ? "unshift" : "push"](x);
      if (t.els) {
        t.els[w ? "unshift" : "push"](x);
      }
      t.slideCount = s.length;
      if (t.random) {
        t.randomMap.push(t.slideCount - 1);
        t.randomMap.sort(function (z, y) {
          return Math.random() - 0.5;
        });
      }
      u.css("position", "absolute");
      u[w ? "prependTo" : "appendTo"](t.$cont);
      if (w) {
        t.currSlide++;
        t.nextSlide++;
      }
      if (!c.support.opacity && t.cleartype && !t.cleartypeNoBg) {
        a(u);
      }
      if (t.fit && t.width) {
        u.width(t.width);
      }
      if (t.fit && t.height && t.height != "auto") {
        u.height(t.height);
      }
      x.cycleH = t.fit && t.height ? t.height : u.height();
      x.cycleW = t.fit && t.width ? t.width : u.width();
      u.css(t.cssBefore);
      if (t.pager || t.pagerAnchorBuilder) {
        c.fn.cycle.createPagerAnchor(s.length - 1, x, c(t.pager), s, t);
      }
      if (c.isFunction(t.onAddSlide)) {
        t.onAddSlide(u);
      } else {
        u.hide();
      }
    };
  }
  c.fn.cycle.resetState = function (t, s) {
    s = s || t.fx;
    t.before = [];
    t.after = [];
    t.cssBefore = c.extend({}, t.original.cssBefore);
    t.cssAfter = c.extend({}, t.original.cssAfter);
    t.animIn = c.extend({}, t.original.animIn);
    t.animOut = c.extend({}, t.original.animOut);
    t.fxFn = null;
    c.each(t.original.before, function () {
      t.before.push(this);
    });
    c.each(t.original.after, function () {
      t.after.push(this);
    });
    var u = c.fn.cycle.transitions[s];
    if (c.isFunction(u)) {
      u(t.$cont, c(t.elements), t);
    }
  };
  function n(y, s, x, A) {
    var v = s.$cont[0],
      D = y[s.currSlide],
      B = y[s.nextSlide];
    if (x && s.busy && s.manualTrump) {
      g("manualTrump in go(), stopping active transition");
      c(y).stop(true, true);
      s.busy = 0;
      clearTimeout(v.cycleTimeout);
    }
    if (s.busy) {
      g("transition active, ignoring new tx request");
      return;
    }
    if (v.cycleStop != s.stopCount || (v.cycleTimeout === 0 && !x)) {
      return;
    }
    if (
      !x &&
      !v.cyclePause &&
      !s.bounce &&
      ((s.autostop && --s.countdown <= 0) ||
        (s.nowrap && !s.random && s.nextSlide < s.currSlide))
    ) {
      if (s.end) {
        s.end(s);
      }
      return;
    }
    var z = false;
    if ((x || !v.cyclePause) && s.nextSlide != s.currSlide) {
      z = true;
      var w = s.fx;
      D.cycleH = D.cycleH || c(D).height();
      D.cycleW = D.cycleW || c(D).width();
      B.cycleH = B.cycleH || c(B).height();
      B.cycleW = B.cycleW || c(B).width();
      if (s.multiFx) {
        if (A && (s.lastFx === d || ++s.lastFx >= s.fxs.length)) {
          s.lastFx = 0;
        } else {
          if (!A && (s.lastFx === d || --s.lastFx < 0)) {
            s.lastFx = s.fxs.length - 1;
          }
        }
        w = s.fxs[s.lastFx];
      }
      if (s.oneTimeFx) {
        w = s.oneTimeFx;
        s.oneTimeFx = null;
      }
      c.fn.cycle.resetState(s, w);
      if (s.before.length) {
        c.each(s.before, function (E, F) {
          if (v.cycleStop != s.stopCount) {
            return;
          }
          F.apply(B, [D, B, s, A]);
        });
      }
      var t = function () {
        s.busy = 0;
        c.each(s.after, function (E, F) {
          if (v.cycleStop != s.stopCount) {
            return;
          }
          F.apply(B, [D, B, s, A]);
        });
        if (!v.cycleStop) {
          C();
        }
      };
      g(
        "tx firing(" +
          w +
          "); currSlide: " +
          s.currSlide +
          "; nextSlide: " +
          s.nextSlide
      );
      s.busy = 1;
      if (s.fxFn) {
        s.fxFn(D, B, s, t, A, x && s.fastOnEvent);
      } else {
        if (c.isFunction(c.fn.cycle[s.fx])) {
          c.fn.cycle[s.fx](D, B, s, t, A, x && s.fastOnEvent);
        } else {
          c.fn.cycle.custom(D, B, s, t, A, x && s.fastOnEvent);
        }
      }
    } else {
      C();
    }
    if (z || s.nextSlide == s.currSlide) {
      var u;
      s.lastSlide = s.currSlide;
      if (s.random) {
        s.currSlide = s.nextSlide;
        if (++s.randomIndex == y.length) {
          s.randomIndex = 0;
          s.randomMap.sort(function (F, E) {
            return Math.random() - 0.5;
          });
        }
        s.nextSlide = s.randomMap[s.randomIndex];
        if (s.nextSlide == s.currSlide) {
          s.nextSlide = s.currSlide == s.slideCount - 1 ? 0 : s.currSlide + 1;
        }
      } else {
        if (s.backwards) {
          u = s.nextSlide - 1 < 0;
          if (u && s.bounce) {
            s.backwards = !s.backwards;
            s.nextSlide = 1;
            s.currSlide = 0;
          } else {
            s.nextSlide = u ? y.length - 1 : s.nextSlide - 1;
            s.currSlide = u ? 0 : s.nextSlide + 1;
          }
        } else {
          u = s.nextSlide + 1 == y.length;
          if (u && s.bounce) {
            s.backwards = !s.backwards;
            s.nextSlide = y.length - 2;
            s.currSlide = y.length - 1;
          } else {
            s.nextSlide = u ? 0 : s.nextSlide + 1;
            s.currSlide = u ? y.length - 1 : s.nextSlide - 1;
          }
        }
      }
    }
    if (z && s.pager) {
      s.updateActivePagerLink(s.pager, s.currSlide, s.activePagerClass);
    }
    function C() {
      var E = 0,
        F = s.timeout;
      if (s.timeout && !s.continuous) {
        E = m(y[s.currSlide], y[s.nextSlide], s, A);
        if (s.fx == "shuffle") {
          E -= s.speedOut;
        }
      } else {
        if (s.continuous && v.cyclePause) {
          E = 10;
        }
      }
      if (E > 0) {
        v.cycleTimeout = setTimeout(function () {
          n(y, s, 0, !s.backwards);
        }, E);
      }
    }
  }
  c.fn.cycle.updateActivePagerLink = function (s, u, t) {
    c(s).each(function () {
      c(this).children().removeClass(t).eq(u).addClass(t);
    });
  };
  function m(x, v, w, u) {
    if (w.timeoutFn) {
      var s = w.timeoutFn.call(x, x, v, w, u);
      while (w.fx != "none" && s - w.speed < 250) {
        s += w.speed;
      }
      g("calculated timeout: " + s + "; speed: " + w.speed);
      if (s !== false) {
        return s;
      }
    }
    return w.timeout;
  }
  c.fn.cycle.next = function (s) {
    h(s, 1);
  };
  c.fn.cycle.prev = function (s) {
    h(s, 0);
  };
  function h(v, u) {
    var y = u ? 1 : -1;
    var t = v.elements;
    var x = v.$cont[0],
      w = x.cycleTimeout;
    if (w) {
      clearTimeout(w);
      x.cycleTimeout = 0;
    }
    if (v.random && y < 0) {
      v.randomIndex--;
      if (--v.randomIndex == -2) {
        v.randomIndex = t.length - 2;
      } else {
        if (v.randomIndex == -1) {
          v.randomIndex = t.length - 1;
        }
      }
      v.nextSlide = v.randomMap[v.randomIndex];
    } else {
      if (v.random) {
        v.nextSlide = v.randomMap[v.randomIndex];
      } else {
        v.nextSlide = v.currSlide + y;
        if (v.nextSlide < 0) {
          if (v.nowrap) {
            return false;
          }
          v.nextSlide = t.length - 1;
        } else {
          if (v.nextSlide >= t.length) {
            if (v.nowrap) {
              return false;
            }
            v.nextSlide = 0;
          }
        }
      }
    }
    var s = v.onPrevNextEvent || v.prevNextClick;
    if (c.isFunction(s)) {
      s(y > 0, v.nextSlide, t[v.nextSlide]);
    }
    n(t, v, 1, u);
    return false;
  }
  function p(t, u) {
    var s = c(u.pager);
    c.each(t, function (v, w) {
      c.fn.cycle.createPagerAnchor(v, w, s, t, u);
    });
    u.updateActivePagerLink(u.pager, u.startingSlide, u.activePagerClass);
  }
  c.fn.cycle.createPagerAnchor = function (x, u, z, w, t) {
    var A;
    if (c.isFunction(t.pagerAnchorBuilder)) {
      A = t.pagerAnchorBuilder(x, u);
      g("pagerAnchorBuilder(" + x + ", el) returned: " + A);
    } else {
      A = '<a href="#">' + (x + 1) + "</a>";
    }
    if (!A) {
      return;
    }
    var v = c(A);
    if (v.parents("body").length === 0) {
      var y = [];
      if (z.length > 1) {
        z.each(function () {
          var D = v.clone(true);
          c(this).append(D);
          y.push(D[0]);
        });
        v = c(y);
      } else {
        v.appendTo(z);
      }
    }
    t.pagerAnchors = t.pagerAnchors || [];
    t.pagerAnchors.push(v);
    var B = function (G) {
      G.preventDefault();
      t.nextSlide = x;
      var F = t.$cont[0],
        E = F.cycleTimeout;
      if (E) {
        clearTimeout(E);
        F.cycleTimeout = 0;
      }
      var D = t.onPagerEvent || t.pagerClick;
      if (c.isFunction(D)) {
        D(t.nextSlide, w[t.nextSlide]);
      }
      n(w, t, 1, t.currSlide < x);
    };
    if (/mouseenter|mouseover/i.test(t.pagerEvent)) {
      v.hover(B, function () {});
    } else {
      v.bind(t.pagerEvent, B);
    }
    if (!/^click/.test(t.pagerEvent) && !t.allowPagerClickBubble) {
      v.bind("click.cycle", function () {
        return false;
      });
    }
    var C = t.$cont[0];
    var s = false;
    if (t.pauseOnPagerHover) {
      v.hover(
        function () {
          s = true;
          C.cyclePause++;
          k(C, true, true);
        },
        function () {
          if (s) {
            C.cyclePause--;
          }
          k(C, true, true);
        }
      );
    }
  };
  c.fn.cycle.hopsFromLast = function (v, u) {
    var t,
      s = v.lastSlide,
      w = v.currSlide;
    if (u) {
      t = w > s ? w - s : v.slideCount - s;
    } else {
      t = w < s ? s - w : s + v.slideCount - w;
    }
    return t;
  };
  function a(u) {
    g("applying clearType background-color hack");
    function t(v) {
      v = parseInt(v, 10).toString(16);
      return v.length < 2 ? "0" + v : v;
    }
    function s(y) {
      for (; y && y.nodeName.toLowerCase() != "html"; y = y.parentNode) {
        var w = c.css(y, "background-color");
        if (w && w.indexOf("rgb") >= 0) {
          var x = w.match(/\d+/g);
          return "#" + t(x[0]) + t(x[1]) + t(x[2]);
        }
        if (w && w != "transparent") {
          return w;
        }
      }
      return "#ffffff";
    }
    u.each(function () {
      c(this).css("background-color", s(this));
    });
  }
  c.fn.cycle.commonReset = function (y, v, x, t, u, s) {
    c(x.elements).not(y).hide();
    if (typeof x.cssBefore.opacity == "undefined") {
      x.cssBefore.opacity = 1;
    }
    x.cssBefore.display = "block";
    if (x.slideResize && t !== false && v.cycleW > 0) {
      x.cssBefore.width = v.cycleW;
    }
    if (x.slideResize && u !== false && v.cycleH > 0) {
      x.cssBefore.height = v.cycleH;
    }
    x.cssAfter = x.cssAfter || {};
    x.cssAfter.display = "none";
    c(y).css("zIndex", x.slideCount + (s === true ? 1 : 0));
    c(v).css("zIndex", x.slideCount + (s === true ? 0 : 1));
  };
  c.fn.cycle.custom = function (E, y, s, v, x, t) {
    var D = c(E),
      z = c(y);
    var u = s.speedIn,
      C = s.speedOut,
      w = s.easeIn,
      B = s.easeOut;
    z.css(s.cssBefore);
    if (t) {
      if (typeof t == "number") {
        u = C = t;
      } else {
        u = C = 1;
      }
      w = B = null;
    }
    var A = function () {
      z.animate(s.animIn, u, w, function () {
        v();
      });
    };
    D.animate(s.animOut, C, B, function () {
      D.css(s.cssAfter);
      if (!s.sync) {
        A();
      }
    });
    if (s.sync) {
      A();
    }
  };
  c.fn.cycle.transitions = {
    fade: function (t, u, s) {
      u.not(":eq(" + s.currSlide + ")").css("opacity", 0);
      s.before.push(function (x, v, w) {
        c.fn.cycle.commonReset(x, v, w);
        w.cssBefore.opacity = 0;
      });
      s.animIn = { opacity: 1 };
      s.animOut = { opacity: 0 };
      s.cssBefore = { top: 0, left: 0 };
    },
  };
  c.fn.cycle.ver = function () {
    return b;
  };
  c.fn.cycle.defaults = {
    activePagerClass: "activeSlide",
    after: null,
    allowPagerClickBubble: false,
    animIn: null,
    animOut: null,
    aspect: false,
    autostop: 0,
    autostopCount: 0,
    backwards: false,
    before: null,
    center: null,
    cleartype: !c.support.opacity,
    cleartypeNoBg: false,
    containerResize: 1,
    containerResizeHeight: 0,
    continuous: 0,
    cssAfter: null,
    cssBefore: null,
    delay: 0,
    easeIn: null,
    easeOut: null,
    easing: null,
    end: null,
    fastOnEvent: 0,
    fit: 0,
    fx: "fade",
    fxFn: null,
    height: "auto",
    manualTrump: true,
    metaAttr: "cycle",
    next: null,
    nowrap: 0,
    onPagerEvent: null,
    onPrevNextEvent: null,
    pager: null,
    pagerAnchorBuilder: null,
    pagerEvent: "click.cycle",
    pause: 0,
    pauseOnPagerHover: 0,
    prev: null,
    prevNextEvent: "click.cycle",
    random: 0,
    randomizeEffects: 1,
    requeueOnImageNotLoaded: true,
    requeueTimeout: 250,
    rev: 0,
    shuffle: null,
    skipInitializationCallbacks: false,
    slideExpr: null,
    slideResize: 1,
    speed: 1000,
    speedIn: null,
    speedOut: null,
    startingSlide: d,
    sync: 1,
    timeout: 4000,
    timeoutFn: null,
    updateActivePagerLink: null,
    width: null,
  };
})(jQuery);
(function (a) {
  a.fn.cycle.transitions.none = function (c, d, b) {
    b.fxFn = function (g, e, f, h) {
      a(e).show();
      a(g).hide();
      h();
    };
  };
  a.fn.cycle.transitions.fadeout = function (c, d, b) {
    d.not(":eq(" + b.currSlide + ")").css({ display: "block", opacity: 1 });
    b.before.push(function (k, i, j, f, g, e) {
      a(k).css("zIndex", j.slideCount + (e !== true ? 1 : 0));
      a(i).css("zIndex", j.slideCount + (e !== true ? 0 : 1));
    });
    b.animIn.opacity = 1;
    b.animOut.opacity = 0;
    b.cssBefore.opacity = 1;
    b.cssBefore.display = "block";
    b.cssAfter.zIndex = 0;
  };
  a.fn.cycle.transitions.scrollUp = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.height();
    c.cssBefore.top = b;
    c.cssBefore.left = 0;
    c.cssFirst.top = 0;
    c.animIn.top = 0;
    c.animOut.top = -b;
  };
  a.fn.cycle.transitions.scrollDown = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.height();
    c.cssFirst.top = 0;
    c.cssBefore.top = -b;
    c.cssBefore.left = 0;
    c.animIn.top = 0;
    c.animOut.top = b;
  };
  a.fn.cycle.transitions.scrollLeft = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.width();
    c.cssFirst.left = 0;
    c.cssBefore.left = b;
    c.cssBefore.top = 0;
    c.animIn.left = 0;
    c.animOut.left = 0 - b;
  };
  a.fn.cycle.transitions.scrollRight = function (d, e, c) {
    d.css("overflow", "hidden");
    c.before.push(a.fn.cycle.commonReset);
    var b = d.width();
    c.cssFirst.left = 0;
    c.cssBefore.left = -b;
    c.cssBefore.top = 0;
    c.animIn.left = 0;
    c.animOut.left = b;
  };
  a.fn.cycle.transitions.scrollHorz = function (c, d, b) {
    c.css("overflow", "hidden").width();
    b.before.push(function (h, f, g, e) {
      if (g.rev) {
        e = !e;
      }
      a.fn.cycle.commonReset(h, f, g);
      g.cssBefore.left = e ? f.cycleW - 1 : 1 - f.cycleW;
      g.animOut.left = e ? -h.cycleW : h.cycleW;
    });
    b.cssFirst.left = 0;
    b.cssBefore.top = 0;
    b.animIn.left = 0;
    b.animOut.top = 0;
  };
  a.fn.cycle.transitions.scrollVert = function (c, d, b) {
    c.css("overflow", "hidden");
    b.before.push(function (h, f, g, e) {
      if (g.rev) {
        e = !e;
      }
      a.fn.cycle.commonReset(h, f, g);
      g.cssBefore.top = e ? 1 - f.cycleH : f.cycleH - 1;
      g.animOut.top = e ? h.cycleH : -h.cycleH;
    });
    b.cssFirst.top = 0;
    b.cssBefore.left = 0;
    b.animIn.top = 0;
    b.animOut.left = 0;
  };
  a.fn.cycle.transitions.slideX = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a(f.elements).not(g).hide();
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.animIn.width = e.cycleW;
    });
    b.cssBefore.left = 0;
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
    b.animIn.width = "show";
    b.animOut.width = 0;
  };
  a.fn.cycle.transitions.slideY = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a(f.elements).not(g).hide();
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.animIn.height = e.cycleH;
    });
    b.cssBefore.left = 0;
    b.cssBefore.top = 0;
    b.cssBefore.height = 0;
    b.animIn.height = "show";
    b.animOut.height = 0;
  };
  a.fn.cycle.transitions.shuffle = function (e, f, d) {
    var c,
      b = e.css("overflow", "visible").width();
    f.css({ left: 0, top: 0 });
    d.before.push(function (i, g, h) {
      a.fn.cycle.commonReset(i, g, h, true, true, true);
    });
    if (!d.speedAdjusted) {
      d.speed = d.speed / 2;
      d.speedAdjusted = true;
    }
    d.random = 0;
    d.shuffle = d.shuffle || { left: -b, top: 15 };
    d.els = [];
    for (c = 0; c < f.length; c++) {
      d.els.push(f[c]);
    }
    for (c = 0; c < d.currSlide; c++) {
      d.els.push(d.els.shift());
    }
    d.fxFn = function (m, j, l, g, i) {
      if (l.rev) {
        i = !i;
      }
      var h = i ? a(m) : a(j);
      a(j).css(l.cssBefore);
      var k = l.slideCount;
      h.animate(l.shuffle, l.speedIn, l.easeIn, function () {
        var o = a.fn.cycle.hopsFromLast(l, i);
        for (var p = 0; p < o; p++) {
          if (i) {
            l.els.push(l.els.shift());
          } else {
            l.els.unshift(l.els.pop());
          }
        }
        if (i) {
          for (var q = 0, n = l.els.length; q < n; q++) {
            a(l.els[q]).css("z-index", n - q + k);
          }
        } else {
          var r = a(m).css("z-index");
          h.css("z-index", parseInt(r, 10) + 1 + k);
        }
        h.animate({ left: 0, top: 0 }, l.speedOut, l.easeOut, function () {
          a(i ? this : m).hide();
          if (g) {
            g();
          }
        });
      });
    };
    a.extend(d.cssBefore, { display: "block", opacity: 1, top: 0, left: 0 });
  };
  a.fn.cycle.transitions.turnUp = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.cssBefore.top = e.cycleH;
      f.animIn.height = e.cycleH;
      f.animOut.width = e.cycleW;
    });
    b.cssFirst.top = 0;
    b.cssBefore.left = 0;
    b.cssBefore.height = 0;
    b.animIn.top = 0;
    b.animOut.height = 0;
  };
  a.fn.cycle.transitions.turnDown = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.animIn.height = e.cycleH;
      f.animOut.top = g.cycleH;
    });
    b.cssFirst.top = 0;
    b.cssBefore.left = 0;
    b.cssBefore.top = 0;
    b.cssBefore.height = 0;
    b.animOut.height = 0;
  };
  a.fn.cycle.transitions.turnLeft = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.cssBefore.left = e.cycleW;
      f.animIn.width = e.cycleW;
    });
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
    b.animIn.left = 0;
    b.animOut.width = 0;
  };
  a.fn.cycle.transitions.turnRight = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.animIn.width = e.cycleW;
      f.animOut.left = g.cycleW;
    });
    a.extend(b.cssBefore, { top: 0, left: 0, width: 0 });
    b.animIn.left = 0;
    b.animOut.width = 0;
  };
  a.fn.cycle.transitions.zoom = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, false, true);
      f.cssBefore.top = e.cycleH / 2;
      f.cssBefore.left = e.cycleW / 2;
      a.extend(f.animIn, {
        top: 0,
        left: 0,
        width: e.cycleW,
        height: e.cycleH,
      });
      a.extend(f.animOut, {
        width: 0,
        height: 0,
        top: g.cycleH / 2,
        left: g.cycleW / 2,
      });
    });
    b.cssFirst.top = 0;
    b.cssFirst.left = 0;
    b.cssBefore.width = 0;
    b.cssBefore.height = 0;
  };
  a.fn.cycle.transitions.fadeZoom = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, false);
      f.cssBefore.left = e.cycleW / 2;
      f.cssBefore.top = e.cycleH / 2;
      a.extend(f.animIn, {
        top: 0,
        left: 0,
        width: e.cycleW,
        height: e.cycleH,
      });
    });
    b.cssBefore.width = 0;
    b.cssBefore.height = 0;
    b.animOut.opacity = 0;
  };
  a.fn.cycle.transitions.blindX = function (d, e, c) {
    var b = d.css("overflow", "hidden").width();
    c.before.push(function (h, f, g) {
      a.fn.cycle.commonReset(h, f, g);
      g.animIn.width = f.cycleW;
      g.animOut.left = h.cycleW;
    });
    c.cssBefore.left = b;
    c.cssBefore.top = 0;
    c.animIn.left = 0;
    c.animOut.left = b;
  };
  a.fn.cycle.transitions.blindY = function (d, e, c) {
    var b = d.css("overflow", "hidden").height();
    c.before.push(function (h, f, g) {
      a.fn.cycle.commonReset(h, f, g);
      g.animIn.height = f.cycleH;
      g.animOut.top = h.cycleH;
    });
    c.cssBefore.top = b;
    c.cssBefore.left = 0;
    c.animIn.top = 0;
    c.animOut.top = b;
  };
  a.fn.cycle.transitions.blindZ = function (e, f, d) {
    var c = e.css("overflow", "hidden").height();
    var b = e.width();
    d.before.push(function (i, g, h) {
      a.fn.cycle.commonReset(i, g, h);
      h.animIn.height = g.cycleH;
      h.animOut.top = i.cycleH;
    });
    d.cssBefore.top = c;
    d.cssBefore.left = b;
    d.animIn.top = 0;
    d.animIn.left = 0;
    d.animOut.top = c;
    d.animOut.left = b;
  };
  a.fn.cycle.transitions.growX = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true);
      f.cssBefore.left = this.cycleW / 2;
      f.animIn.left = 0;
      f.animIn.width = this.cycleW;
      f.animOut.left = 0;
    });
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
  };
  a.fn.cycle.transitions.growY = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false);
      f.cssBefore.top = this.cycleH / 2;
      f.animIn.top = 0;
      f.animIn.height = this.cycleH;
      f.animOut.top = 0;
    });
    b.cssBefore.height = 0;
    b.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.curtainX = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, false, true, true);
      f.cssBefore.left = e.cycleW / 2;
      f.animIn.left = 0;
      f.animIn.width = this.cycleW;
      f.animOut.left = g.cycleW / 2;
      f.animOut.width = 0;
    });
    b.cssBefore.top = 0;
    b.cssBefore.width = 0;
  };
  a.fn.cycle.transitions.curtainY = function (c, d, b) {
    b.before.push(function (g, e, f) {
      a.fn.cycle.commonReset(g, e, f, true, false, true);
      f.cssBefore.top = e.cycleH / 2;
      f.animIn.top = 0;
      f.animIn.height = e.cycleH;
      f.animOut.top = g.cycleH / 2;
      f.animOut.height = 0;
    });
    b.cssBefore.height = 0;
    b.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.cover = function (f, g, e) {
    var i = e.direction || "left";
    var b = f.css("overflow", "hidden").width();
    var c = f.height();
    e.before.push(function (j, d, h) {
      a.fn.cycle.commonReset(j, d, h);
      h.cssAfter.display = "";
      if (i == "right") {
        h.cssBefore.left = -b;
      } else {
        if (i == "up") {
          h.cssBefore.top = c;
        } else {
          if (i == "down") {
            h.cssBefore.top = -c;
          } else {
            h.cssBefore.left = b;
          }
        }
      }
    });
    e.animIn.left = 0;
    e.animIn.top = 0;
    e.cssBefore.top = 0;
    e.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.uncover = function (f, g, e) {
    var i = e.direction || "left";
    var b = f.css("overflow", "hidden").width();
    var c = f.height();
    e.before.push(function (j, d, h) {
      a.fn.cycle.commonReset(j, d, h, true, true, true);
      if (i == "right") {
        h.animOut.left = b;
      } else {
        if (i == "up") {
          h.animOut.top = -c;
        } else {
          if (i == "down") {
            h.animOut.top = c;
          } else {
            h.animOut.left = -b;
          }
        }
      }
    });
    e.animIn.left = 0;
    e.animIn.top = 0;
    e.cssBefore.top = 0;
    e.cssBefore.left = 0;
  };
  a.fn.cycle.transitions.toss = function (e, f, d) {
    var b = e.css("overflow", "visible").width();
    var c = e.height();
    d.before.push(function (i, g, h) {
      a.fn.cycle.commonReset(i, g, h, true, true, true);
      if (!h.animOut.left && !h.animOut.top) {
        a.extend(h.animOut, { left: b * 2, top: -c / 2, opacity: 0 });
      } else {
        h.animOut.opacity = 0;
      }
    });
    d.cssBefore.left = 0;
    d.cssBefore.top = 0;
    d.animIn.left = 0;
  };
  a.fn.cycle.transitions.wipe = function (q, m, e) {
    var p = q.css("overflow", "hidden").width();
    var j = q.height();
    e.cssBefore = e.cssBefore || {};
    var g;
    if (e.clip) {
      if (/l2r/.test(e.clip)) {
        g = "rect(0px 0px " + j + "px 0px)";
      } else {
        if (/r2l/.test(e.clip)) {
          g = "rect(0px " + p + "px " + j + "px " + p + "px)";
        } else {
          if (/t2b/.test(e.clip)) {
            g = "rect(0px " + p + "px 0px 0px)";
          } else {
            if (/b2t/.test(e.clip)) {
              g = "rect(" + j + "px " + p + "px " + j + "px 0px)";
            } else {
              if (/zoom/.test(e.clip)) {
                var o = parseInt(j / 2, 10);
                var f = parseInt(p / 2, 10);
                g = "rect(" + o + "px " + f + "px " + o + "px " + f + "px)";
              }
            }
          }
        }
      }
    }
    e.cssBefore.clip = e.cssBefore.clip || g || "rect(0px 0px 0px 0px)";
    var k = e.cssBefore.clip.match(/(\d+)/g);
    var s = parseInt(k[0], 10),
      c = parseInt(k[1], 10),
      n = parseInt(k[2], 10),
      i = parseInt(k[3], 10);
    e.before.push(function (v, h, t) {
      if (v == h) {
        return;
      }
      var d = a(v),
        b = a(h);
      a.fn.cycle.commonReset(v, h, t, true, true, false);
      t.cssAfter.display = "block";
      var r = 1,
        l = parseInt(t.speedIn / 13, 10) - 1;
      (function u() {
        var x = s ? s - parseInt(r * (s / l), 10) : 0;
        var y = i ? i - parseInt(r * (i / l), 10) : 0;
        var z = n < j ? n + parseInt(r * ((j - n) / l || 1), 10) : j;
        var w = c < p ? c + parseInt(r * ((p - c) / l || 1), 10) : p;
        b.css({
          clip: "rect(" + x + "px " + w + "px " + z + "px " + y + "px)",
        });
        r++ <= l ? setTimeout(u, 13) : d.css("display", "none");
      })();
    });
    a.extend(e.cssBefore, { display: "block", opacity: 1, top: 0, left: 0 });
    e.animIn = { left: 0 };
    e.animOut = { left: 0 };
  };
})(jQuery);
var is_rtl = $("body").hasClass("rtl");
// $(function () {
//   $(document).on(
//     "click",
//     ".brand-modal-wrapper, .feature-brand-block",
//     function (e) {
//       $(document).find(".brand-loader, .overlay-loader").show();
//       var $this = $(this),
//         href = $this.attr("data-remote") || $this.attr("href"),
//         $target = $($this.data("target"));
//       if (typeof ggoc !== "undefined" && ggoc != "") {
//         href = href + "?ggoc=" + ggoc;
//       }
//       if ($this.is("a")) {
//         e.preventDefault();
//       }
//       $target
//         .find(".modal-content")
//         .empty()
//         .html(
//           '<div class="brand-loader"><div class="loader"><img src="https://test.credencerewards.co.in/static/assets/imgs/pre-loader-white-bg.gif" /></div><div class="clearfix"></div></div>'
//         );
//       $(document).find(".overlay-loader").hide();
//       $target.modal();
//       $target.find(".modal-content").load(href, function () {
//         if (typeof GROUP_GIFT !== "undefined") {
//           pushTProductViewedGGEvent(
//             $(e.target).data("brand_name"),
//             $(e.target).data("code")
//           );
//         }
//         $(document).find(".brand-loader").hide();
//         if ($(e.target).attr("data-tab")) {
//           $(document)
//             .find(".brand-modal .nav a")
//             .eq($(e.target).data("tab"))
//             .click();
//         }
//       });
//     }
//   );
//   let pushTProductViewedGGEvent = function (productName, productID) {
//     let productViewedGGData = {
//       "Product Name": productName,
//       "Product ID": productID,
//       Category: currentCategory,
//       Language: siteLanguage,
//       Store: $(".search-block .countries-select")
//         .find("option:selected")
//         .data("country"),
//     };
//     clevertap.event.push(clevertap_events.productViewedGG, productViewedGGData);
//   };
// });
$(document).ready(function () {
  $(".brand-modal-wrapper").hover(
    function () {
      $(this).parent(".flip-container").find(".flipper").addClass("hovered");
    },
    function () {
      $(this).next(".flipper").removeClass("hovered");
    }
  );
  $(".gtm-see-all-brands").click(function () {
    $(".brand").show(function () {
      $(window).scroll();
    });
    $(this).hide();
  });
});
// $(document).on("click", ".brand-modal-wrapper", function () {
//   let productViewedData = {
//     "Image URL": $(this).data("brand_image"),
//     "Product Name": $(this).data("brand_name"),
//     "Product ID": $(this).data("code"),
//     Category: $(this).data("category"),
//     Language: siteLanguage,
//     Store: $("#countrySelect").find("option:selected").data("country"),
//     Platform: sitePlatform,
//   };
//   clevertap.event.push(clevertap_events.productViewed, productViewedData);
//   console.log("Clevertap Web productViewed event pushed");
// });
(function (window, document, undefined) {
  "use strict";
  function minErr(module, ErrorConstructor) {
    ErrorConstructor = ErrorConstructor || Error;
    return function () {
      var SKIP_INDEXES = 2;
      var templateArgs = arguments,
        code = templateArgs[0],
        message = "[" + (module ? module + ":" : "") + code + "] ",
        template = templateArgs[1],
        paramPrefix,
        i;
      message += template.replace(/\{\d+\}/g, function (match) {
        var index = +match.slice(1, -1),
          shiftedIndex = index + SKIP_INDEXES;
        if (shiftedIndex < templateArgs.length) {
          return toDebugString(templateArgs[shiftedIndex]);
        }
        return match;
      });
      message +=
        "\nhttp://errors.angularjs.org/1.4.14/" +
        (module ? module + "/" : "") +
        code;
      for (
        i = SKIP_INDEXES, paramPrefix = "?";
        i < templateArgs.length;
        i++, paramPrefix = "&"
      ) {
        message +=
          paramPrefix +
          "p" +
          (i - SKIP_INDEXES) +
          "=" +
          encodeURIComponent(toDebugString(templateArgs[i]));
      }
      return new ErrorConstructor(message);
    };
  }
  var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
  var VALIDITY_STATE_PROPERTY = "validity";
  var lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function (s) {
    return isString(s)
      ? s.replace(/[A-Z]/g, function (ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        })
      : s;
  };
  var manualUppercase = function (s) {
    return isString(s)
      ? s.replace(/[a-z]/g, function (ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        })
      : s;
  };
  if ("i" !== "I".toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie,
    jqLite,
    jQuery,
    slice = [].slice,
    splice = [].splice,
    push = [].push,
    toString = Object.prototype.toString,
    getPrototypeOf = Object.getPrototypeOf,
    ngMinErr = minErr("ng"),
    angular = window.angular || (window.angular = {}),
    angularModule,
    uid = 0;
  msie = document.documentMode;
  function isArrayLike(obj) {
    if (obj == null || isWindow(obj)) return false;
    if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
      return true;
    var length = "length" in Object(obj) && obj.length;
    return (
      isNumber(length) &&
      ((length >= 0 && (length - 1 in obj || obj instanceof Array)) ||
        typeof obj.item == "function")
    );
  }
  function forEach(obj, iterator, context) {
    var key, length;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (
            key != "prototype" &&
            key != "length" &&
            key != "name" &&
            (!obj.hasOwnProperty || obj.hasOwnProperty(key))
          ) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (isArray(obj) || isArrayLike(obj)) {
        var isPrimitive = typeof obj !== "object";
        for (key = 0, length = obj.length; key < length; key++) {
          if (isPrimitive || key in obj) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context, obj);
      } else if (isBlankObject(obj)) {
        for (key in obj) {
          iterator.call(context, obj[key], key, obj);
        }
      } else if (typeof obj.hasOwnProperty === "function") {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else {
        for (key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      }
    }
    return obj;
  }
  function forEachSorted(obj, iterator, context) {
    var keys = Object.keys(obj).sort();
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function (value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    return ++uid;
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function baseExtend(dst, objs, deep) {
    var h = dst.$$hashKey;
    for (var i = 0, ii = objs.length; i < ii; ++i) {
      var obj = objs[i];
      if (!isObject(obj) && !isFunction(obj)) continue;
      var keys = Object.keys(obj);
      for (var j = 0, jj = keys.length; j < jj; j++) {
        var key = keys[j];
        var src = obj[key];
        if (deep && isObject(src)) {
          if (isDate(src)) {
            dst[key] = new Date(src.valueOf());
          } else if (isRegExp(src)) {
            dst[key] = new RegExp(src);
          } else if (src.nodeName) {
            dst[key] = src.cloneNode(true);
          } else if (isElement(src)) {
            dst[key] = src.clone();
          } else {
            if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
            baseExtend(dst[key], [src], true);
          }
        } else {
          dst[key] = src;
        }
      }
    }
    setHashKey(dst, h);
    return dst;
  }
  function extend(dst) {
    return baseExtend(dst, slice.call(arguments, 1), false);
  }
  function merge(dst) {
    return baseExtend(dst, slice.call(arguments, 1), true);
  }
  function toInt(str) {
    return parseInt(str, 10);
  }
  function inherit(parent, extra) {
    return extend(Object.create(parent), extra);
  }
  function noop() {}
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function () {
      return value;
    };
  }
  function hasCustomToString(obj) {
    return isFunction(obj.toString) && obj.toString !== toString;
  }
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  function isDefined(value) {
    return typeof value !== "undefined";
  }
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  function isBlankObject(value) {
    return (
      value !== null && typeof value === "object" && !getPrototypeOf(value)
    );
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function isDate(value) {
    return toString.call(value) === "[object Date]";
  }
  var isArray = Array.isArray;
  function isFunction(value) {
    return typeof value === "function";
  }
  function isRegExp(value) {
    return toString.call(value) === "[object RegExp]";
  }
  function isWindow(obj) {
    return obj && obj.window === obj;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.call(obj) === "[object File]";
  }
  function isFormData(obj) {
    return toString.call(obj) === "[object FormData]";
  }
  function isBlob(obj) {
    return toString.call(obj) === "[object Blob]";
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isPromiseLike(obj) {
    return obj && isFunction(obj.then);
  }
  var TYPED_ARRAY_REGEXP =
    /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
  function isTypedArray(value) {
    return (
      value &&
      isNumber(value.length) &&
      TYPED_ARRAY_REGEXP.test(toString.call(value))
    );
  }
  var trim = function (value) {
    return isString(value) ? value.trim() : value;
  };
  var escapeForRegexp = function (s) {
    return s
      .replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1")
      .replace(/\x08/g, "\\x08");
  };
  function isElement(node) {
    return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
  }
  function makeMap(str) {
    var obj = {},
      items = str.split(","),
      i;
    for (i = 0; i < items.length; i++) {
      obj[items[i]] = true;
    }
    return obj;
  }
  function nodeName_(element) {
    return lowercase(element.nodeName || (element[0] && element[0].nodeName));
  }
  function includes(array, obj) {
    return Array.prototype.indexOf.call(array, obj) != -1;
  }
  function arrayRemove(array, value) {
    var index = array.indexOf(value);
    if (index >= 0) {
      array.splice(index, 1);
    }
    return index;
  }
  function copy(source, destination) {
    var stackSource = [];
    var stackDest = [];
    if (destination) {
      if (isTypedArray(destination)) {
        throw ngMinErr(
          "cpta",
          "Can't copy! TypedArray destination cannot be mutated."
        );
      }
      if (source === destination) {
        throw ngMinErr(
          "cpi",
          "Can't copy! Source and destination are identical."
        );
      }
      if (isArray(destination)) {
        destination.length = 0;
      } else {
        forEach(destination, function (value, key) {
          if (key !== "$$hashKey") {
            delete destination[key];
          }
        });
      }
      stackSource.push(source);
      stackDest.push(destination);
      return copyRecurse(source, destination);
    }
    return copyElement(source);
    function copyRecurse(source, destination) {
      var h = destination.$$hashKey;
      var result, key;
      if (isArray(source)) {
        for (var i = 0, ii = source.length; i < ii; i++) {
          destination.push(copyElement(source[i]));
        }
      } else if (isBlankObject(source)) {
        for (key in source) {
          destination[key] = copyElement(source[key]);
        }
      } else if (source && typeof source.hasOwnProperty === "function") {
        for (key in source) {
          if (source.hasOwnProperty(key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      } else {
        for (key in source) {
          if (hasOwnProperty.call(source, key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      }
      setHashKey(destination, h);
      return destination;
    }
    function copyElement(source) {
      if (!isObject(source)) {
        return source;
      }
      var index = stackSource.indexOf(source);
      if (index !== -1) {
        return stackDest[index];
      }
      if (isWindow(source) || isScope(source)) {
        throw ngMinErr(
          "cpws",
          "Can't copy! Making copies of Window or Scope instances is not supported."
        );
      }
      var needsRecurse = false;
      var destination;
      if (isArray(source)) {
        destination = [];
        needsRecurse = true;
      } else if (isTypedArray(source)) {
        destination = new source.constructor(source);
      } else if (isDate(source)) {
        destination = new Date(source.getTime());
      } else if (isRegExp(source)) {
        destination = new RegExp(
          source.source,
          source.toString().match(/[^\/]*$/)[0]
        );
        destination.lastIndex = source.lastIndex;
      } else if (isBlob(source)) {
        destination = new source.constructor([source], { type: source.type });
      } else if (isFunction(source.cloneNode)) {
        destination = source.cloneNode(true);
      } else {
        destination = Object.create(getPrototypeOf(source));
        needsRecurse = true;
      }
      stackSource.push(source);
      stackDest.push(destination);
      return needsRecurse ? copyRecurse(source, destination) : destination;
    }
  }
  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];
      for (var i = 0, ii = src.length; i < ii; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};
      for (var key in src) {
        if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
          dst[key] = src[key];
        }
      }
    }
    return dst || src;
  }
  function equals(o1, o2) {
    if (o1 === o2) return true;
    if (o1 === null || o2 === null) return false;
    if (o1 !== o1 && o2 !== o2) return true;
    var t1 = typeof o1,
      t2 = typeof o2,
      length,
      key,
      keySet;
    if (t1 == t2) {
      if (t1 == "object") {
        if (isArray(o1)) {
          if (!isArray(o2)) return false;
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++) {
              if (!equals(o1[key], o2[key])) return false;
            }
            return true;
          }
        } else if (isDate(o1)) {
          if (!isDate(o2)) return false;
          return equals(o1.getTime(), o2.getTime());
        } else if (isRegExp(o1)) {
          return isRegExp(o2) ? o1.toString() == o2.toString() : false;
        } else {
          if (
            isScope(o1) ||
            isScope(o2) ||
            isWindow(o1) ||
            isWindow(o2) ||
            isArray(o2) ||
            isDate(o2) ||
            isRegExp(o2)
          )
            return false;
          keySet = createMap();
          for (key in o1) {
            if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
            if (!equals(o1[key], o2[key])) return false;
            keySet[key] = true;
          }
          for (key in o2) {
            if (
              !(key in keySet) &&
              key.charAt(0) !== "$" &&
              isDefined(o2[key]) &&
              !isFunction(o2[key])
            )
              return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  var csp = function () {
    if (!isDefined(csp.rules)) {
      var ngCspElement =
        document.querySelector("[ng-csp]") ||
        document.querySelector("[data-ng-csp]");
      if (ngCspElement) {
        var ngCspAttribute =
          ngCspElement.getAttribute("ng-csp") ||
          ngCspElement.getAttribute("data-ng-csp");
        csp.rules = {
          noUnsafeEval:
            !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
          noInlineStyle:
            !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1,
        };
      } else {
        csp.rules = { noUnsafeEval: noUnsafeEval(), noInlineStyle: false };
      }
    }
    return csp.rules;
    function noUnsafeEval() {
      try {
        new Function("");
        return false;
      } catch (e) {
        return true;
      }
    }
  };
  var jq = function () {
    if (isDefined(jq.name_)) return jq.name_;
    var el;
    var i,
      ii = ngAttrPrefixes.length,
      prefix,
      name;
    for (i = 0; i < ii; ++i) {
      prefix = ngAttrPrefixes[i];
      if (
        (el = document.querySelector("[" + prefix.replace(":", "\\:") + "jq]"))
      ) {
        name = el.getAttribute(prefix + "jq");
        break;
      }
    }
    return (jq.name_ = name);
  };
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length
        ? function () {
            return arguments.length
              ? fn.apply(self, concat(curryArgs, arguments, 0))
              : fn.apply(self, curryArgs);
          }
        : function () {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (
      typeof key === "string" &&
      key.charAt(0) === "$" &&
      key.charAt(1) === "$"
    ) {
      val = undefined;
    } else if (isWindow(value)) {
      val = "$WINDOW";
    } else if (value && document === value) {
      val = "$DOCUMENT";
    } else if (isScope(value)) {
      val = "$SCOPE";
    }
    return val;
  }
  function toJson(obj, pretty) {
    if (isUndefined(obj)) return undefined;
    if (!isNumber(pretty)) {
      pretty = pretty ? 2 : null;
    }
    return JSON.stringify(obj, toJsonReplacer, pretty);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  var ALL_COLONS = /:/g;
  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(ALL_COLONS, "");
    var requestedTimezoneOffset =
      Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 60000;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }
  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }
  function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(
      date,
      reverse * (timezoneOffset - dateTimezoneOffset)
    );
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.empty();
    } catch (e) {}
    var elemHtml = jqLite("<div>").append(element).html();
    try {
      return element[0].nodeType === NODE_TYPE_TEXT
        ? lowercase(elemHtml)
        : elemHtml
            .match(/^(<[^>]+>)/)[1]
            .replace(/^<([\w\-]+)/, function (match, nodeName) {
              return "<" + lowercase(nodeName);
            });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function tryDecodeURIComponent(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {}
  }
  function parseKeyValue(keyValue) {
    var obj = {};
    forEach((keyValue || "").split("&"), function (keyValue) {
      var splitPoint, key, val;
      if (keyValue) {
        key = keyValue = keyValue.replace(/\+/g, "%20");
        splitPoint = keyValue.indexOf("=");
        if (splitPoint !== -1) {
          key = keyValue.substring(0, splitPoint);
          val = keyValue.substring(splitPoint + 1);
        }
        key = tryDecodeURIComponent(key);
        if (isDefined(key)) {
          val = isDefined(val) ? tryDecodeURIComponent(val) : true;
          if (!hasOwnProperty.call(obj, key)) {
            obj[key] = val;
          } else if (isArray(obj[key])) {
            obj[key].push(val);
          } else {
            obj[key] = [obj[key], val];
          }
        }
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
      if (isArray(value)) {
        forEach(value, function (arrayValue) {
          parts.push(
            encodeUriQuery(key, true) +
              (arrayValue === true
                ? ""
                : "=" + encodeUriQuery(arrayValue, true))
          );
        });
      } else {
        parts.push(
          encodeUriQuery(key, true) +
            (value === true ? "" : "=" + encodeUriQuery(value, true))
        );
      }
    });
    return parts.length ? parts.join("&") : "";
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true)
      .replace(/%26/gi, "&")
      .replace(/%3D/gi, "=")
      .replace(/%2B/gi, "+");
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val)
      .replace(/%40/gi, "@")
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%3B/gi, ";")
      .replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
  }
  var ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"];
  function getNgAttribute(element, ngAttr) {
    var attr,
      i,
      ii = ngAttrPrefixes.length;
    for (i = 0; i < ii; ++i) {
      attr = ngAttrPrefixes[i] + ngAttr;
      if (isString((attr = element.getAttribute(attr)))) {
        return attr;
      }
    }
    return null;
  }
  function angularInit(element, bootstrap) {
    var appElement,
      module,
      config = {};
    forEach(ngAttrPrefixes, function (prefix) {
      var name = prefix + "app";
      if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
        appElement = element;
        module = element.getAttribute(name);
      }
    });
    forEach(ngAttrPrefixes, function (prefix) {
      var name = prefix + "app";
      var candidate;
      if (
        !appElement &&
        (candidate = element.querySelector(
          "[" + name.replace(":", "\\:") + "]"
        ))
      ) {
        appElement = candidate;
        module = candidate.getAttribute(name);
      }
    });
    if (appElement) {
      config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
      bootstrap(appElement, module ? [module] : [], config);
    }
  }
  function bootstrap(element, modules, config) {
    if (!isObject(config)) config = {};
    var defaultConfig = { strictDi: false };
    config = extend(defaultConfig, config);
    var doBootstrap = function () {
      element = jqLite(element);
      if (element.injector()) {
        var tag = element[0] === document ? "document" : startingTag(element);
        throw ngMinErr(
          "btstrpd",
          "App already bootstrapped with this element '{0}'",
          tag.replace(/</, "&lt;").replace(/>/, "&gt;")
        );
      }
      modules = modules || [];
      modules.unshift([
        "$provide",
        function ($provide) {
          $provide.value("$rootElement", element);
        },
      ]);
      if (config.debugInfoEnabled) {
        modules.push([
          "$compileProvider",
          function ($compileProvider) {
            $compileProvider.debugInfoEnabled(true);
          },
        ]);
      }
      modules.unshift("ng");
      var injector = createInjector(modules, config.strictDi);
      injector.invoke([
        "$rootScope",
        "$rootElement",
        "$compile",
        "$injector",
        function bootstrapApply(scope, element, compile, injector) {
          scope.$apply(function () {
            element.data("$injector", injector);
            compile(element)(scope);
          });
        },
      ]);
      return injector;
    };
    var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
      config.debugInfoEnabled = true;
      window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
    }
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return doBootstrap();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
    angular.resumeBootstrap = function (extraModules) {
      forEach(extraModules, function (module) {
        modules.push(module);
      });
      return doBootstrap();
    };
    if (isFunction(angular.resumeDeferredBootstrap)) {
      angular.resumeDeferredBootstrap();
    }
  }
  function reloadWithDebugInfo() {
    window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
    window.location.reload();
  }
  function getTestability(rootElement) {
    var injector = angular.element(rootElement).injector();
    if (!injector) {
      throw ngMinErr(
        "test",
        "no injector found for element argument to getTestability"
      );
    }
    return injector.get("$$testability");
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || "_";
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
      return (pos ? separator : "") + letter.toLowerCase();
    });
  }
  var bindJQueryFired = false;
  var skipDestroyOnNextJQueryCleanData;
  function bindJQuery() {
    var originalCleanData;
    if (bindJQueryFired) {
      return;
    }
    var jqName = jq();
    jQuery = isUndefined(jqName)
      ? window.jQuery
      : !jqName
      ? undefined
      : window[jqName];
    if (jQuery && jQuery.fn.on) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        isolateScope: JQLitePrototype.isolateScope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData,
      });
      originalCleanData = jQuery.cleanData;
      jQuery.cleanData = function (elems) {
        var events;
        if (!skipDestroyOnNextJQueryCleanData) {
          for (var i = 0, elem; (elem = elems[i]) != null; i++) {
            events = jQuery._data(elem, "events");
            if (events && events.$destroy) {
              jQuery(elem).triggerHandler("$destroy");
            }
          }
        } else {
          skipDestroyOnNextJQueryCleanData = false;
        }
        originalCleanData(elems);
      };
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
    bindJQueryFired = true;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr(
        "areq",
        "Argument '{0}' is {1}",
        name || "?",
        reason || "required"
      );
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(
      isFunction(arg),
      name,
      "not a function, got " +
        (arg && typeof arg === "object"
          ? arg.constructor.name || "Object"
          : typeof arg)
    );
    return arg;
  }
  function assertNotHasOwnProperty(name, context) {
    if (name === "hasOwnProperty") {
      throw ngMinErr(
        "badname",
        "hasOwnProperty is not a valid {0} name",
        context
      );
    }
  }
  function getter(obj, path, bindFnToScope) {
    if (!path) return obj;
    var keys = path.split(".");
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  function getBlockNodes(nodes) {
    var node = nodes[0];
    var endNode = nodes[nodes.length - 1];
    var blockNodes;
    for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
      if (blockNodes || nodes[i] !== node) {
        if (!blockNodes) {
          blockNodes = jqLite(slice.call(nodes, 0, i));
        }
        blockNodes.push(node);
      }
    }
    return blockNodes || nodes;
  }
  function createMap() {
    return Object.create(null);
  }
  var NODE_TYPE_ELEMENT = 1;
  var NODE_TYPE_ATTRIBUTE = 2;
  var NODE_TYPE_TEXT = 3;
  var NODE_TYPE_COMMENT = 8;
  var NODE_TYPE_DOCUMENT = 9;
  var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
  function setupModuleLoader(window) {
    var $injectorMinErr = minErr("$injector");
    var ngMinErr = minErr("ng");
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    var angular = ensure(window, "angular", Object);
    angular.$$minErr = angular.$$minErr || minErr;
    return ensure(angular, "module", function () {
      var modules = {};
      return function module(name, requires, configFn) {
        var assertNotHasOwnProperty = function (name, context) {
          if (name === "hasOwnProperty") {
            throw ngMinErr(
              "badname",
              "hasOwnProperty is not a valid {0} name",
              context
            );
          }
        };
        assertNotHasOwnProperty(name, "module");
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function () {
          if (!requires) {
            throw $injectorMinErr(
              "nomod",
              "Module '{0}' is not available! You either misspelled " +
                "the module name or forgot to load it. If registering a module ensure that you " +
                "specify the dependencies as the second argument.",
              name
            );
          }
          var invokeQueue = [];
          var configBlocks = [];
          var runBlocks = [];
          var config = invokeLater("$injector", "invoke", "push", configBlocks);
          var moduleInstance = {
            _invokeQueue: invokeQueue,
            _configBlocks: configBlocks,
            _runBlocks: runBlocks,
            requires: requires,
            name: name,
            provider: invokeLaterAndSetModuleName("$provide", "provider"),
            factory: invokeLaterAndSetModuleName("$provide", "factory"),
            service: invokeLaterAndSetModuleName("$provide", "service"),
            value: invokeLater("$provide", "value"),
            constant: invokeLater("$provide", "constant", "unshift"),
            decorator: invokeLaterAndSetModuleName("$provide", "decorator"),
            animation: invokeLaterAndSetModuleName(
              "$animateProvider",
              "register"
            ),
            filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
            controller: invokeLaterAndSetModuleName(
              "$controllerProvider",
              "register"
            ),
            directive: invokeLaterAndSetModuleName(
              "$compileProvider",
              "directive"
            ),
            config: config,
            run: function (block) {
              runBlocks.push(block);
              return this;
            },
          };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod, queue) {
            if (!queue) queue = invokeQueue;
            return function () {
              queue[insertMethod || "push"]([provider, method, arguments]);
              return moduleInstance;
            };
          }
          function invokeLaterAndSetModuleName(provider, method) {
            return function (recipeName, factoryFunction) {
              if (factoryFunction && isFunction(factoryFunction))
                factoryFunction.$$moduleName = name;
              invokeQueue.push([provider, method, arguments]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  function serializeObject(obj) {
    var seen = [];
    return JSON.stringify(obj, function (key, val) {
      val = toJsonReplacer(key, val);
      if (isObject(val)) {
        if (seen.indexOf(val) >= 0) return "...";
        seen.push(val);
      }
      return val;
    });
  }
  function toDebugString(obj) {
    if (typeof obj === "function") {
      return obj.toString().replace(/ \{[\s\S]*$/, "");
    } else if (isUndefined(obj)) {
      return "undefined";
    } else if (typeof obj !== "string") {
      return serializeObject(obj);
    }
    return obj;
  }
  var version = {
    full: "1.4.14",
    major: 1,
    minor: 4,
    dot: 14,
    codeName: "material-distinction",
  };
  function publishExternalAPI(angular) {
    extend(angular, {
      bootstrap: bootstrap,
      copy: copy,
      extend: extend,
      merge: merge,
      equals: equals,
      element: jqLite,
      forEach: forEach,
      injector: createInjector,
      noop: noop,
      bind: bind,
      toJson: toJson,
      fromJson: fromJson,
      identity: identity,
      isUndefined: isUndefined,
      isDefined: isDefined,
      isString: isString,
      isFunction: isFunction,
      isObject: isObject,
      isNumber: isNumber,
      isElement: isElement,
      isArray: isArray,
      version: version,
      isDate: isDate,
      lowercase: lowercase,
      uppercase: uppercase,
      callbacks: { counter: 0 },
      getTestability: getTestability,
      $$minErr: minErr,
      $$csp: csp,
      reloadWithDebugInfo: reloadWithDebugInfo,
    });
    angularModule = setupModuleLoader(window);
    angularModule(
      "ng",
      ["ngLocale"],
      [
        "$provide",
        function ngModule($provide) {
          $provide.provider({ $$sanitizeUri: $$SanitizeUriProvider });
          $provide
            .provider("$compile", $CompileProvider)
            .directive({
              a: htmlAnchorDirective,
              input: inputDirective,
              textarea: inputDirective,
              form: formDirective,
              script: scriptDirective,
              select: selectDirective,
              style: styleDirective,
              option: optionDirective,
              ngBind: ngBindDirective,
              ngBindHtml: ngBindHtmlDirective,
              ngBindTemplate: ngBindTemplateDirective,
              ngClass: ngClassDirective,
              ngClassEven: ngClassEvenDirective,
              ngClassOdd: ngClassOddDirective,
              ngCloak: ngCloakDirective,
              ngController: ngControllerDirective,
              ngForm: ngFormDirective,
              ngHide: ngHideDirective,
              ngIf: ngIfDirective,
              ngInclude: ngIncludeDirective,
              ngInit: ngInitDirective,
              ngNonBindable: ngNonBindableDirective,
              ngPluralize: ngPluralizeDirective,
              ngRepeat: ngRepeatDirective,
              ngShow: ngShowDirective,
              ngStyle: ngStyleDirective,
              ngSwitch: ngSwitchDirective,
              ngSwitchWhen: ngSwitchWhenDirective,
              ngSwitchDefault: ngSwitchDefaultDirective,
              ngOptions: ngOptionsDirective,
              ngTransclude: ngTranscludeDirective,
              ngModel: ngModelDirective,
              ngList: ngListDirective,
              ngChange: ngChangeDirective,
              pattern: patternDirective,
              ngPattern: patternDirective,
              required: requiredDirective,
              ngRequired: requiredDirective,
              minlength: minlengthDirective,
              ngMinlength: minlengthDirective,
              maxlength: maxlengthDirective,
              ngMaxlength: maxlengthDirective,
              ngValue: ngValueDirective,
              ngModelOptions: ngModelOptionsDirective,
            })
            .directive({ ngInclude: ngIncludeFillContentDirective })
            .directive(ngAttributeAliasDirectives)
            .directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider,
          });
        },
      ]
    );
  }
  JQLite.expando = "ng339";
  var jqCache = (JQLite.cache = {}),
    jqId = 1,
    addEventListenerFn = function (element, type, fn) {
      element.addEventListener(type, fn, false);
    },
    removeEventListenerFn = function (element, type, fn) {
      element.removeEventListener(type, fn, false);
    };
  JQLite._data = function (node) {
    return this.cache[node[this.expando]] || {};
  };
  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var MOUSE_EVENT_MAP = { mouseleave: "mouseout", mouseenter: "mouseover" };
  var jqLiteMinErr = minErr("jqLite");
  function camelCase(name) {
    return name
      .replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
        return offset ? letter.toUpperCase() : letter;
      })
      .replace(MOZ_HACK_REGEXP, "Moz$1");
  }
  var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
  var HTML_REGEXP = /<|&#?\w+;/;
  var TAG_NAME_REGEXP = /<([\w:-]+)/;
  var XHTML_TAG_REGEXP =
    /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
  var wrapMap = {
    option: [1, '<select multiple="multiple">', "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""],
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody =
    wrapMap.tfoot =
    wrapMap.colgroup =
    wrapMap.caption =
      wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function jqLiteIsTextNode(html) {
    return !HTML_REGEXP.test(html);
  }
  function jqLiteAcceptsData(node) {
    var nodeType = node.nodeType;
    return (
      nodeType === NODE_TYPE_ELEMENT ||
      !nodeType ||
      nodeType === NODE_TYPE_DOCUMENT
    );
  }
  function jqLiteHasData(node) {
    for (var key in jqCache[node.ng339]) {
      return true;
    }
    return false;
  }
  function jqLiteBuildFragment(html, context) {
    var tmp,
      tag,
      wrap,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i;
    if (jqLiteIsTextNode(html)) {
      nodes.push(context.createTextNode(html));
    } else {
      tmp = tmp || fragment.appendChild(context.createElement("div"));
      tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
      wrap = wrapMap[tag] || wrapMap._default;
      tmp.innerHTML =
        wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
      i = wrap[0];
      while (i--) {
        tmp = tmp.lastChild;
      }
      nodes = concat(nodes, tmp.childNodes);
      tmp = fragment.firstChild;
      tmp.textContent = "";
    }
    fragment.textContent = "";
    fragment.innerHTML = "";
    forEach(nodes, function (node) {
      fragment.appendChild(node);
    });
    return fragment;
  }
  function jqLiteParseHTML(html, context) {
    context = context || document;
    var parsed;
    if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
      return [context.createElement(parsed[1])];
    }
    if ((parsed = jqLiteBuildFragment(html, context))) {
      return parsed.childNodes;
    }
    return [];
  }
  function jqLiteWrapNode(node, wrapper) {
    var parent = node.parentNode;
    if (parent) {
      parent.replaceChild(wrapper, node);
    }
    wrapper.appendChild(node);
  }
  var jqLiteContains =
    Node.prototype.contains ||
    function (arg) {
      return !!(this.compareDocumentPosition(arg) & 16);
    };
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    var argIsString;
    if (isString(element)) {
      element = trim(element);
      argIsString = true;
    }
    if (!(this instanceof JQLite)) {
      if (argIsString && element.charAt(0) != "<") {
        throw jqLiteMinErr(
          "nosel",
          "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element"
        );
      }
      return new JQLite(element);
    }
    if (argIsString) {
      jqLiteAddNodes(this, jqLiteParseHTML(element));
    } else {
      jqLiteAddNodes(this, element);
    }
  }
  function jqLiteClone(element) {
    return element.cloneNode(true);
  }
  function jqLiteDealoc(element, onlyDescendants) {
    if (!onlyDescendants) jqLiteRemoveData(element);
    if (element.querySelectorAll) {
      var descendants = element.querySelectorAll("*");
      for (var i = 0, l = descendants.length; i < l; i++) {
        jqLiteRemoveData(descendants[i]);
      }
    }
  }
  function jqLiteOff(element, type, fn, unsupported) {
    if (isDefined(unsupported))
      throw jqLiteMinErr(
        "offargs",
        "jqLite#off() does not support the `selector` argument"
      );
    var expandoStore = jqLiteExpandoStore(element);
    var events = expandoStore && expandoStore.events;
    var handle = expandoStore && expandoStore.handle;
    if (!handle) return;
    if (!type) {
      for (type in events) {
        if (type !== "$destroy") {
          removeEventListenerFn(element, type, handle);
        }
        delete events[type];
      }
    } else {
      var removeHandler = function (type) {
        var listenerFns = events[type];
        if (isDefined(fn)) {
          arrayRemove(listenerFns || [], fn);
        }
        if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
          removeEventListenerFn(element, type, handle);
          delete events[type];
        }
      };
      forEach(type.split(" "), function (type) {
        removeHandler(type);
        if (MOUSE_EVENT_MAP[type]) {
          removeHandler(MOUSE_EVENT_MAP[type]);
        }
      });
    }
  }
  function jqLiteRemoveData(element, name) {
    var expandoId = element.ng339;
    var expandoStore = expandoId && jqCache[expandoId];
    if (expandoStore) {
      if (name) {
        delete expandoStore.data[name];
        return;
      }
      if (expandoStore.handle) {
        if (expandoStore.events.$destroy) {
          expandoStore.handle({}, "$destroy");
        }
        jqLiteOff(element);
      }
      delete jqCache[expandoId];
      element.ng339 = undefined;
    }
  }
  function jqLiteExpandoStore(element, createIfNecessary) {
    var expandoId = element.ng339,
      expandoStore = expandoId && jqCache[expandoId];
    if (createIfNecessary && !expandoStore) {
      element.ng339 = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {
        events: {},
        data: {},
        handle: undefined,
      };
    }
    return expandoStore;
  }
  function jqLiteData(element, key, value) {
    if (jqLiteAcceptsData(element)) {
      var isSimpleSetter = isDefined(value);
      var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
      var massGetter = !key;
      var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
      var data = expandoStore && expandoStore.data;
      if (isSimpleSetter) {
        data[key] = value;
      } else {
        if (massGetter) {
          return data;
        } else {
          if (isSimpleGetter) {
            return data && data[key];
          } else {
            extend(data, key);
          }
        }
      }
    }
  }
  function jqLiteHasClass(element, selector) {
    if (!element.getAttribute) return false;
    return (
      (" " + (element.getAttribute("class") || "") + " ")
        .replace(/[\n\t]/g, " ")
        .indexOf(" " + selector + " ") > -1
    );
  }
  function jqLiteRemoveClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      forEach(cssClasses.split(" "), function (cssClass) {
        element.setAttribute(
          "class",
          trim(
            (" " + (element.getAttribute("class") || "") + " ")
              .replace(/[\n\t]/g, " ")
              .replace(" " + trim(cssClass) + " ", " ")
          )
        );
      });
    }
  }
  function jqLiteAddClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      var existingClasses = (
        " " +
        (element.getAttribute("class") || "") +
        " "
      ).replace(/[\n\t]/g, " ");
      forEach(cssClasses.split(" "), function (cssClass) {
        cssClass = trim(cssClass);
        if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
          existingClasses += cssClass + " ";
        }
      });
      element.setAttribute("class", trim(existingClasses));
    }
  }
  function jqLiteAddNodes(root, elements) {
    if (elements) {
      if (elements.nodeType) {
        root[root.length++] = elements;
      } else {
        var length = elements.length;
        if (typeof length === "number" && elements.window !== elements) {
          if (length) {
            for (var i = 0; i < length; i++) {
              root[root.length++] = elements[i];
            }
          }
        } else {
          root[root.length++] = elements;
        }
      }
    }
  }
  function jqLiteController(element, name) {
    return jqLiteInheritedData(
      element,
      "$" + (name || "ngController") + "Controller"
    );
  }
  function jqLiteInheritedData(element, name, value) {
    if (element.nodeType == NODE_TYPE_DOCUMENT) {
      element = element.documentElement;
    }
    var names = isArray(name) ? name : [name];
    while (element) {
      for (var i = 0, ii = names.length; i < ii; i++) {
        if (isDefined((value = jqLite.data(element, names[i])))) return value;
      }
      element =
        element.parentNode ||
        (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
    }
  }
  function jqLiteEmpty(element) {
    jqLiteDealoc(element, true);
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  function jqLiteRemove(element, keepData) {
    if (!keepData) jqLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  }
  function jqLiteDocumentLoaded(action, win) {
    win = win || window;
    if (win.document.readyState === "complete") {
      win.setTimeout(action);
    } else {
      jqLite(win).on("load", action);
    }
  }
  var JQLitePrototype = (JQLite.prototype = {
    ready: function (fn) {
      var fired = false;
      function trigger() {
        if (fired) return;
        fired = true;
        fn();
      }
      if (document.readyState === "complete") {
        setTimeout(trigger);
      } else {
        this.on("DOMContentLoaded", trigger);
        JQLite(window).on("load", trigger);
      }
    },
    toString: function () {
      var value = [];
      forEach(this, function (e) {
        value.push("" + e);
      });
      return "[" + value.join(", ") + "]";
    },
    eq: function (index) {
      return index >= 0
        ? jqLite(this[index])
        : jqLite(this[this.length + index]);
    },
    length: 0,
    push: push,
    sort: [].sort,
    splice: [].splice,
  });
  var BOOLEAN_ATTR = {};
  forEach(
    "multiple,selected,checked,disabled,readOnly,required,open".split(","),
    function (value) {
      BOOLEAN_ATTR[lowercase(value)] = value;
    }
  );
  var BOOLEAN_ELEMENTS = {};
  forEach(
    "input,select,option,textarea,button,form,details".split(","),
    function (value) {
      BOOLEAN_ELEMENTS[value] = true;
    }
  );
  var ALIASED_ATTR = {
    ngMinlength: "minlength",
    ngMaxlength: "maxlength",
    ngMin: "min",
    ngMax: "max",
    ngPattern: "pattern",
  };
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
  }
  function getAliasedAttrName(name) {
    return ALIASED_ATTR[name];
  }
  forEach(
    { data: jqLiteData, removeData: jqLiteRemoveData, hasData: jqLiteHasData },
    function (fn, name) {
      JQLite[name] = fn;
    }
  );
  forEach(
    {
      data: jqLiteData,
      inheritedData: jqLiteInheritedData,
      scope: function (element) {
        return (
          jqLite.data(element, "$scope") ||
          jqLiteInheritedData(element.parentNode || element, [
            "$isolateScope",
            "$scope",
          ])
        );
      },
      isolateScope: function (element) {
        return (
          jqLite.data(element, "$isolateScope") ||
          jqLite.data(element, "$isolateScopeNoTemplate")
        );
      },
      controller: jqLiteController,
      injector: function (element) {
        return jqLiteInheritedData(element, "$injector");
      },
      removeAttr: function (element, name) {
        element.removeAttribute(name);
      },
      hasClass: jqLiteHasClass,
      css: function (element, name, value) {
        name = camelCase(name);
        if (isDefined(value)) {
          element.style[name] = value;
        } else {
          return element.style[name];
        }
      },
      attr: function (element, name, value) {
        var nodeType = element.nodeType;
        if (
          nodeType === NODE_TYPE_TEXT ||
          nodeType === NODE_TYPE_ATTRIBUTE ||
          nodeType === NODE_TYPE_COMMENT
        ) {
          return;
        }
        var lowercasedName = lowercase(name);
        if (BOOLEAN_ATTR[lowercasedName]) {
          if (isDefined(value)) {
            if (!!value) {
              element[name] = true;
              element.setAttribute(name, lowercasedName);
            } else {
              element[name] = false;
              element.removeAttribute(lowercasedName);
            }
          } else {
            return element[name] ||
              (element.attributes.getNamedItem(name) || noop).specified
              ? lowercasedName
              : undefined;
          }
        } else if (isDefined(value)) {
          element.setAttribute(name, value);
        } else if (element.getAttribute) {
          var ret = element.getAttribute(name, 2);
          return ret === null ? undefined : ret;
        }
      },
      prop: function (element, name, value) {
        if (isDefined(value)) {
          element[name] = value;
        } else {
          return element[name];
        }
      },
      text: (function () {
        getText.$dv = "";
        return getText;
        function getText(element, value) {
          if (isUndefined(value)) {
            var nodeType = element.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT
              ? element.textContent
              : "";
          }
          element.textContent = value;
        }
      })(),
      val: function (element, value) {
        if (isUndefined(value)) {
          if (element.multiple && nodeName_(element) === "select") {
            var result = [];
            forEach(element.options, function (option) {
              if (option.selected) {
                result.push(option.value || option.text);
              }
            });
            return result.length === 0 ? null : result;
          }
          return element.value;
        }
        element.value = value;
      },
      html: function (element, value) {
        if (isUndefined(value)) {
          return element.innerHTML;
        }
        jqLiteDealoc(element, true);
        element.innerHTML = value;
      },
      empty: jqLiteEmpty,
    },
    function (fn, name) {
      JQLite.prototype[name] = function (arg1, arg2) {
        var i, key;
        var nodeCount = this.length;
        if (
          fn !== jqLiteEmpty &&
          isUndefined(
            fn.length == 2 && fn !== jqLiteHasClass && fn !== jqLiteController
              ? arg1
              : arg2
          )
        ) {
          if (isObject(arg1)) {
            for (i = 0; i < nodeCount; i++) {
              if (fn === jqLiteData) {
                fn(this[i], arg1);
              } else {
                for (key in arg1) {
                  fn(this[i], key, arg1[key]);
                }
              }
            }
            return this;
          } else {
            var value = fn.$dv;
            var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
            for (var j = 0; j < jj; j++) {
              var nodeValue = fn(this[j], arg1, arg2);
              value = value ? value + nodeValue : nodeValue;
            }
            return value;
          }
        } else {
          for (i = 0; i < nodeCount; i++) {
            fn(this[i], arg1, arg2);
          }
          return this;
        }
      };
    }
  );
  function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
      event.isDefaultPrevented = function () {
        return event.defaultPrevented;
      };
      var eventFns = events[type || event.type];
      var eventFnsLength = eventFns ? eventFns.length : 0;
      if (!eventFnsLength) return;
      if (isUndefined(event.immediatePropagationStopped)) {
        var originalStopImmediatePropagation = event.stopImmediatePropagation;
        event.stopImmediatePropagation = function () {
          event.immediatePropagationStopped = true;
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (originalStopImmediatePropagation) {
            originalStopImmediatePropagation.call(event);
          }
        };
      }
      event.isImmediatePropagationStopped = function () {
        return event.immediatePropagationStopped === true;
      };
      var handlerWrapper =
        eventFns.specialHandlerWrapper || defaultHandlerWrapper;
      if (eventFnsLength > 1) {
        eventFns = shallowCopy(eventFns);
      }
      for (var i = 0; i < eventFnsLength; i++) {
        if (!event.isImmediatePropagationStopped()) {
          handlerWrapper(element, event, eventFns[i]);
        }
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  function defaultHandlerWrapper(element, event, handler) {
    handler.call(element, event);
  }
  function specialMouseHandlerWrapper(target, event, handler) {
    var related = event.relatedTarget;
    if (
      !related ||
      (related !== target && !jqLiteContains.call(target, related))
    ) {
      handler.call(target, event);
    }
  }
  forEach(
    {
      removeData: jqLiteRemoveData,
      on: function jqLiteOn(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr(
            "onargs",
            "jqLite#on() does not support the `selector` or `eventData` parameters"
          );
        if (!jqLiteAcceptsData(element)) {
          return;
        }
        var expandoStore = jqLiteExpandoStore(element, true);
        var events = expandoStore.events;
        var handle = expandoStore.handle;
        if (!handle) {
          handle = expandoStore.handle = createEventHandler(element, events);
        }
        var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type];
        var i = types.length;
        var addHandler = function (
          type,
          specialHandlerWrapper,
          noEventListener
        ) {
          var eventFns = events[type];
          if (!eventFns) {
            eventFns = events[type] = [];
            eventFns.specialHandlerWrapper = specialHandlerWrapper;
            if (type !== "$destroy" && !noEventListener) {
              addEventListenerFn(element, type, handle);
            }
          }
          eventFns.push(fn);
        };
        while (i--) {
          type = types[i];
          if (MOUSE_EVENT_MAP[type]) {
            addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
            addHandler(type, undefined, true);
          } else {
            addHandler(type);
          }
        }
      },
      off: jqLiteOff,
      one: function (element, type, fn) {
        element = jqLite(element);
        element.on(type, function onFn() {
          element.off(type, fn);
          element.off(type, onFn);
        });
        element.on(type, fn);
      },
      replaceWith: function (element, replaceNode) {
        var index,
          parent = element.parentNode;
        jqLiteDealoc(element);
        forEach(new JQLite(replaceNode), function (node) {
          if (index) {
            parent.insertBefore(node, index.nextSibling);
          } else {
            parent.replaceChild(node, element);
          }
          index = node;
        });
      },
      children: function (element) {
        var children = [];
        forEach(element.childNodes, function (element) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            children.push(element);
          }
        });
        return children;
      },
      contents: function (element) {
        return element.contentDocument || element.childNodes || [];
      },
      append: function (element, node) {
        var nodeType = element.nodeType;
        if (
          nodeType !== NODE_TYPE_ELEMENT &&
          nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT
        )
          return;
        node = new JQLite(node);
        for (var i = 0, ii = node.length; i < ii; i++) {
          var child = node[i];
          element.appendChild(child);
        }
      },
      prepend: function (element, node) {
        if (element.nodeType === NODE_TYPE_ELEMENT) {
          var index = element.firstChild;
          forEach(new JQLite(node), function (child) {
            element.insertBefore(child, index);
          });
        }
      },
      wrap: function (element, wrapNode) {
        jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
      },
      remove: jqLiteRemove,
      detach: function (element) {
        jqLiteRemove(element, true);
      },
      after: function (element, newElement) {
        var index = element,
          parent = element.parentNode;
        newElement = new JQLite(newElement);
        for (var i = 0, ii = newElement.length; i < ii; i++) {
          var node = newElement[i];
          parent.insertBefore(node, index.nextSibling);
          index = node;
        }
      },
      addClass: jqLiteAddClass,
      removeClass: jqLiteRemoveClass,
      toggleClass: function (element, selector, condition) {
        if (selector) {
          forEach(selector.split(" "), function (className) {
            var classCondition = condition;
            if (isUndefined(classCondition)) {
              classCondition = !jqLiteHasClass(element, className);
            }
            (classCondition
              ? jqLiteAddClass
              : jqLiteRemoveClass)(element, className);
          });
        }
      },
      parent: function (element) {
        var parent = element.parentNode;
        return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT
          ? parent
          : null;
      },
      next: function (element) {
        return element.nextElementSibling;
      },
      find: function (element, selector) {
        if (element.getElementsByTagName) {
          return element.getElementsByTagName(selector);
        } else {
          return [];
        }
      },
      clone: jqLiteClone,
      triggerHandler: function (element, event, extraParameters) {
        var dummyEvent, eventFnsCopy, handlerArgs;
        var eventName = event.type || event;
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var eventFns = events && events[eventName];
        if (eventFns) {
          dummyEvent = {
            preventDefault: function () {
              this.defaultPrevented = true;
            },
            isDefaultPrevented: function () {
              return this.defaultPrevented === true;
            },
            stopImmediatePropagation: function () {
              this.immediatePropagationStopped = true;
            },
            isImmediatePropagationStopped: function () {
              return this.immediatePropagationStopped === true;
            },
            stopPropagation: noop,
            type: eventName,
            target: element,
          };
          if (event.type) {
            dummyEvent = extend(dummyEvent, event);
          }
          eventFnsCopy = shallowCopy(eventFns);
          handlerArgs = extraParameters
            ? [dummyEvent].concat(extraParameters)
            : [dummyEvent];
          forEach(eventFnsCopy, function (fn) {
            if (!dummyEvent.isImmediatePropagationStopped()) {
              fn.apply(element, handlerArgs);
            }
          });
        }
      },
    },
    function (fn, name) {
      JQLite.prototype[name] = function (arg1, arg2, arg3) {
        var value;
        for (var i = 0, ii = this.length; i < ii; i++) {
          if (isUndefined(value)) {
            value = fn(this[i], arg1, arg2, arg3);
            if (isDefined(value)) {
              value = jqLite(value);
            }
          } else {
            jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
          }
        }
        return isDefined(value) ? value : this;
      };
      JQLite.prototype.bind = JQLite.prototype.on;
      JQLite.prototype.unbind = JQLite.prototype.off;
    }
  );
  function $$jqLiteProvider() {
    this.$get = function $$jqLite() {
      return extend(JQLite, {
        hasClass: function (node, classes) {
          if (node.attr) node = node[0];
          return jqLiteHasClass(node, classes);
        },
        addClass: function (node, classes) {
          if (node.attr) node = node[0];
          return jqLiteAddClass(node, classes);
        },
        removeClass: function (node, classes) {
          if (node.attr) node = node[0];
          return jqLiteRemoveClass(node, classes);
        },
      });
    };
  }
  function hashKey(obj, nextUidFn) {
    var key = obj && obj.$$hashKey;
    if (key) {
      if (typeof key === "function") {
        key = obj.$$hashKey();
      }
      return key;
    }
    var objType = typeof obj;
    if (objType == "function" || (objType == "object" && obj !== null)) {
      key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
    } else {
      key = objType + ":" + obj;
    }
    return key;
  }
  function HashMap(array, isolatedUid) {
    if (isolatedUid) {
      var uid = 0;
      this.nextUid = function () {
        return ++uid;
      };
    }
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function (key, value) {
      this[hashKey(key, this.nextUid)] = value;
    },
    get: function (key) {
      return this[hashKey(key, this.nextUid)];
    },
    remove: function (key) {
      var value = this[(key = hashKey(key, this.nextUid))];
      delete this[key];
      return value;
    },
  };
  var $$HashMapProvider = [
    function () {
      this.$get = [
        function () {
          return HashMap;
        },
      ];
    },
  ];
  var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  var $injectorMinErr = minErr("$injector");
  function anonFn(fn) {
    var fnText = fn.toString().replace(STRIP_COMMENTS, ""),
      args = fnText.match(FN_ARGS);
    if (args) {
      return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
    }
    return "fn";
  }
  function annotate(fn, strictDi, name) {
    var $inject, fnText, argDecl, last;
    if (typeof fn === "function") {
      if (!($inject = fn.$inject)) {
        $inject = [];
        if (fn.length) {
          if (strictDi) {
            if (!isString(name) || !name) {
              name = fn.name || anonFn(fn);
            }
            throw $injectorMinErr(
              "strictdi",
              "{0} is not using explicit annotation and cannot be invoked in strict mode",
              name
            );
          }
          fnText = fn.toString().replace(STRIP_COMMENTS, "");
          argDecl = fnText.match(FN_ARGS);
          forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
            arg.replace(FN_ARG, function (all, underscore, name) {
              $inject.push(name);
            });
          });
        }
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], "fn");
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, "fn", true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad, strictDi) {
    strictDi = strictDi === true;
    var INSTANTIATING = {},
      providerSuffix = "Provider",
      path = [],
      loadedModules = new HashMap([], true),
      providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator,
        },
      },
      providerInjector = (providerCache.$injector = createInternalInjector(
        providerCache,
        function (serviceName, caller) {
          if (angular.isString(caller)) {
            path.push(caller);
          }
          throw $injectorMinErr(
            "unpr",
            "Unknown provider: {0}",
            path.join(" <- ")
          );
        }
      )),
      instanceCache = {},
      instanceInjector = (instanceCache.$injector = createInternalInjector(
        instanceCache,
        function (serviceName, caller) {
          var provider = providerInjector.get(
            serviceName + providerSuffix,
            caller
          );
          return instanceInjector.invoke(
            provider.$get,
            provider,
            undefined,
            serviceName
          );
        }
      ));
    forEach(loadModules(modulesToLoad), function (fn) {
      if (fn) instanceInjector.invoke(fn);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function (key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      assertNotHasOwnProperty(name, "service");
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw $injectorMinErr(
          "pget",
          "Provider '{0}' must define $get factory method.",
          name
        );
      }
      return (providerCache[name + providerSuffix] = provider_);
    }
    function enforceReturnValue(name, factory) {
      return function enforcedReturnValue() {
        var result = instanceInjector.invoke(factory, this);
        if (isUndefined(result)) {
          throw $injectorMinErr(
            "undef",
            "Provider '{0}' must return a value from $get factory method.",
            name
          );
        }
        return result;
      };
    }
    function factory(name, factoryFn, enforce) {
      return provider(name, {
        $get:
          enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn,
      });
    }
    function service(name, constructor) {
      return factory(name, [
        "$injector",
        function ($injector) {
          return $injector.instantiate(constructor);
        },
      ]);
    }
    function value(name, val) {
      return factory(name, valueFn(val), false);
    }
    function constant(name, value) {
      assertNotHasOwnProperty(name, "constant");
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;
      origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, {
          $delegate: origInstance,
        });
      };
    }
    function loadModules(modulesToLoad) {
      assertArg(
        isUndefined(modulesToLoad) || isArray(modulesToLoad),
        "modulesToLoad",
        "not an array"
      );
      var runBlocks = [],
        moduleFn;
      forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module)) return;
        loadedModules.put(module, true);
        function runInvokeQueue(queue) {
          var i, ii;
          for (i = 0, ii = queue.length; i < ii; i++) {
            var invokeArgs = queue[i],
              provider = providerInjector.get(invokeArgs[0]);
            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        }
        try {
          if (isString(module)) {
            moduleFn = angularModule(module);
            runBlocks = runBlocks
              .concat(loadModules(moduleFn.requires))
              .concat(moduleFn._runBlocks);
            runInvokeQueue(moduleFn._invokeQueue);
            runInvokeQueue(moduleFn._configBlocks);
          } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else {
            assertArgFn(module, "module");
          }
        } catch (e) {
          if (isArray(module)) {
            module = module[module.length - 1];
          }
          if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
            e = e.message + "\n" + e.stack;
          }
          throw $injectorMinErr(
            "modulerr",
            "Failed to instantiate module {0} due to:\n{1}",
            module,
            e.stack || e.message || e
          );
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName, caller) {
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw $injectorMinErr(
              "cdep",
              "Circular dependency found: {0}",
              serviceName + " <- " + path.join(" <- ")
            );
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return (cache[serviceName] = factory(serviceName, caller));
          } catch (err) {
            if (cache[serviceName] === INSTANTIATING) {
              delete cache[serviceName];
            }
            throw err;
          } finally {
            path.shift();
          }
        }
      }
      function invoke(fn, self, locals, serviceName) {
        if (typeof locals === "string") {
          serviceName = locals;
          locals = null;
        }
        var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName),
          length,
          i,
          key;
        for (i = 0, length = $inject.length; i < length; i++) {
          key = $inject[i];
          if (typeof key !== "string") {
            throw $injectorMinErr(
              "itkn",
              "Incorrect injection token! Expected service name as string, got {0}",
              key
            );
          }
          args.push(
            locals && locals.hasOwnProperty(key)
              ? locals[key]
              : getService(key, serviceName)
          );
        }
        if (isArray(fn)) {
          fn = fn[length];
        }
        return fn.apply(self, args);
      }
      function instantiate(Type, locals, serviceName) {
        var instance = Object.create(
          (isArray(Type) ? Type[Type.length - 1] : Type).prototype || null
        );
        var returnedValue = invoke(Type, instance, locals, serviceName);
        return isObject(returnedValue) || isFunction(returnedValue)
          ? returnedValue
          : instance;
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: createInjector.$$annotate,
        has: function (name) {
          return (
            providerCache.hasOwnProperty(name + providerSuffix) ||
            cache.hasOwnProperty(name)
          );
        },
      };
    }
  }
  createInjector.$$annotate = annotate;
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
      autoScrollingEnabled = false;
    };
    this.$get = [
      "$window",
      "$location",
      "$rootScope",
      function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          Array.prototype.some.call(list, function (element) {
            if (nodeName_(element) === "a") {
              result = element;
              return true;
            }
          });
          return result;
        }
        function getYOffset() {
          var offset = scroll.yOffset;
          if (isFunction(offset)) {
            offset = offset();
          } else if (isElement(offset)) {
            var elem = offset[0];
            var style = $window.getComputedStyle(elem);
            if (style.position !== "fixed") {
              offset = 0;
            } else {
              offset = elem.getBoundingClientRect().bottom;
            }
          } else if (!isNumber(offset)) {
            offset = 0;
          }
          return offset;
        }
        function scrollTo(elem) {
          if (elem) {
            elem.scrollIntoView();
            var offset = getYOffset();
            if (offset) {
              var elemTop = elem.getBoundingClientRect().top;
              $window.scrollBy(0, elemTop - offset);
            }
          } else {
            $window.scrollTo(0, 0);
          }
        }
        function scroll(hash) {
          hash = isString(hash) ? hash : $location.hash();
          var elm;
          if (!hash) scrollTo(null);
          else if ((elm = document.getElementById(hash))) scrollTo(elm);
          else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
            scrollTo(elm);
          else if (hash === "top") scrollTo(null);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(
            function autoScrollWatch() {
              return $location.hash();
            },
            function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === "") return;
              jqLiteDocumentLoaded(function () {
                $rootScope.$evalAsync(scroll);
              });
            }
          );
        }
        return scroll;
      },
    ];
  }
  var $animateMinErr = minErr("$animate");
  var ELEMENT_NODE = 1;
  var NG_ANIMATE_CLASSNAME = "ng-animate";
  function mergeClasses(a, b) {
    if (!a && !b) return "";
    if (!a) return b;
    if (!b) return a;
    if (isArray(a)) a = a.join(" ");
    if (isArray(b)) b = b.join(" ");
    return a + " " + b;
  }
  function extractElementNode(element) {
    for (var i = 0; i < element.length; i++) {
      var elm = element[i];
      if (elm.nodeType === ELEMENT_NODE) {
        return elm;
      }
    }
  }
  function splitClasses(classes) {
    if (isString(classes)) {
      classes = classes.split(" ");
    }
    var obj = createMap();
    forEach(classes, function (klass) {
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }
  function prepareAnimateOptions(options) {
    return isObject(options) ? options : {};
  }
  var $$CoreAnimateJsProvider = function () {
    this.$get = function () {};
  };
  var $$CoreAnimateQueueProvider = function () {
    var postDigestQueue = new HashMap();
    var postDigestElements = [];
    this.$get = [
      "$$AnimateRunner",
      "$rootScope",
      function ($$AnimateRunner, $rootScope) {
        return {
          enabled: noop,
          on: noop,
          off: noop,
          pin: noop,
          push: function (element, event, options, domOperation) {
            domOperation && domOperation();
            options = options || {};
            options.from && element.css(options.from);
            options.to && element.css(options.to);
            if (options.addClass || options.removeClass) {
              addRemoveClassesPostDigest(
                element,
                options.addClass,
                options.removeClass
              );
            }
            var runner = new $$AnimateRunner();
            runner.complete();
            return runner;
          },
        };
        function updateData(data, classes, value) {
          var changed = false;
          if (classes) {
            classes = isString(classes)
              ? classes.split(" ")
              : isArray(classes)
              ? classes
              : [];
            forEach(classes, function (className) {
              if (className) {
                changed = true;
                data[className] = value;
              }
            });
          }
          return changed;
        }
        function handleCSSClassChanges() {
          forEach(postDigestElements, function (element) {
            var data = postDigestQueue.get(element);
            if (data) {
              var existing = splitClasses(element.attr("class"));
              var toAdd = "";
              var toRemove = "";
              forEach(data, function (status, className) {
                var hasClass = !!existing[className];
                if (status !== hasClass) {
                  if (status) {
                    toAdd += (toAdd.length ? " " : "") + className;
                  } else {
                    toRemove += (toRemove.length ? " " : "") + className;
                  }
                }
              });
              forEach(element, function (elm) {
                toAdd && jqLiteAddClass(elm, toAdd);
                toRemove && jqLiteRemoveClass(elm, toRemove);
              });
              postDigestQueue.remove(element);
            }
          });
          postDigestElements.length = 0;
        }
        function addRemoveClassesPostDigest(element, add, remove) {
          var data = postDigestQueue.get(element) || {};
          var classesAdded = updateData(data, add, true);
          var classesRemoved = updateData(data, remove, false);
          if (classesAdded || classesRemoved) {
            postDigestQueue.put(element, data);
            postDigestElements.push(element);
            if (postDigestElements.length === 1) {
              $rootScope.$$postDigest(handleCSSClassChanges);
            }
          }
        }
      },
    ];
  };
  var $AnimateProvider = [
    "$provide",
    function ($provide) {
      var provider = this;
      this.$$registeredAnimations = Object.create(null);
      this.register = function (name, factory) {
        if (name && name.charAt(0) !== ".") {
          throw $animateMinErr(
            "notcsel",
            "Expecting class selector starting with '.' got '{0}'.",
            name
          );
        }
        var key = name + "-animation";
        provider.$$registeredAnimations[name.substr(1)] = key;
        $provide.factory(key, factory);
      };
      this.classNameFilter = function (expression) {
        if (arguments.length === 1) {
          this.$$classNameFilter =
            expression instanceof RegExp ? expression : null;
          if (this.$$classNameFilter) {
            var reservedRegex = new RegExp(
              "(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)"
            );
            if (reservedRegex.test(this.$$classNameFilter.toString())) {
              throw $animateMinErr(
                "nongcls",
                '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.',
                NG_ANIMATE_CLASSNAME
              );
            }
          }
        }
        return this.$$classNameFilter;
      };
      this.$get = [
        "$$animateQueue",
        function ($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (
                afterNode &&
                !afterNode.parentNode &&
                !afterNode.previousElementSibling
              ) {
                afterElement = null;
              }
            }
            afterElement
              ? afterElement.after(element)
              : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function (runner) {
              runner.end && runner.end();
            },
            enter: function (element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(
                element,
                "enter",
                prepareAnimateOptions(options)
              );
            },
            move: function (element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(
                element,
                "move",
                prepareAnimateOptions(options)
              );
            },
            leave: function (element, options) {
              return $$animateQueue.push(
                element,
                "leave",
                prepareAnimateOptions(options),
                function () {
                  element.remove();
                }
              );
            },
            addClass: function (element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, "addClass", options);
            },
            removeClass: function (element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(
                options.removeClass,
                className
              );
              return $$animateQueue.push(element, "removeClass", options);
            },
            setClass: function (element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, "setClass", options);
            },
            animate: function (element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || "ng-inline-animate";
              options.tempClasses = mergeClasses(
                options.tempClasses,
                className
              );
              return $$animateQueue.push(element, "animate", options);
            },
          };
        },
      ];
    },
  ];
  var $$AnimateAsyncRunFactoryProvider = function () {
    this.$get = [
      "$$rAF",
      function ($$rAF) {
        var waitQueue = [];
        function waitForTick(fn) {
          waitQueue.push(fn);
          if (waitQueue.length > 1) return;
          $$rAF(function () {
            for (var i = 0; i < waitQueue.length; i++) {
              waitQueue[i]();
            }
            waitQueue = [];
          });
        }
        return function () {
          var passed = false;
          waitForTick(function () {
            passed = true;
          });
          return function (callback) {
            passed ? callback() : waitForTick(callback);
          };
        };
      },
    ];
  };
  var $$AnimateRunnerFactoryProvider = function () {
    this.$get = [
      "$q",
      "$sniffer",
      "$$animateAsyncRun",
      "$document",
      "$timeout",
      function ($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function (chain, callback) {
          var index = 0;
          next();
          function next() {
            if (index === chain.length) {
              callback(true);
              return;
            }
            chain[index](function (response) {
              if (response === false) {
                callback(false);
                return;
              }
              index++;
              next();
            });
          }
        };
        AnimateRunner.all = function (runners, callback) {
          var count = 0;
          var status = true;
          forEach(runners, function (runner) {
            runner.done(onProgress);
          });
          function onProgress(response) {
            status = status && response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        };
        function AnimateRunner(host) {
          this.setHost(host);
          var rafTick = $$animateAsyncRun();
          var timeoutTick = function (fn) {
            $timeout(fn, 0, false);
          };
          this._doneCallbacks = [];
          this._tick = function (fn) {
            var doc = $document[0];
            if (doc && doc.hidden) {
              timeoutTick(fn);
            } else {
              rafTick(fn);
            }
          };
          this._state = 0;
        }
        AnimateRunner.prototype = {
          setHost: function (host) {
            this.host = host || {};
          },
          done: function (fn) {
            if (this._state === DONE_COMPLETE_STATE) {
              fn();
            } else {
              this._doneCallbacks.push(fn);
            }
          },
          progress: noop,
          getPromise: function () {
            if (!this.promise) {
              var self = this;
              this.promise = $q(function (resolve, reject) {
                self.done(function (status) {
                  status === false ? reject() : resolve();
                });
              });
            }
            return this.promise;
          },
          then: function (resolveHandler, rejectHandler) {
            return this.getPromise().then(resolveHandler, rejectHandler);
          },
          catch: function (handler) {
            return this.getPromise()["catch"](handler);
          },
          finally: function (handler) {
            return this.getPromise()["finally"](handler);
          },
          pause: function () {
            if (this.host.pause) {
              this.host.pause();
            }
          },
          resume: function () {
            if (this.host.resume) {
              this.host.resume();
            }
          },
          end: function () {
            if (this.host.end) {
              this.host.end();
            }
            this._resolve(true);
          },
          cancel: function () {
            if (this.host.cancel) {
              this.host.cancel();
            }
            this._resolve(false);
          },
          complete: function (response) {
            var self = this;
            if (self._state === INITIAL_STATE) {
              self._state = DONE_PENDING_STATE;
              self._tick(function () {
                self._resolve(response);
              });
            }
          },
          _resolve: function (response) {
            if (this._state !== DONE_COMPLETE_STATE) {
              forEach(this._doneCallbacks, function (fn) {
                fn(response);
              });
              this._doneCallbacks.length = 0;
              this._state = DONE_COMPLETE_STATE;
            }
          },
        };
        return AnimateRunner;
      },
    ];
  };
  var $CoreAnimateCssProvider = function () {
    this.$get = [
      "$$rAF",
      "$q",
      "$$AnimateRunner",
      function ($$rAF, $q, $$AnimateRunner) {
        return function (element, initialOptions) {
          var options = initialOptions || {};
          if (!options.$$prepared) {
            options = copy(options);
          }
          if (options.cleanupStyles) {
            options.from = options.to = null;
          }
          if (options.from) {
            element.css(options.from);
            options.from = null;
          }
          var closed,
            runner = new $$AnimateRunner();
          return { start: run, end: run };
          function run() {
            $$rAF(function () {
              applyAnimationContents();
              if (!closed) {
                runner.complete();
              }
              closed = true;
            });
            return runner;
          }
          function applyAnimationContents() {
            if (options.addClass) {
              element.addClass(options.addClass);
              options.addClass = null;
            }
            if (options.removeClass) {
              element.removeClass(options.removeClass);
              options.removeClass = null;
            }
            if (options.to) {
              element.css(options.to);
              options.to = null;
            }
          }
        };
      },
    ];
  };
  function Browser(window, document, $log, $sniffer) {
    var self = this,
      rawDocument = document[0],
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    function getHash(url) {
      var index = url.indexOf("#");
      return index === -1 ? "" : url.substr(index);
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var cachedState,
      lastHistoryState,
      lastBrowserUrl = location.href,
      baseElement = document.find("base"),
      pendingLocation = null;
    cacheState();
    lastHistoryState = cachedState;
    self.url = function (url, replace, state) {
      if (isUndefined(state)) {
        state = null;
      }
      if (location !== window.location) location = window.location;
      if (history !== window.history) history = window.history;
      if (url) {
        var sameState = lastHistoryState === state;
        if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
          return self;
        }
        var sameBase =
          lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
        lastBrowserUrl = url;
        lastHistoryState = state;
        if ($sniffer.history && (!sameBase || !sameState)) {
          history[replace ? "replaceState" : "pushState"](state, "", url);
          cacheState();
          lastHistoryState = cachedState;
        } else {
          if (!sameBase || pendingLocation) {
            pendingLocation = url;
          }
          if (replace) {
            location.replace(url);
          } else if (!sameBase) {
            location.href = url;
          } else {
            location.hash = getHash(url);
          }
          if (location.href !== url) {
            pendingLocation = url;
          }
        }
        return self;
      } else {
        return pendingLocation || location.href.replace(/%27/g, "'");
      }
    };
    self.state = function () {
      return cachedState;
    };
    var urlChangeListeners = [],
      urlChangeInit = false;
    function cacheStateAndFireUrlChange() {
      pendingLocation = null;
      cacheState();
      fireUrlChange();
    }
    function getCurrentState() {
      try {
        return history.state;
      } catch (e) {}
    }
    var lastCachedState = null;
    function cacheState() {
      cachedState = getCurrentState();
      cachedState = isUndefined(cachedState) ? null : cachedState;
      if (equals(cachedState, lastCachedState)) {
        cachedState = lastCachedState;
      }
      lastCachedState = cachedState;
    }
    function fireUrlChange() {
      if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
        return;
      }
      lastBrowserUrl = self.url();
      lastHistoryState = cachedState;
      forEach(urlChangeListeners, function (listener) {
        listener(self.url(), cachedState);
      });
    }
    self.onUrlChange = function (callback) {
      if (!urlChangeInit) {
        if ($sniffer.history)
          jqLite(window).on("popstate", cacheStateAndFireUrlChange);
        jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.$$applicationDestroyed = function () {
      jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
    };
    self.$$checkUrlChange = fireUrlChange;
    self.baseHref = function () {
      var href = baseElement.attr("href");
      return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
    };
    self.defer = function (fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function (deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [
      "$window",
      "$log",
      "$sniffer",
      "$document",
      function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      },
    ];
  }
  function $CacheFactoryProvider() {
    this.$get = function () {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw minErr("$cacheFactory")(
            "iid",
            "CacheId '{0}' is already taken!",
            cacheId
          );
        }
        var size = 0,
          stats = extend({}, options, { id: cacheId }),
          data = createMap(),
          capacity = (options && options.capacity) || Number.MAX_VALUE,
          lruHash = createMap(),
          freshEnd = null,
          staleEnd = null;
        return (caches[cacheId] = {
          put: function (key, value) {
            if (isUndefined(value)) return;
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
              refresh(lruEntry);
            }
            if (!(key in data)) size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
            return value;
          },
          get: function (key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              refresh(lruEntry);
            }
            return data[key];
          },
          remove: function (key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              if (lruEntry == freshEnd) freshEnd = lruEntry.p;
              if (lruEntry == staleEnd) staleEnd = lruEntry.n;
              link(lruEntry.n, lruEntry.p);
              delete lruHash[key];
            }
            if (!(key in data)) return;
            delete data[key];
            size--;
          },
          removeAll: function () {
            data = createMap();
            size = 0;
            lruHash = createMap();
            freshEnd = staleEnd = null;
          },
          destroy: function () {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function () {
            return extend({}, stats, { size: size });
          },
        });
        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry) nextEntry.p = prevEntry;
            if (prevEntry) prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function (cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [
      "$cacheFactory",
      function ($cacheFactory) {
        return $cacheFactory("templates");
      },
    ];
  }
  var $compileMinErr = minErr("$compile");
  $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
  function $CompileProvider($provide, $$sanitizeUriProvider) {
    var hasDirectives = {},
      Suffix = "Directive",
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
      ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"),
      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
    var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
    var bindingCache = createMap();
    function parseIsolateBindings(scope, directiveName, isController) {
      var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
      var bindings = createMap();
      forEach(scope, function (definition, scopeName) {
        if (definition in bindingCache) {
          bindings[scopeName] = bindingCache[definition];
          return;
        }
        var match = definition.match(LOCAL_REGEXP);
        if (!match) {
          throw $compileMinErr(
            "iscp",
            "Invalid {3} for directive '{0}'." +
              " Definition: {... {1}: '{2}' ...}",
            directiveName,
            scopeName,
            definition,
            isController
              ? "controller bindings definition"
              : "isolate scope definition"
          );
        }
        bindings[scopeName] = {
          mode: match[1][0],
          collection: match[2] === "*",
          optional: match[3] === "?",
          attrName: match[4] || scopeName,
        };
        if (match[4]) {
          bindingCache[definition] = bindings[scopeName];
        }
      });
      return bindings;
    }
    function parseDirectiveBindings(directive, directiveName) {
      var bindings = { isolateScope: null, bindToController: null };
      if (isObject(directive.scope)) {
        if (directive.bindToController === true) {
          bindings.bindToController = parseIsolateBindings(
            directive.scope,
            directiveName,
            true
          );
          bindings.isolateScope = {};
        } else {
          bindings.isolateScope = parseIsolateBindings(
            directive.scope,
            directiveName,
            false
          );
        }
      }
      if (isObject(directive.bindToController)) {
        bindings.bindToController = parseIsolateBindings(
          directive.bindToController,
          directiveName,
          true
        );
      }
      if (isObject(bindings.bindToController)) {
        var controller = directive.controller;
        var controllerAs = directive.controllerAs;
        if (!controller) {
          throw $compileMinErr(
            "noctrl",
            "Cannot bind to controller without directive '{0}'s controller.",
            directiveName
          );
        } else if (!identifierForController(controller, controllerAs)) {
          throw $compileMinErr(
            "noident",
            "Cannot bind to controller without identifier for directive '{0}'.",
            directiveName
          );
        }
      }
      return bindings;
    }
    function assertValidDirectiveName(name) {
      var letter = name.charAt(0);
      if (!letter || letter !== lowercase(letter)) {
        throw $compileMinErr(
          "baddir",
          "Directive name '{0}' is invalid. The first character must be a lowercase letter",
          name
        );
      }
      if (name !== name.trim()) {
        throw $compileMinErr(
          "baddir",
          "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
          name
        );
      }
    }
    this.directive = function registerDirective(name, directiveFactory) {
      assertNotHasOwnProperty(name, "directive");
      if (isString(name)) {
        assertValidDirectiveName(name);
        assertArg(directiveFactory, "directiveFactory");
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [
            "$injector",
            "$exceptionHandler",
            function ($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function (directiveFactory, index) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = { compile: valueFn(directive) };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.index = index;
                  directive.name = directive.name || name;
                  directive.require =
                    directive.require ||
                    (directive.controller && directive.name);
                  directive.restrict = directive.restrict || "EA";
                  directive.$$moduleName = directiveFactory.$$moduleName;
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            },
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.aHrefSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
      }
    };
    this.imgSrcSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
      }
    };
    var debugInfoEnabled = true;
    this.debugInfoEnabled = function (enabled) {
      if (isDefined(enabled)) {
        debugInfoEnabled = enabled;
        return this;
      }
      return debugInfoEnabled;
    };
    this.$get = [
      "$injector",
      "$interpolate",
      "$exceptionHandler",
      "$templateRequest",
      "$parse",
      "$controller",
      "$rootScope",
      "$sce",
      "$animate",
      "$$sanitizeUri",
      function (
        $injector,
        $interpolate,
        $exceptionHandler,
        $templateRequest,
        $parse,
        $controller,
        $rootScope,
        $sce,
        $animate,
        $$sanitizeUri
      ) {
        var Attributes = function (element, attributesToCopy) {
          if (attributesToCopy) {
            var keys = Object.keys(attributesToCopy);
            var i, l, key;
            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              this[key] = attributesToCopy[key];
            }
          } else {
            this.$attr = {};
          }
          this.$$element = element;
        };
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $addClass: function (classVal) {
            if (classVal && classVal.length > 0) {
              $animate.addClass(this.$$element, classVal);
            }
          },
          $removeClass: function (classVal) {
            if (classVal && classVal.length > 0) {
              $animate.removeClass(this.$$element, classVal);
            }
          },
          $updateClass: function (newClasses, oldClasses) {
            var toAdd = tokenDifference(newClasses, oldClasses);
            if (toAdd && toAdd.length) {
              $animate.addClass(this.$$element, toAdd);
            }
            var toRemove = tokenDifference(oldClasses, newClasses);
            if (toRemove && toRemove.length) {
              $animate.removeClass(this.$$element, toRemove);
            }
          },
          $set: function (key, value, writeAttr, attrName) {
            var node = this.$$element[0],
              booleanKey = getBooleanAttrName(node, key),
              aliasedKey = getAliasedAttrName(key),
              observer = key,
              nodeName;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            } else if (aliasedKey) {
              this[aliasedKey] = value;
              observer = aliasedKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, "-");
              }
            }
            nodeName = nodeName_(this.$$element);
            if (
              (nodeName === "a" && key === "href") ||
              (nodeName === "img" && key === "src")
            ) {
              this[key] = value = $$sanitizeUri(value, key === "src");
            } else if (
              nodeName === "img" &&
              key === "srcset" &&
              isDefined(value)
            ) {
              var result = "";
              var trimmedSrcset = trim(value);
              var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
              var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
              var rawUris = trimmedSrcset.split(pattern);
              var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
              for (var i = 0; i < nbrUrisWith2parts; i++) {
                var innerIdx = i * 2;
                result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                result += " " + trim(rawUris[innerIdx + 1]);
              }
              var lastTuple = trim(rawUris[i * 2]).split(/\s/);
              result += $$sanitizeUri(trim(lastTuple[0]), true);
              if (lastTuple.length === 2) {
                result += " " + trim(lastTuple[1]);
              }
              this[key] = value = result;
            }
            if (writeAttr !== false) {
              if (value === null || isUndefined(value)) {
                this.$$element.removeAttr(attrName);
              } else {
                this.$$element.attr(attrName, value);
              }
            }
            var $$observers = this.$$observers;
            $$observers &&
              forEach($$observers[observer], function (fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
          },
          $observe: function (key, fn) {
            var attrs = this,
              $$observers =
                attrs.$$observers || (attrs.$$observers = createMap()),
              listeners = $$observers[key] || ($$observers[key] = []);
            listeners.push(fn);
            $rootScope.$evalAsync(function () {
              if (
                !listeners.$$inter &&
                attrs.hasOwnProperty(key) &&
                !isUndefined(attrs[key])
              ) {
                fn(attrs[key]);
              }
            });
            return function () {
              arrayRemove(listeners, fn);
            };
          },
        };
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {}
        }
        var startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          denormalizeTemplate =
            startSymbol == "{{" && endSymbol == "}}"
              ? identity
              : function denormalizeTemplate(template) {
                  return template
                    .replace(/\{\{/g, startSymbol)
                    .replace(/}}/g, endSymbol);
                },
          NG_ATTR_BINDING = /^ngAttr[A-Z]/;
        var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
        compile.$$addBindingInfo = debugInfoEnabled
          ? function $$addBindingInfo($element, binding) {
              var bindings = $element.data("$binding") || [];
              if (isArray(binding)) {
                bindings = bindings.concat(binding);
              } else {
                bindings.push(binding);
              }
              $element.data("$binding", bindings);
            }
          : noop;
        compile.$$addBindingClass = debugInfoEnabled
          ? function $$addBindingClass($element) {
              safeAddClass($element, "ng-binding");
            }
          : noop;
        compile.$$addScopeInfo = debugInfoEnabled
          ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
              var dataName = isolated
                ? noTemplate
                  ? "$isolateScopeNoTemplate"
                  : "$isolateScope"
                : "$scope";
              $element.data(dataName, scope);
            }
          : noop;
        compile.$$addScopeClass = debugInfoEnabled
          ? function $$addScopeClass($element, isolated) {
              safeAddClass(
                $element,
                isolated ? "ng-isolate-scope" : "ng-scope"
              );
            }
          : noop;
        return compile;
        function compile(
          $compileNodes,
          transcludeFn,
          maxPriority,
          ignoreDirective,
          previousCompileContext
        ) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          var NOT_EMPTY = /\S+/;
          for (var i = 0, len = $compileNodes.length; i < len; i++) {
            var domNode = $compileNodes[i];
            if (
              domNode.nodeType === NODE_TYPE_TEXT &&
              domNode.nodeValue.match(NOT_EMPTY)
            ) {
              jqLiteWrapNode(
                domNode,
                ($compileNodes[i] = document.createElement("span"))
              );
            }
          }
          var compositeLinkFn = compileNodes(
            $compileNodes,
            transcludeFn,
            $compileNodes,
            maxPriority,
            ignoreDirective,
            previousCompileContext
          );
          compile.$$addScopeClass($compileNodes);
          var namespace = null;
          return function publicLinkFn(scope, cloneConnectFn, options) {
            assertArg(scope, "scope");
            if (
              previousCompileContext &&
              previousCompileContext.needsNewScope
            ) {
              scope = scope.$parent.$new();
            }
            options = options || {};
            var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
              transcludeControllers = options.transcludeControllers,
              futureParentElement = options.futureParentElement;
            if (
              parentBoundTranscludeFn &&
              parentBoundTranscludeFn.$$boundTransclude
            ) {
              parentBoundTranscludeFn =
                parentBoundTranscludeFn.$$boundTransclude;
            }
            if (!namespace) {
              namespace = detectNamespaceForChildElements(futureParentElement);
            }
            var $linkNode;
            if (namespace !== "html") {
              $linkNode = jqLite(
                wrapTemplate(
                  namespace,
                  jqLite("<div>").append($compileNodes).html()
                )
              );
            } else if (cloneConnectFn) {
              $linkNode = JQLitePrototype.clone.call($compileNodes);
            } else {
              $linkNode = $compileNodes;
            }
            if (transcludeControllers) {
              for (var controllerName in transcludeControllers) {
                $linkNode.data(
                  "$" + controllerName + "Controller",
                  transcludeControllers[controllerName].instance
                );
              }
            }
            compile.$$addScopeInfo($linkNode, scope);
            if (cloneConnectFn) cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(
                scope,
                $linkNode,
                $linkNode,
                parentBoundTranscludeFn
              );
            return $linkNode;
          };
        }
        function detectNamespaceForChildElements(parentElement) {
          var node = parentElement && parentElement[0];
          if (!node) {
            return "html";
          } else {
            return nodeName_(node) !== "foreignobject" &&
              node.toString().match(/SVG/)
              ? "svg"
              : "html";
          }
        }
        function compileNodes(
          nodeList,
          transcludeFn,
          $rootElement,
          maxPriority,
          ignoreDirective,
          previousCompileContext
        ) {
          var linkFns = [],
            attrs,
            directives,
            nodeLinkFn,
            childNodes,
            childLinkFn,
            linkFnFound,
            nodeLinkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(
              nodeList[i],
              [],
              attrs,
              i === 0 ? maxPriority : undefined,
              ignoreDirective
            );
            nodeLinkFn = directives.length
              ? applyDirectivesToNode(
                  directives,
                  nodeList[i],
                  attrs,
                  transcludeFn,
                  $rootElement,
                  null,
                  [],
                  [],
                  previousCompileContext
                )
              : null;
            if (nodeLinkFn && nodeLinkFn.scope) {
              compile.$$addScopeClass(attrs.$$element);
            }
            childLinkFn =
              (nodeLinkFn && nodeLinkFn.terminal) ||
              !(childNodes = nodeList[i].childNodes) ||
              !childNodes.length
                ? null
                : compileNodes(
                    childNodes,
                    nodeLinkFn
                      ? (nodeLinkFn.transcludeOnThisElement ||
                          !nodeLinkFn.templateOnThisElement) &&
                          nodeLinkFn.transclude
                      : transcludeFn
                  );
            if (nodeLinkFn || childLinkFn) {
              linkFns.push(i, nodeLinkFn, childLinkFn);
              linkFnFound = true;
              nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
            }
            previousCompileContext = null;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(
            scope,
            nodeList,
            $rootElement,
            parentBoundTranscludeFn
          ) {
            var nodeLinkFn,
              childLinkFn,
              node,
              childScope,
              i,
              ii,
              idx,
              childBoundTranscludeFn;
            var stableNodeList;
            if (nodeLinkFnFound) {
              var nodeListLength = nodeList.length;
              stableNodeList = new Array(nodeListLength);
              for (i = 0; i < linkFns.length; i += 3) {
                idx = linkFns[i];
                stableNodeList[idx] = nodeList[idx];
              }
            } else {
              stableNodeList = nodeList;
            }
            for (i = 0, ii = linkFns.length; i < ii; ) {
              node = stableNodeList[linkFns[i++]];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new();
                  compile.$$addScopeInfo(jqLite(node), childScope);
                } else {
                  childScope = scope;
                }
                if (nodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope,
                    nodeLinkFn.transclude,
                    parentBoundTranscludeFn
                  );
                } else if (
                  !nodeLinkFn.templateOnThisElement &&
                  parentBoundTranscludeFn
                ) {
                  childBoundTranscludeFn = parentBoundTranscludeFn;
                } else if (!parentBoundTranscludeFn && transcludeFn) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope,
                    transcludeFn
                  );
                } else {
                  childBoundTranscludeFn = null;
                }
                nodeLinkFn(
                  childLinkFn,
                  childScope,
                  node,
                  $rootElement,
                  childBoundTranscludeFn
                );
              } else if (childLinkFn) {
                childLinkFn(
                  scope,
                  node.childNodes,
                  undefined,
                  parentBoundTranscludeFn
                );
              }
            }
          }
        }
        function createBoundTranscludeFn(
          scope,
          transcludeFn,
          previousBoundTranscludeFn
        ) {
          var boundTranscludeFn = function (
            transcludedScope,
            cloneFn,
            controllers,
            futureParentElement,
            containingScope
          ) {
            if (!transcludedScope) {
              transcludedScope = scope.$new(false, containingScope);
              transcludedScope.$$transcluded = true;
            }
            return transcludeFn(transcludedScope, cloneFn, {
              parentBoundTranscludeFn: previousBoundTranscludeFn,
              transcludeControllers: controllers,
              futureParentElement: futureParentElement,
            });
          };
          return boundTranscludeFn;
        }
        function collectDirectives(
          node,
          directives,
          attrs,
          maxPriority,
          ignoreDirective
        ) {
          var nodeType = node.nodeType,
            attrsMap = attrs.$attr,
            match,
            nodeName,
            className;
          switch (nodeType) {
            case NODE_TYPE_ELEMENT:
              nodeName = nodeName_(node);
              addDirective(
                directives,
                directiveNormalize(nodeName),
                "E",
                maxPriority,
                ignoreDirective
              );
              for (
                var attr,
                  name,
                  nName,
                  ngAttrName,
                  value,
                  isNgAttr,
                  nAttrs = node.attributes,
                  j = 0,
                  jj = nAttrs && nAttrs.length;
                j < jj;
                j++
              ) {
                var attrStartName = false;
                var attrEndName = false;
                attr = nAttrs[j];
                name = attr.name;
                value = trim(attr.value);
                ngAttrName = directiveNormalize(name);
                if ((isNgAttr = NG_ATTR_BINDING.test(ngAttrName))) {
                  name = name
                    .replace(PREFIX_REGEXP, "")
                    .substr(8)
                    .replace(/_(.)/g, function (match, letter) {
                      return letter.toUpperCase();
                    });
                }
                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                if (
                  multiElementMatch &&
                  directiveIsMultiElement(multiElementMatch[1])
                ) {
                  attrStartName = name;
                  attrEndName = name.substr(0, name.length - 5) + "end";
                  name = name.substr(0, name.length - 6);
                }
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                  attrs[nName] = value;
                  if (getBooleanAttrName(node, nName)) {
                    attrs[nName] = true;
                  }
                }
                addAttrInterpolateDirective(
                  node,
                  directives,
                  value,
                  nName,
                  isNgAttr
                );
                addDirective(
                  directives,
                  nName,
                  "A",
                  maxPriority,
                  ignoreDirective,
                  attrStartName,
                  attrEndName
                );
              }
              if (
                nodeName === "input" &&
                node.getAttribute("type") === "hidden"
              ) {
                node.setAttribute("autocomplete", "off");
              }
              className = node.className;
              if (isObject(className)) {
                className = className.animVal;
              }
              if (isString(className) && className !== "") {
                while ((match = CLASS_DIRECTIVE_REGEXP.exec(className))) {
                  nName = directiveNormalize(match[2]);
                  if (
                    addDirective(
                      directives,
                      nName,
                      "C",
                      maxPriority,
                      ignoreDirective
                    )
                  ) {
                    attrs[nName] = trim(match[3]);
                  }
                  className = className.substr(match.index + match[0].length);
                }
              }
              break;
            case NODE_TYPE_TEXT:
              if (msie === 11) {
                while (
                  node.parentNode &&
                  node.nextSibling &&
                  node.nextSibling.nodeType === NODE_TYPE_TEXT
                ) {
                  node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                  node.parentNode.removeChild(node.nextSibling);
                }
              }
              addTextInterpolateDirective(directives, node.nodeValue);
              break;
            case NODE_TYPE_COMMENT:
              try {
                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                if (match) {
                  nName = directiveNormalize(match[1]);
                  if (
                    addDirective(
                      directives,
                      nName,
                      "M",
                      maxPriority,
                      ignoreDirective
                    )
                  ) {
                    attrs[nName] = trim(match[2]);
                  }
                }
              } catch (e) {}
              break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function groupScan(node, attrStart, attrEnd) {
          var nodes = [];
          var depth = 0;
          if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
            do {
              if (!node) {
                throw $compileMinErr(
                  "uterdir",
                  "Unterminated attribute, found '{0}' but no matching '{1}' found.",
                  attrStart,
                  attrEnd
                );
              }
              if (node.nodeType == NODE_TYPE_ELEMENT) {
                if (node.hasAttribute(attrStart)) depth++;
                if (node.hasAttribute(attrEnd)) depth--;
              }
              nodes.push(node);
              node = node.nextSibling;
            } while (depth > 0);
          } else {
            nodes.push(node);
          }
          return jqLite(nodes);
        }
        function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
          return function (scope, element, attrs, controllers, transcludeFn) {
            element = groupScan(element[0], attrStart, attrEnd);
            return linkFn(scope, element, attrs, controllers, transcludeFn);
          };
        }
        function applyDirectivesToNode(
          directives,
          compileNode,
          templateAttrs,
          transcludeFn,
          jqCollection,
          originalReplaceDirective,
          preLinkFns,
          postLinkFns,
          previousCompileContext
        ) {
          previousCompileContext = previousCompileContext || {};
          var terminalPriority = -Number.MAX_VALUE,
            newScopeDirective = previousCompileContext.newScopeDirective,
            controllerDirectives = previousCompileContext.controllerDirectives,
            newIsolateScopeDirective =
              previousCompileContext.newIsolateScopeDirective,
            templateDirective = previousCompileContext.templateDirective,
            nonTlbTranscludeDirective =
              previousCompileContext.nonTlbTranscludeDirective,
            hasTranscludeDirective = false,
            hasTemplate = false,
            hasElementTranscludeDirective =
              previousCompileContext.hasElementTranscludeDirective,
            $compileNode = (templateAttrs.$$element = jqLite(compileNode)),
            directive,
            directiveName,
            $template,
            replaceDirective = originalReplaceDirective,
            childTranscludeFn = transcludeFn,
            linkFn,
            directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            var attrStart = directive.$$start;
            var attrEnd = directive.$$end;
            if (attrStart) {
              $compileNode = groupScan(compileNode, attrStart, attrEnd);
            }
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if ((directiveValue = directive.scope)) {
              if (!directive.templateUrl) {
                if (isObject(directiveValue)) {
                  assertNoDuplicate(
                    "new/isolated scope",
                    newIsolateScopeDirective || newScopeDirective,
                    directive,
                    $compileNode
                  );
                  newIsolateScopeDirective = directive;
                } else {
                  assertNoDuplicate(
                    "new/isolated scope",
                    newIsolateScopeDirective,
                    directive,
                    $compileNode
                  );
                }
              }
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (!directive.templateUrl && directive.controller) {
              directiveValue = directive.controller;
              controllerDirectives = controllerDirectives || createMap();
              assertNoDuplicate(
                "'" + directiveName + "' controller",
                controllerDirectives[directiveName],
                directive,
                $compileNode
              );
              controllerDirectives[directiveName] = directive;
            }
            if ((directiveValue = directive.transclude)) {
              hasTranscludeDirective = true;
              if (!directive.$$tlb) {
                assertNoDuplicate(
                  "transclusion",
                  nonTlbTranscludeDirective,
                  directive,
                  $compileNode
                );
                nonTlbTranscludeDirective = directive;
              }
              if (directiveValue == "element") {
                hasElementTranscludeDirective = true;
                terminalPriority = directive.priority;
                $template = $compileNode;
                $compileNode = templateAttrs.$$element = jqLite(
                  document.createComment(
                    " " +
                      directiveName +
                      ": " +
                      templateAttrs[directiveName] +
                      " "
                  )
                );
                compileNode = $compileNode[0];
                replaceWith(jqCollection, sliceArgs($template), compileNode);
                childTranscludeFn = compile(
                  $template,
                  transcludeFn,
                  terminalPriority,
                  replaceDirective && replaceDirective.name,
                  { nonTlbTranscludeDirective: nonTlbTranscludeDirective }
                );
              } else {
                $template = jqLite(jqLiteClone(compileNode)).contents();
                $compileNode.empty();
                childTranscludeFn = compile(
                  $template,
                  transcludeFn,
                  undefined,
                  undefined,
                  {
                    needsNewScope:
                      directive.$$isolateScope || directive.$$newScope,
                  }
                );
              }
            }
            if (directive.template) {
              hasTemplate = true;
              assertNoDuplicate(
                "template",
                templateDirective,
                directive,
                $compileNode
              );
              templateDirective = directive;
              directiveValue = isFunction(directive.template)
                ? directive.template($compileNode, templateAttrs)
                : directive.template;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                replaceDirective = directive;
                if (jqLiteIsTextNode(directiveValue)) {
                  $template = [];
                } else {
                  $template = removeComments(
                    wrapTemplate(
                      directive.templateNamespace,
                      trim(directiveValue)
                    )
                  );
                }
                compileNode = $template[0];
                if (
                  $template.length != 1 ||
                  compileNode.nodeType !== NODE_TYPE_ELEMENT
                ) {
                  throw $compileMinErr(
                    "tplrt",
                    "Template for directive '{0}' must have exactly one root element. {1}",
                    directiveName,
                    ""
                  );
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = { $attr: {} };
                var templateDirectives = collectDirectives(
                  compileNode,
                  [],
                  newTemplateAttrs
                );
                var unprocessedDirectives = directives.splice(
                  i + 1,
                  directives.length - (i + 1)
                );
                if (newIsolateScopeDirective || newScopeDirective) {
                  markDirectiveScope(
                    templateDirectives,
                    newIsolateScopeDirective,
                    newScopeDirective
                  );
                }
                directives = directives
                  .concat(templateDirectives)
                  .concat(unprocessedDirectives);
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              hasTemplate = true;
              assertNoDuplicate(
                "template",
                templateDirective,
                directive,
                $compileNode
              );
              templateDirective = directive;
              if (directive.replace) {
                replaceDirective = directive;
              }
              nodeLinkFn = compileTemplateUrl(
                directives.splice(i, directives.length - i),
                $compileNode,
                templateAttrs,
                jqCollection,
                hasTranscludeDirective && childTranscludeFn,
                preLinkFns,
                postLinkFns,
                {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective:
                    newScopeDirective !== directive && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective,
                }
              );
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile(
                  $compileNode,
                  templateAttrs,
                  childTranscludeFn
                );
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn, attrStart, attrEnd);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope =
            newScopeDirective && newScopeDirective.scope === true;
          nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
          nodeLinkFn.templateOnThisElement = hasTemplate;
          nodeLinkFn.transclude = childTranscludeFn;
          previousCompileContext.hasElementTranscludeDirective =
            hasElementTranscludeDirective;
          return nodeLinkFn;
          function addLinkFns(pre, post, attrStart, attrEnd) {
            if (pre) {
              if (attrStart)
                pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
              pre.require = directive.require;
              pre.directiveName = directiveName;
              if (
                newIsolateScopeDirective === directive ||
                directive.$$isolateScope
              ) {
                pre = cloneAndAnnotateFn(pre, { isolateScope: true });
              }
              preLinkFns.push(pre);
            }
            if (post) {
              if (attrStart)
                post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
              post.require = directive.require;
              post.directiveName = directiveName;
              if (
                newIsolateScopeDirective === directive ||
                directive.$$isolateScope
              ) {
                post = cloneAndAnnotateFn(post, { isolateScope: true });
              }
              postLinkFns.push(post);
            }
          }
          function getControllers(
            directiveName,
            require,
            $element,
            elementControllers
          ) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === "?";
              if (inheritType === "^^") {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = "$" + name + "Controller";
                value = inheritType
                  ? $element.inheritedData(dataName)
                  : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr(
                  "ctreq",
                  "Controller '{0}', required by directive '{1}', can't be found!",
                  name,
                  directiveName
                );
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0, ii = require.length; i < ii; i++) {
                value[i] = getControllers(
                  directiveName,
                  require[i],
                  $element,
                  elementControllers
                );
              }
            }
            return value || null;
          }
          function setupControllers(
            $element,
            attrs,
            transcludeFn,
            controllerDirectives,
            isolateScope,
            scope
          ) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope:
                  directive === newIsolateScopeDirective ||
                  directive.$$isolateScope
                    ? isolateScope
                    : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn,
              };
              var controller = directive.controller;
              if (controller == "@") {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(
                controller,
                locals,
                true,
                directive.controllerAs
              );
              elementControllers[directive.name] = controllerInstance;
              $element.data(
                "$" + directive.name + "Controller",
                controllerInstance.instance
              );
            }
            return elementControllers;
          }
          function nodeLinkFn(
            childLinkFn,
            scope,
            linkNode,
            $rootElement,
            boundTranscludeFn
          ) {
            var linkFn,
              isolateScope,
              controllerScope,
              elementControllers,
              transcludeFn,
              $element,
              attrs,
              removeScopeBindingWatches,
              removeControllerBindingWatches;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
              $element = templateAttrs.$$element;
            } else {
              $element = jqLite(linkNode);
              attrs = new Attributes($element, templateAttrs);
            }
            controllerScope = scope;
            if (newIsolateScopeDirective) {
              isolateScope = scope.$new(true);
            } else if (newScopeDirective) {
              controllerScope = scope.$parent;
            }
            if (boundTranscludeFn) {
              transcludeFn = controllersBoundTransclude;
              transcludeFn.$$boundTransclude = boundTranscludeFn;
            }
            if (controllerDirectives) {
              elementControllers = setupControllers(
                $element,
                attrs,
                transcludeFn,
                controllerDirectives,
                isolateScope,
                scope
              );
            }
            if (newIsolateScopeDirective) {
              compile.$$addScopeInfo(
                $element,
                isolateScope,
                true,
                !(
                  templateDirective &&
                  (templateDirective === newIsolateScopeDirective ||
                    templateDirective ===
                      newIsolateScopeDirective.$$originalDirective)
                )
              );
              compile.$$addScopeClass($element, true);
              isolateScope.$$isolateBindings =
                newIsolateScopeDirective.$$isolateBindings;
              removeScopeBindingWatches = initializeDirectiveBindings(
                scope,
                attrs,
                isolateScope,
                isolateScope.$$isolateBindings,
                newIsolateScopeDirective
              );
              if (removeScopeBindingWatches) {
                isolateScope.$on("$destroy", removeScopeBindingWatches);
              }
            }
            for (var name in elementControllers) {
              var controllerDirective = controllerDirectives[name];
              var controller = elementControllers[name];
              var bindings = controllerDirective.$$bindings.bindToController;
              if (controller.identifier && bindings) {
                removeControllerBindingWatches = initializeDirectiveBindings(
                  controllerScope,
                  attrs,
                  controller.instance,
                  bindings,
                  controllerDirective
                );
              }
              var controllerResult = controller();
              if (controllerResult !== controller.instance) {
                controller.instance = controllerResult;
                $element.data(
                  "$" + controllerDirective.name + "Controller",
                  controllerResult
                );
                removeControllerBindingWatches &&
                  removeControllerBindingWatches();
                removeControllerBindingWatches = initializeDirectiveBindings(
                  controllerScope,
                  attrs,
                  controller.instance,
                  bindings,
                  controllerDirective
                );
              }
            }
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              linkFn = preLinkFns[i];
              invokeLinkFn(
                linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require &&
                  getControllers(
                    linkFn.directiveName,
                    linkFn.require,
                    $element,
                    elementControllers
                  ),
                transcludeFn
              );
            }
            var scopeToChild = scope;
            if (
              newIsolateScopeDirective &&
              (newIsolateScopeDirective.template ||
                newIsolateScopeDirective.templateUrl === null)
            ) {
              scopeToChild = isolateScope;
            }
            childLinkFn &&
              childLinkFn(
                scopeToChild,
                linkNode.childNodes,
                undefined,
                boundTranscludeFn
              );
            for (i = postLinkFns.length - 1; i >= 0; i--) {
              linkFn = postLinkFns[i];
              invokeLinkFn(
                linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require &&
                  getControllers(
                    linkFn.directiveName,
                    linkFn.require,
                    $element,
                    elementControllers
                  ),
                transcludeFn
              );
            }
            function controllersBoundTransclude(
              scope,
              cloneAttachFn,
              futureParentElement
            ) {
              var transcludeControllers;
              if (!isScope(scope)) {
                futureParentElement = cloneAttachFn;
                cloneAttachFn = scope;
                scope = undefined;
              }
              if (hasElementTranscludeDirective) {
                transcludeControllers = elementControllers;
              }
              if (!futureParentElement) {
                futureParentElement = hasElementTranscludeDirective
                  ? $element.parent()
                  : $element;
              }
              return boundTranscludeFn(
                scope,
                cloneAttachFn,
                transcludeControllers,
                futureParentElement,
                scopeToChild
              );
            }
          }
        }
        function markDirectiveScope(directives, isolateScope, newScope) {
          for (var j = 0, jj = directives.length; j < jj; j++) {
            directives[j] = inherit(directives[j], {
              $$isolateScope: isolateScope,
              $$newScope: newScope,
            });
          }
        }
        function addDirective(
          tDirectives,
          name,
          location,
          maxPriority,
          ignoreDirective,
          startAttrName,
          endAttrName
        ) {
          if (name === ignoreDirective) return null;
          var match = null;
          if (hasDirectives.hasOwnProperty(name)) {
            for (
              var directive,
                directives = $injector.get(name + Suffix),
                i = 0,
                ii = directives.length;
              i < ii;
              i++
            ) {
              try {
                directive = directives[i];
                if (
                  (isUndefined(maxPriority) ||
                    maxPriority > directive.priority) &&
                  directive.restrict.indexOf(location) != -1
                ) {
                  if (startAttrName) {
                    directive = inherit(directive, {
                      $$start: startAttrName,
                      $$end: endAttrName,
                    });
                  }
                  if (!directive.$$bindings) {
                    var bindings = (directive.$$bindings =
                      parseDirectiveBindings(directive, directive.name));
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                  }
                  tDirectives.push(directive);
                  match = directive;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }
        function directiveIsMultiElement(name) {
          if (hasDirectives.hasOwnProperty(name)) {
            for (
              var directive,
                directives = $injector.get(name + Suffix),
                i = 0,
                ii = directives.length;
              i < ii;
              i++
            ) {
              directive = directives[i];
              if (directive.multiElement) {
                return true;
              }
            }
          }
          return false;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr,
            dstAttr = dst.$attr,
            $element = dst.$$element;
          forEach(dst, function (value, key) {
            if (key.charAt(0) != "$") {
              if (src[key] && src[key] !== value) {
                value += (key === "style" ? ";" : " ") + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function (value, key) {
            if (key == "class") {
              safeAddClass($element, value);
              dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value;
            } else if (key == "style") {
              $element.attr("style", $element.attr("style") + ";" + value);
              dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value;
            } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }
        function compileTemplateUrl(
          directives,
          $compileNode,
          tAttrs,
          $rootElement,
          childTranscludeFn,
          preLinkFns,
          postLinkFns,
          previousCompileContext
        ) {
          var linkQueue = [],
            afterTemplateNodeLinkFn,
            afterTemplateChildLinkFn,
            beforeTemplateCompileNode = $compileNode[0],
            origAsyncDirective = directives.shift(),
            derivedSyncDirective = inherit(origAsyncDirective, {
              templateUrl: null,
              transclude: null,
              replace: null,
              $$originalDirective: origAsyncDirective,
            }),
            templateUrl = isFunction(origAsyncDirective.templateUrl)
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl,
            templateNamespace = origAsyncDirective.templateNamespace;
          $compileNode.empty();
          $templateRequest(templateUrl).then(function (content) {
            var compileNode,
              tempTemplateAttrs,
              $template,
              childBoundTranscludeFn;
            content = denormalizeTemplate(content);
            if (origAsyncDirective.replace) {
              if (jqLiteIsTextNode(content)) {
                $template = [];
              } else {
                $template = removeComments(
                  wrapTemplate(templateNamespace, trim(content))
                );
              }
              compileNode = $template[0];
              if (
                $template.length != 1 ||
                compileNode.nodeType !== NODE_TYPE_ELEMENT
              ) {
                throw $compileMinErr(
                  "tplrt",
                  "Template for directive '{0}' must have exactly one root element. {1}",
                  origAsyncDirective.name,
                  templateUrl
                );
              }
              tempTemplateAttrs = { $attr: {} };
              replaceWith($rootElement, $compileNode, compileNode);
              var templateDirectives = collectDirectives(
                compileNode,
                [],
                tempTemplateAttrs
              );
              if (isObject(origAsyncDirective.scope)) {
                markDirectiveScope(templateDirectives, true);
              }
              directives = templateDirectives.concat(directives);
              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.html(content);
            }
            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(
              directives,
              compileNode,
              tAttrs,
              childTranscludeFn,
              $compileNode,
              origAsyncDirective,
              preLinkFns,
              postLinkFns,
              previousCompileContext
            );
            forEach($rootElement, function (node, i) {
              if (node == compileNode) {
                $rootElement[i] = $compileNode[0];
              }
            });
            afterTemplateChildLinkFn = compileNodes(
              $compileNode[0].childNodes,
              childTranscludeFn
            );
            while (linkQueue.length) {
              var scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                boundTranscludeFn = linkQueue.shift(),
                linkNode = $compileNode[0];
              if (scope.$$destroyed) continue;
              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                var oldClasses = beforeTemplateLinkNode.className;
                if (
                  !(
                    previousCompileContext.hasElementTranscludeDirective &&
                    origAsyncDirective.replace
                  )
                ) {
                  linkNode = jqLiteClone(compileNode);
                }
                replaceWith(
                  linkRootElement,
                  jqLite(beforeTemplateLinkNode),
                  linkNode
                );
                safeAddClass(jqLite(linkNode), oldClasses);
              }
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(
                  scope,
                  afterTemplateNodeLinkFn.transclude,
                  boundTranscludeFn
                );
              } else {
                childBoundTranscludeFn = boundTranscludeFn;
              }
              afterTemplateNodeLinkFn(
                afterTemplateChildLinkFn,
                scope,
                linkNode,
                $rootElement,
                childBoundTranscludeFn
              );
            }
            linkQueue = null;
          });
          return function delayedNodeLinkFn(
            ignoreChildLinkFn,
            scope,
            node,
            rootElement,
            boundTranscludeFn
          ) {
            var childBoundTranscludeFn = boundTranscludeFn;
            if (scope.$$destroyed) return;
            if (linkQueue) {
              linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
            } else {
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(
                  scope,
                  afterTemplateNodeLinkFn.transclude,
                  boundTranscludeFn
                );
              }
              afterTemplateNodeLinkFn(
                afterTemplateChildLinkFn,
                scope,
                node,
                rootElement,
                childBoundTranscludeFn
              );
            }
          };
        }
        function byPriority(a, b) {
          var diff = b.priority - a.priority;
          if (diff !== 0) return diff;
          if (a.name !== b.name) return a.name < b.name ? -1 : 1;
          return a.index - b.index;
        }
        function assertNoDuplicate(
          what,
          previousDirective,
          directive,
          element
        ) {
          function wrapModuleNameIfDefined(moduleName) {
            return moduleName ? " (module: " + moduleName + ")" : "";
          }
          if (previousDirective) {
            throw $compileMinErr(
              "multidir",
              "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}",
              previousDirective.name,
              wrapModuleNameIfDefined(previousDirective.$$moduleName),
              directive.name,
              wrapModuleNameIfDefined(directive.$$moduleName),
              what,
              startingTag(element)
            );
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: function textInterpolateCompileFn(templateNode) {
                var templateNodeParent = templateNode.parent(),
                  hasCompileParent = !!templateNodeParent.length;
                if (hasCompileParent)
                  compile.$$addBindingClass(templateNodeParent);
                return function textInterpolateLinkFn(scope, node) {
                  var parent = node.parent();
                  if (!hasCompileParent) compile.$$addBindingClass(parent);
                  compile.$$addBindingInfo(parent, interpolateFn.expressions);
                  scope.$watch(
                    interpolateFn,
                    function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    }
                  );
                };
              },
            });
          }
        }
        function wrapTemplate(type, template) {
          type = lowercase(type || "html");
          switch (type) {
            case "svg":
            case "math":
              var wrapper = document.createElement("div");
              wrapper.innerHTML =
                "<" + type + ">" + template + "</" + type + ">";
              return wrapper.childNodes[0].childNodes;
            default:
              return template;
          }
        }
        function getTrustedContext(node, attrNormalizedName) {
          if (attrNormalizedName == "srcdoc") {
            return $sce.HTML;
          }
          var tag = nodeName_(node);
          if (
            attrNormalizedName == "xlinkHref" ||
            (tag == "form" && attrNormalizedName == "action") ||
            (tag != "img" &&
              (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))
          ) {
            return $sce.RESOURCE_URL;
          }
        }
        function addAttrInterpolateDirective(
          node,
          directives,
          value,
          name,
          allOrNothing
        ) {
          var trustedContext = getTrustedContext(node, name);
          allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
          var interpolateFn = $interpolate(
            value,
            true,
            trustedContext,
            allOrNothing
          );
          if (!interpolateFn) return;
          if (name === "multiple" && nodeName_(node) === "select") {
            throw $compileMinErr(
              "selmulti",
              "Binding to the 'multiple' attribute is not supported. Element: {0}",
              startingTag(node)
            );
          }
          directives.push({
            priority: 100,
            compile: function () {
              return {
                pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                  var $$observers =
                    attr.$$observers || (attr.$$observers = createMap());
                  if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                    throw $compileMinErr(
                      "nodomevents",
                      "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
                        "ng- versions (such as ng-click instead of onclick) instead."
                    );
                  }
                  var newValue = attr[name];
                  if (newValue !== value) {
                    interpolateFn =
                      newValue &&
                      $interpolate(
                        newValue,
                        true,
                        trustedContext,
                        allOrNothing
                      );
                    value = newValue;
                  }
                  if (!interpolateFn) return;
                  attr[name] = interpolateFn(scope);
                  (
                    $$observers[name] || ($$observers[name] = [])
                  ).$$inter = true;
                  (
                    (attr.$$observers && attr.$$observers[name].$$scope) ||
                    scope
                  ).$watch(
                    interpolateFn,
                    function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === "class" && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    }
                  );
                },
              };
            },
          });
        }
        function replaceWith($rootElement, elementsToRemove, newNode) {
          var firstElementToRemove = elementsToRemove[0],
            removeCount = elementsToRemove.length,
            parent = firstElementToRemove.parentNode,
            i,
            ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == firstElementToRemove) {
                $rootElement[i++] = newNode;
                for (
                  var j = i, j2 = j + removeCount - 1, jj = $rootElement.length;
                  j < jj;
                  j++, j2++
                ) {
                  if (j2 < jj) {
                    $rootElement[j] = $rootElement[j2];
                  } else {
                    delete $rootElement[j];
                  }
                }
                $rootElement.length -= removeCount - 1;
                if ($rootElement.context === firstElementToRemove) {
                  $rootElement.context = newNode;
                }
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, firstElementToRemove);
          }
          var fragment = document.createDocumentFragment();
          fragment.appendChild(firstElementToRemove);
          if (jqLite.hasData(firstElementToRemove)) {
            jqLite.data(newNode, jqLite.data(firstElementToRemove));
            if (!jQuery) {
              delete jqLite.cache[firstElementToRemove[jqLite.expando]];
            } else {
              skipDestroyOnNextJQueryCleanData = true;
              jQuery.cleanData([firstElementToRemove]);
            }
          }
          for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
            var element = elementsToRemove[k];
            jqLite(element).remove();
            fragment.appendChild(element);
            delete elementsToRemove[k];
          }
          elementsToRemove[0] = newNode;
          elementsToRemove.length = 1;
        }
        function cloneAndAnnotateFn(fn, annotation) {
          return extend(
            function () {
              return fn.apply(null, arguments);
            },
            fn,
            annotation
          );
        }
        function invokeLinkFn(
          linkFn,
          scope,
          $element,
          attrs,
          controllers,
          transcludeFn
        ) {
          try {
            linkFn(scope, $element, attrs, controllers, transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }
        function initializeDirectiveBindings(
          scope,
          attrs,
          destination,
          bindings,
          directive
        ) {
          var removeWatchCollection = [];
          forEach(bindings, function (definition, scopeName) {
            var attrName = definition.attrName,
              optional = definition.optional,
              mode = definition.mode,
              lastValue,
              parentGet,
              parentSet,
              compare;
            switch (mode) {
              case "@":
                if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                  destination[scopeName] = attrs[attrName] = void 0;
                }
                attrs.$observe(attrName, function (value) {
                  if (isString(value)) {
                    destination[scopeName] = value;
                  }
                });
                attrs.$$observers[attrName].$$scope = scope;
                lastValue = attrs[attrName];
                if (isString(lastValue)) {
                  destination[scopeName] = $interpolate(lastValue)(scope);
                } else if (isBoolean(lastValue)) {
                  destination[scopeName] = lastValue;
                }
                break;
              case "=":
                if (!hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  attrs[attrName] = void 0;
                }
                if (optional && !attrs[attrName]) break;
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function (a, b) {
                    return a === b || (a !== a && b !== b);
                  };
                }
                parentSet =
                  parentGet.assign ||
                  function () {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr(
                      "nonassign",
                      "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                      attrs[attrName],
                      attrName,
                      directive.name
                    );
                  };
                lastValue = destination[scopeName] = parentGet(scope);
                var parentValueWatch = function parentValueWatch(parentValue) {
                  if (!compare(parentValue, destination[scopeName])) {
                    if (!compare(parentValue, lastValue)) {
                      destination[scopeName] = parentValue;
                    } else {
                      parentSet(scope, (parentValue = destination[scopeName]));
                    }
                  }
                  return (lastValue = parentValue);
                };
                parentValueWatch.$stateful = true;
                var removeWatch;
                if (definition.collection) {
                  removeWatch = scope.$watchCollection(
                    attrs[attrName],
                    parentValueWatch
                  );
                } else {
                  removeWatch = scope.$watch(
                    $parse(attrs[attrName], parentValueWatch),
                    null,
                    parentGet.literal
                  );
                }
                removeWatchCollection.push(removeWatch);
                break;
              case "&":
                parentGet = attrs.hasOwnProperty(attrName)
                  ? $parse(attrs[attrName])
                  : noop;
                if (parentGet === noop && optional) break;
                destination[scopeName] = function (locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });
          return (
            removeWatchCollection.length &&
            function removeWatches() {
              for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                removeWatchCollection[i]();
              }
            }
          );
        }
      },
    ];
  }
  var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ""));
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
  function directiveLinkingFn(
    nodesetLinkingFn,
    scope,
    node,
    rootElement,
    boundTranscludeFn
  ) {}
  function tokenDifference(str1, str2) {
    var values = "",
      tokens1 = str1.split(/\s+/),
      tokens2 = str2.split(/\s+/);
    outer: for (var i = 0; i < tokens1.length; i++) {
      var token = tokens1[i];
      for (var j = 0; j < tokens2.length; j++) {
        if (token == tokens2[j]) continue outer;
      }
      values += (values.length > 0 ? " " : "") + token;
    }
    return values;
  }
  function removeComments(jqNodes) {
    jqNodes = jqLite(jqNodes);
    var i = jqNodes.length;
    if (i <= 1) {
      return jqNodes;
    }
    while (i--) {
      var node = jqNodes[i];
      if (node.nodeType === NODE_TYPE_COMMENT) {
        splice.call(jqNodes, i, 1);
      }
    }
    return jqNodes;
  }
  var $controllerMinErr = minErr("$controller");
  var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
  function identifierForController(controller, ident) {
    if (ident && isString(ident)) return ident;
    if (isString(controller)) {
      var match = CNTRL_REG.exec(controller);
      if (match) return match[3];
    }
  }
  function $ControllerProvider() {
    var controllers = {},
      globals = false;
    this.register = function (name, constructor) {
      assertNotHasOwnProperty(name, "controller");
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.allowGlobals = function () {
      globals = true;
    };
    this.$get = [
      "$injector",
      "$window",
      function ($injector, $window) {
        return function (expression, locals, later, ident) {
          var instance, match, constructor, identifier;
          later = later === true;
          if (ident && isString(ident)) {
            identifier = ident;
          }
          if (isString(expression)) {
            match = expression.match(CNTRL_REG);
            if (!match) {
              throw $controllerMinErr(
                "ctrlfmt",
                "Badly formed controller string '{0}'. " +
                  "Must match `__name__ as __id__` or `__name__`.",
                expression
              );
            }
            (constructor = match[1]), (identifier = identifier || match[3]);
            expression = controllers.hasOwnProperty(constructor)
              ? controllers[constructor]
              : getter(locals.$scope, constructor, true) ||
                (globals ? getter($window, constructor, true) : undefined);
            assertArgFn(expression, constructor, true);
          }
          if (later) {
            var controllerPrototype = (
              isArray(expression)
                ? expression[expression.length - 1]
                : expression
            ).prototype;
            instance = Object.create(controllerPrototype || null);
            if (identifier) {
              addIdentifier(
                locals,
                identifier,
                instance,
                constructor || expression.name
              );
            }
            var instantiate;
            return (instantiate = extend(
              function () {
                var result = $injector.invoke(
                  expression,
                  instance,
                  locals,
                  constructor
                );
                if (
                  result !== instance &&
                  (isObject(result) || isFunction(result))
                ) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(
                      locals,
                      identifier,
                      instance,
                      constructor || expression.name
                    );
                  }
                }
                return instance;
              },
              { instance: instance, identifier: identifier }
            ));
          }
          instance = $injector.instantiate(expression, locals, constructor);
          if (identifier) {
            addIdentifier(
              locals,
              identifier,
              instance,
              constructor || expression.name
            );
          }
          return instance;
        };
        function addIdentifier(locals, identifier, instance, name) {
          if (!(locals && isObject(locals.$scope))) {
            throw minErr("$controller")(
              "noscp",
              "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
              name,
              identifier
            );
          }
          locals.$scope[identifier] = instance;
        }
      },
    ];
  }
  function $DocumentProvider() {
    this.$get = [
      "$window",
      function (window) {
        return jqLite(window.document);
      },
    ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [
      "$log",
      function ($log) {
        return function (exception, cause) {
          $log.error.apply($log, arguments);
        };
      },
    ];
  }
  var $$ForceReflowProvider = function () {
    this.$get = [
      "$document",
      function ($document) {
        return function (domNode) {
          if (domNode) {
            if (!domNode.nodeType && domNode instanceof jqLite) {
              domNode = domNode[0];
            }
          } else {
            domNode = $document[0].body;
          }
          return domNode.offsetWidth + 1;
        };
      },
    ];
  };
  var APPLICATION_JSON = "application/json";
  var CONTENT_TYPE_APPLICATION_JSON = {
    "Content-Type": APPLICATION_JSON + ";charset=utf-8",
  };
  var JSON_START = /^\[|^\{(?!\{)/;
  var JSON_ENDS = { "[": /]$/, "{": /}$/ };
  var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
  var $httpMinErr = minErr("$http");
  var $httpMinErrLegacyFn = function (method) {
    return function () {
      throw $httpMinErr(
        "legacy",
        "The method `{0}` on the promise returned from `$http` has been disabled.",
        method
      );
    };
  };
  function serializeValue(v) {
    if (isObject(v)) {
      return isDate(v) ? v.toISOString() : toJson(v);
    }
    return v;
  }
  function $HttpParamSerializerProvider() {
    this.$get = function () {
      return function ngParamSerializer(params) {
        if (!params) return "";
        var parts = [];
        forEachSorted(params, function (value, key) {
          if (value === null || isUndefined(value)) return;
          if (isArray(value)) {
            forEach(value, function (v, k) {
              parts.push(
                encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v))
              );
            });
          } else {
            parts.push(
              encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))
            );
          }
        });
        return parts.join("&");
      };
    };
  }
  function $HttpParamSerializerJQLikeProvider() {
    this.$get = function () {
      return function jQueryLikeParamSerializer(params) {
        if (!params) return "";
        var parts = [];
        serialize(params, "", true);
        return parts.join("&");
        function serialize(toSerialize, prefix, topLevel) {
          if (toSerialize === null || isUndefined(toSerialize)) return;
          if (isArray(toSerialize)) {
            forEach(toSerialize, function (value, index) {
              serialize(
                value,
                prefix + "[" + (isObject(value) ? index : "") + "]"
              );
            });
          } else if (isObject(toSerialize) && !isDate(toSerialize)) {
            forEachSorted(toSerialize, function (value, key) {
              serialize(
                value,
                prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]")
              );
            });
          } else {
            parts.push(
              encodeUriQuery(prefix) +
                "=" +
                encodeUriQuery(serializeValue(toSerialize))
            );
          }
        }
      };
    };
  }
  function defaultHttpResponseTransform(data, headers) {
    if (isString(data)) {
      var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
      if (tempData) {
        var contentType = headers("Content-Type");
        if (
          (contentType && contentType.indexOf(APPLICATION_JSON) === 0) ||
          isJsonLike(tempData)
        ) {
          data = fromJson(tempData);
        }
      }
    }
    return data;
  }
  function isJsonLike(str) {
    var jsonStart = str.match(JSON_START);
    return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
  }
  function parseHeaders(headers) {
    var parsed = createMap(),
      i;
    function fillInParsed(key, val) {
      if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
    if (isString(headers)) {
      forEach(headers.split("\n"), function (line) {
        i = line.indexOf(":");
        fillInParsed(
          lowercase(trim(line.substr(0, i))),
          trim(line.substr(i + 1))
        );
      });
    } else if (isObject(headers)) {
      forEach(headers, function (headerVal, headerKey) {
        fillInParsed(lowercase(headerKey), trim(headerVal));
      });
    }
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj;
    return function (name) {
      if (!headersObj) headersObj = parseHeaders(headers);
      if (name) {
        var value = headersObj[lowercase(name)];
        if (value === void 0) {
          value = null;
        }
        return value;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, status, fns) {
    if (isFunction(fns)) {
      return fns(data, headers, status);
    }
    forEach(fns, function (fn) {
      data = fn(data, headers, status);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var defaults = (this.defaults = {
      transformResponse: [defaultHttpResponseTransform],
      transformRequest: [
        function (d) {
          return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d)
            ? toJson(d)
            : d;
        },
      ],
      headers: {
        common: { Accept: "application/json, text/plain, */*" },
        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
      },
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      paramSerializer: "$httpParamSerializer",
    });
    var useApplyAsync = false;
    this.useApplyAsync = function (value) {
      if (isDefined(value)) {
        useApplyAsync = !!value;
        return this;
      }
      return useApplyAsync;
    };
    var useLegacyPromise = true;
    this.useLegacyPromiseExtensions = function (value) {
      if (isDefined(value)) {
        useLegacyPromise = !!value;
        return this;
      }
      return useLegacyPromise;
    };
    var interceptorFactories = (this.interceptors = []);
    this.$get = [
      "$httpBackend",
      "$$cookieReader",
      "$cacheFactory",
      "$rootScope",
      "$q",
      "$injector",
      function (
        $httpBackend,
        $$cookieReader,
        $cacheFactory,
        $rootScope,
        $q,
        $injector
      ) {
        var defaultCache = $cacheFactory("$http");
        defaults.paramSerializer = isString(defaults.paramSerializer)
          ? $injector.get(defaults.paramSerializer)
          : defaults.paramSerializer;
        var reversedInterceptors = [];
        forEach(interceptorFactories, function (interceptorFactory) {
          reversedInterceptors.unshift(
            isString(interceptorFactory)
              ? $injector.get(interceptorFactory)
              : $injector.invoke(interceptorFactory)
          );
        });
        function $http(requestConfig) {
          if (!angular.isObject(requestConfig)) {
            throw minErr("$http")(
              "badreq",
              "Http request configuration must be an object.  Received: {0}",
              requestConfig
            );
          }
          if (!isString(requestConfig.url)) {
            throw minErr("$http")(
              "badreq",
              "Http request configuration url must be a string.  Received: {0}",
              requestConfig.url
            );
          }
          var config = extend(
            {
              method: "get",
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer,
            },
            requestConfig
          );
          config.headers = mergeHeaders(requestConfig);
          config.method = uppercase(config.method);
          config.paramSerializer = isString(config.paramSerializer)
            ? $injector.get(config.paramSerializer)
            : config.paramSerializer;
          var serverRequest = function (config) {
            var headers = config.headers;
            var reqData = transformData(
              config.data,
              headersGetter(headers),
              undefined,
              config.transformRequest
            );
            if (isUndefined(reqData)) {
              forEach(headers, function (value, header) {
                if (lowercase(header) === "content-type") {
                  delete headers[header];
                }
              });
            }
            if (
              isUndefined(config.withCredentials) &&
              !isUndefined(defaults.withCredentials)
            ) {
              config.withCredentials = defaults.withCredentials;
            }
            return sendReq(config, reqData).then(
              transformResponse,
              transformResponse
            );
          };
          var chain = [serverRequest, undefined];
          var promise = $q.when(config);
          forEach(reversedInterceptors, function (interceptor) {
            if (interceptor.request || interceptor.requestError) {
              chain.unshift(interceptor.request, interceptor.requestError);
            }
            if (interceptor.response || interceptor.responseError) {
              chain.push(interceptor.response, interceptor.responseError);
            }
          });
          while (chain.length) {
            var thenFn = chain.shift();
            var rejectFn = chain.shift();
            promise = promise.then(thenFn, rejectFn);
          }
          if (useLegacyPromise) {
            promise.success = function (fn) {
              assertArgFn(fn, "fn");
              promise.then(function (response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
            promise.error = function (fn) {
              assertArgFn(fn, "fn");
              promise.then(null, function (response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
          } else {
            promise.success = $httpMinErrLegacyFn("success");
            promise.error = $httpMinErrLegacyFn("error");
          }
          return promise;
          function transformResponse(response) {
            var resp = extend({}, response);
            resp.data = transformData(
              response.data,
              response.headers,
              response.status,
              config.transformResponse
            );
            return isSuccess(response.status) ? resp : $q.reject(resp);
          }
          function executeHeaderFns(headers, config) {
            var headerContent,
              processedHeaders = {};
            forEach(headers, function (headerFn, header) {
              if (isFunction(headerFn)) {
                headerContent = headerFn(config);
                if (headerContent != null) {
                  processedHeaders[header] = headerContent;
                }
              } else {
                processedHeaders[header] = headerFn;
              }
            });
            return processedHeaders;
          }
          function mergeHeaders(config) {
            var defHeaders = defaults.headers,
              reqHeaders = extend({}, config.headers),
              defHeaderName,
              lowercaseDefHeaderName,
              reqHeaderName;
            defHeaders = extend(
              {},
              defHeaders.common,
              defHeaders[lowercase(config.method)]
            );
            defaultHeadersIteration: for (defHeaderName in defHeaders) {
              lowercaseDefHeaderName = lowercase(defHeaderName);
              for (reqHeaderName in reqHeaders) {
                if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                  continue defaultHeadersIteration;
                }
              }
              reqHeaders[defHeaderName] = defHeaders[defHeaderName];
            }
            return executeHeaderFns(reqHeaders, shallowCopy(config));
          }
        }
        $http.pendingRequests = [];
        createShortMethods("get", "delete", "head", "jsonp");
        createShortMethodsWithData("post", "put", "patch");
        $http.defaults = defaults;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function (name) {
            $http[name] = function (url, config) {
              return $http(
                extend({}, config || {}, { method: name, url: url })
              );
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function (name) {
            $http[name] = function (url, data, config) {
              return $http(
                extend({}, config || {}, { method: name, url: url, data: data })
              );
            };
          });
        }
        function sendReq(config, reqData) {
          var deferred = $q.defer(),
            promise = deferred.promise,
            cache,
            cachedResp,
            reqHeaders = config.headers,
            url = buildUrl(config.url, config.paramSerializer(config.params));
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if (
            (config.cache || defaults.cache) &&
            config.cache !== false &&
            (config.method === "GET" || config.method === "JSONP")
          ) {
            cache = isObject(config.cache)
              ? config.cache
              : isObject(defaults.cache)
              ? defaults.cache
              : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (isDefined(cachedResp)) {
              if (isPromiseLike(cachedResp)) {
                cachedResp.then(
                  resolvePromiseWithResult,
                  resolvePromiseWithResult
                );
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(
                    cachedResp[1],
                    cachedResp[0],
                    shallowCopy(cachedResp[2]),
                    cachedResp[3]
                  );
                } else {
                  resolvePromise(cachedResp, 200, {}, "OK");
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (isUndefined(cachedResp)) {
            var xsrfValue = urlIsSameOrigin(config.url)
              ? $$cookieReader()[
                  config.xsrfCookieName || defaults.xsrfCookieName
                ]
              : undefined;
            if (xsrfValue) {
              reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] =
                xsrfValue;
            }
            $httpBackend(
              config.method,
              url,
              reqData,
              done,
              reqHeaders,
              config.timeout,
              config.withCredentials,
              config.responseType
            );
          }
          return promise;
          function done(status, response, headersString, statusText) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [
                  status,
                  response,
                  parseHeaders(headersString),
                  statusText,
                ]);
              } else {
                cache.remove(url);
              }
            }
            function resolveHttpPromise() {
              resolvePromise(response, status, headersString, statusText);
            }
            if (useApplyAsync) {
              $rootScope.$applyAsync(resolveHttpPromise);
            } else {
              resolveHttpPromise();
              if (!$rootScope.$$phase) $rootScope.$apply();
            }
          }
          function resolvePromise(response, status, headers, statusText) {
            status = status >= -1 ? status : 0;
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config,
              statusText: statusText,
            });
          }
          function resolvePromiseWithResult(result) {
            resolvePromise(
              result.data,
              result.status,
              shallowCopy(result.headers()),
              result.statusText
            );
          }
          function removePendingReq() {
            var idx = $http.pendingRequests.indexOf(config);
            if (idx !== -1) $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, serializedParams) {
          if (serializedParams.length > 0) {
            url += (url.indexOf("?") == -1 ? "?" : "&") + serializedParams;
          }
          return url;
        }
      },
    ];
  }
  function $xhrFactoryProvider() {
    this.$get = function () {
      return function createXhr() {
        return new window.XMLHttpRequest();
      };
    };
  }
  function $HttpBackendProvider() {
    this.$get = [
      "$browser",
      "$window",
      "$document",
      "$xhrFactory",
      function ($browser, $window, $document, $xhrFactory) {
        return createHttpBackend(
          $browser,
          $xhrFactory,
          $browser.defer,
          $window.angular.callbacks,
          $document[0]
        );
      },
    ];
  }
  function createHttpBackend(
    $browser,
    createXhr,
    $browserDefer,
    callbacks,
    rawDocument
  ) {
    return function (
      method,
      url,
      post,
      callback,
      headers,
      timeout,
      withCredentials,
      responseType
    ) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == "jsonp") {
        var callbackId = "_" + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function (data) {
          callbacks[callbackId].data = data;
          callbacks[callbackId].called = true;
        };
        var jsonpDone = jsonpReq(
          url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId),
          callbackId,
          function (status, text) {
            completeRequest(
              callback,
              status,
              callbacks[callbackId].data,
              "",
              text
            );
            callbacks[callbackId] = noop;
          }
        );
      } else {
        var xhr = createXhr(method, url);
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
          if (isDefined(value)) {
            xhr.setRequestHeader(key, value);
          }
        });
        xhr.onload = function requestLoaded() {
          var statusText = xhr.statusText || "";
          var response = "response" in xhr ? xhr.response : xhr.responseText;
          var status = xhr.status === 1223 ? 204 : xhr.status;
          if (status === 0) {
            status = response
              ? 200
              : urlResolve(url).protocol == "file"
              ? 404
              : 0;
          }
          completeRequest(
            callback,
            status,
            response,
            xhr.getAllResponseHeaders(),
            statusText
          );
        };
        var requestError = function () {
          completeRequest(callback, -1, null, null, "");
        };
        xhr.onerror = requestError;
        xhr.onabort = requestError;
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        if (responseType) {
          try {
            xhr.responseType = responseType;
          } catch (e) {
            if (responseType !== "json") {
              throw e;
            }
          }
        }
        xhr.send(isUndefined(post) ? null : post);
      }
      if (timeout > 0) {
        var timeoutId = $browserDefer(timeoutRequest, timeout);
      } else if (isPromiseLike(timeout)) {
        timeout.then(timeoutRequest);
      }
      function timeoutRequest() {
        jsonpDone && jsonpDone();
        xhr && xhr.abort();
      }
      function completeRequest(
        callback,
        status,
        response,
        headersString,
        statusText
      ) {
        if (isDefined(timeoutId)) {
          $browserDefer.cancel(timeoutId);
        }
        jsonpDone = xhr = null;
        callback(status, response, headersString, statusText);
        $browser.$$completeOutstandingRequest(noop);
      }
    };
    function jsonpReq(url, callbackId, done) {
      var script = rawDocument.createElement("script"),
        callback = null;
      script.type = "text/javascript";
      script.src = url;
      script.async = true;
      callback = function (event) {
        removeEventListenerFn(script, "load", callback);
        removeEventListenerFn(script, "error", callback);
        rawDocument.body.removeChild(script);
        script = null;
        var status = -1;
        var text = "unknown";
        if (event) {
          if (event.type === "load" && !callbacks[callbackId].called) {
            event = { type: "error" };
          }
          text = event.type;
          status = event.type === "error" ? 404 : 200;
        }
        if (done) {
          done(status, text);
        }
      };
      addEventListenerFn(script, "load", callback);
      addEventListenerFn(script, "error", callback);
      rawDocument.body.appendChild(script);
      return callback;
    }
  }
  var $interpolateMinErr = (angular.$interpolateMinErr =
    minErr("$interpolate"));
  $interpolateMinErr.throwNoconcat = function (text) {
    throw $interpolateMinErr(
      "noconcat",
      "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
        "interpolations that concatenate multiple expressions when a trusted value is " +
        "required.  See http://docs.angularjs.org/api/ng.$sce",
      text
    );
  };
  $interpolateMinErr.interr = function (text, err) {
    return $interpolateMinErr(
      "interr",
      "Can't interpolate: {0}\n{1}",
      text,
      err.toString()
    );
  };
  function $InterpolateProvider() {
    var startSymbol = "{{";
    var endSymbol = "}}";
    this.startSymbol = function (value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function (value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [
      "$parse",
      "$exceptionHandler",
      "$sce",
      function ($parse, $exceptionHandler, $sce) {
        var startSymbolLength = startSymbol.length,
          endSymbolLength = endSymbol.length,
          escapedStartRegexp = new RegExp(
            startSymbol.replace(/./g, escape),
            "g"
          ),
          escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
        function escape(ch) {
          return "\\\\\\" + ch;
        }
        function unescapeText(text) {
          return text
            .replace(escapedStartRegexp, startSymbol)
            .replace(escapedEndRegexp, endSymbol);
        }
        function stringify(value) {
          if (value == null) {
            return "";
          }
          switch (typeof value) {
            case "string":
              break;
            case "number":
              value = "" + value;
              break;
            default:
              value = toJson(value);
          }
          return value;
        }
        function $interpolate(
          text,
          mustHaveExpression,
          trustedContext,
          allOrNothing
        ) {
          allOrNothing = !!allOrNothing;
          var startIndex,
            endIndex,
            index = 0,
            expressions = [],
            parseFns = [],
            textLength = text.length,
            exp,
            concat = [],
            expressionPositions = [];
          while (index < textLength) {
            if (
              (startIndex = text.indexOf(startSymbol, index)) != -1 &&
              (endIndex = text.indexOf(
                endSymbol,
                startIndex + startSymbolLength
              )) != -1
            ) {
              if (index !== startIndex) {
                concat.push(unescapeText(text.substring(index, startIndex)));
              }
              exp = text.substring(startIndex + startSymbolLength, endIndex);
              expressions.push(exp);
              parseFns.push($parse(exp, parseStringifyInterceptor));
              index = endIndex + endSymbolLength;
              expressionPositions.push(concat.length);
              concat.push("");
            } else {
              if (index !== textLength) {
                concat.push(unescapeText(text.substring(index)));
              }
              break;
            }
          }
          if (trustedContext && concat.length > 1) {
            $interpolateMinErr.throwNoconcat(text);
          }
          if (!mustHaveExpression || expressions.length) {
            var compute = function (values) {
              for (var i = 0, ii = expressions.length; i < ii; i++) {
                if (allOrNothing && isUndefined(values[i])) return;
                concat[expressionPositions[i]] = values[i];
              }
              return concat.join("");
            };
            var getValue = function (value) {
              return trustedContext
                ? $sce.getTrusted(trustedContext, value)
                : $sce.valueOf(value);
            };
            return extend(
              function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              },
              {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function (scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(
                    parseFns,
                    function interpolateFnWatcher(values, oldValues) {
                      var currValue = compute(values);
                      if (isFunction(listener)) {
                        listener.call(
                          this,
                          currValue,
                          values !== oldValues ? lastValue : currValue,
                          scope
                        );
                      }
                      lastValue = currValue;
                    }
                  );
                },
              }
            );
          }
          function parseStringifyInterceptor(value) {
            try {
              value = getValue(value);
              return allOrNothing && !isDefined(value)
                ? value
                : stringify(value);
            } catch (err) {
              $exceptionHandler($interpolateMinErr.interr(text, err));
            }
          }
        }
        $interpolate.startSymbol = function () {
          return startSymbol;
        };
        $interpolate.endSymbol = function () {
          return endSymbol;
        };
        return $interpolate;
      },
    ];
  }
  function $IntervalProvider() {
    this.$get = [
      "$rootScope",
      "$window",
      "$q",
      "$$q",
      function ($rootScope, $window, $q, $$q) {
        var intervals = {};
        function interval(fn, delay, count, invokeApply) {
          var hasParams = arguments.length > 4,
            args = hasParams ? sliceArgs(arguments, 4) : [],
            setInterval = $window.setInterval,
            clearInterval = $window.clearInterval,
            iteration = 0,
            skipApply = isDefined(invokeApply) && !invokeApply,
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise;
          count = isDefined(count) ? count : 0;
          promise.then(
            null,
            null,
            !hasParams
              ? fn
              : function () {
                  fn.apply(null, args);
                }
          );
          promise.$$intervalId = setInterval(function tick() {
            deferred.notify(iteration++);
            if (count > 0 && iteration >= count) {
              deferred.resolve(iteration);
              clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          intervals[promise.$$intervalId] = deferred;
          return promise;
        }
        interval.cancel = function (promise) {
          if (promise && promise.$$intervalId in intervals) {
            intervals[promise.$$intervalId].reject("canceled");
            $window.clearInterval(promise.$$intervalId);
            delete intervals[promise.$$intervalId];
            return true;
          }
          return false;
        };
        return interval;
      },
    ];
  }
  var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = { http: 80, https: 443, ftp: 21 };
  var $locationMinErr = minErr("$location");
  function encodePath(path) {
    var segments = path.split("/"),
      i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join("/");
  }
  function parseAbsoluteUrl(absoluteUrl, locationObj) {
    var parsedUrl = urlResolve(absoluteUrl);
    locationObj.$$protocol = parsedUrl.protocol;
    locationObj.$$host = parsedUrl.hostname;
    locationObj.$$port =
      toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
  }
  function parseAppUrl(relativeUrl, locationObj) {
    var prefixed = relativeUrl.charAt(0) !== "/";
    if (prefixed) {
      relativeUrl = "/" + relativeUrl;
    }
    var match = urlResolve(relativeUrl);
    locationObj.$$path = decodeURIComponent(
      prefixed && match.pathname.charAt(0) === "/"
        ? match.pathname.substring(1)
        : match.pathname
    );
    locationObj.$$search = parseKeyValue(match.search);
    locationObj.$$hash = decodeURIComponent(match.hash);
    if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
      locationObj.$$path = "/" + locationObj.$$path;
    }
  }
  function beginsWith(begin, whole) {
    if (whole.indexOf(begin) === 0) {
      return whole.substr(begin.length);
    }
  }
  function stripHash(url) {
    var index = url.indexOf("#");
    return index == -1 ? url : url.substr(0, index);
  }
  function trimEmptyHash(url) {
    return url.replace(/(#.+)|#$/, "$1");
  }
  function stripFile(url) {
    return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
  }
  function serverBase(url) {
    return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
  }
  function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
    this.$$html5 = true;
    basePrefix = basePrefix || "";
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function (url) {
      var pathUrl = beginsWith(appBaseNoFile, url);
      if (!isString(pathUrl)) {
        throw $locationMinErr(
          "ipthprfx",
          'Invalid url "{0}", missing path prefix "{1}".',
          url,
          appBaseNoFile
        );
      }
      parseAppUrl(pathUrl, this);
      if (!this.$$path) {
        this.$$path = "/";
      }
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url =
        encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
    };
    this.$$parseLinkUrl = function (url, relHref) {
      if (relHref && relHref[0] === "#") {
        this.hash(relHref.slice(1));
        return true;
      }
      var appUrl, prevAppUrl;
      var rewrittenUrl;
      if (isDefined((appUrl = beginsWith(appBase, url)))) {
        prevAppUrl = appUrl;
        if (isDefined((appUrl = beginsWith(basePrefix, appUrl)))) {
          rewrittenUrl = appBaseNoFile + (beginsWith("/", appUrl) || appUrl);
        } else {
          rewrittenUrl = appBase + prevAppUrl;
        }
      } else if (isDefined((appUrl = beginsWith(appBaseNoFile, url)))) {
        rewrittenUrl = appBaseNoFile + appUrl;
      } else if (appBaseNoFile == url + "/") {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
  }
  function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function (url) {
      var withoutBaseUrl =
        beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
      var withoutHashUrl;
      if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
        withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
        if (isUndefined(withoutHashUrl)) {
          withoutHashUrl = withoutBaseUrl;
        }
      } else {
        if (this.$$html5) {
          withoutHashUrl = withoutBaseUrl;
        } else {
          withoutHashUrl = "";
          if (isUndefined(withoutBaseUrl)) {
            appBase = url;
            this.replace();
          }
        }
      }
      parseAppUrl(withoutHashUrl, this);
      this.$$path = removeWindowsDriveName(
        this.$$path,
        withoutHashUrl,
        appBase
      );
      this.$$compose();
      function removeWindowsDriveName(path, url, base) {
        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
        var firstPathSegmentMatch;
        if (url.indexOf(base) === 0) {
          url = url.replace(base, "");
        }
        if (windowsFilePathExp.exec(url)) {
          return path;
        }
        firstPathSegmentMatch = windowsFilePathExp.exec(path);
        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
      }
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url =
        encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
    };
    this.$$parseLinkUrl = function (url, relHref) {
      if (stripHash(appBase) == stripHash(url)) {
        this.$$parse(url);
        return true;
      }
      return false;
    };
  }
  function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
    this.$$html5 = true;
    LocationHashbangUrl.apply(this, arguments);
    this.$$parseLinkUrl = function (url, relHref) {
      if (relHref && relHref[0] === "#") {
        this.hash(relHref.slice(1));
        return true;
      }
      var rewrittenUrl;
      var appUrl;
      if (appBase == stripHash(url)) {
        rewrittenUrl = url;
      } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
        rewrittenUrl = appBase + hashPrefix + appUrl;
      } else if (appBaseNoFile === url + "/") {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url =
        encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBase + hashPrefix + this.$$url;
    };
  }
  var locationPrototype = {
    $$html5: false,
    $$replace: false,
    absUrl: locationGetter("$$absUrl"),
    url: function (url) {
      if (isUndefined(url)) {
        return this.$$url;
      }
      var match = PATH_MATCH.exec(url);
      if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1] || url === "") this.search(match[3] || "");
      this.hash(match[5] || "");
      return this;
    },
    protocol: locationGetter("$$protocol"),
    host: locationGetter("$$host"),
    port: locationGetter("$$port"),
    path: locationGetterSetter("$$path", function (path) {
      path = path !== null ? path.toString() : "";
      return path.charAt(0) == "/" ? path : "/" + path;
    }),
    search: function (search, paramValue) {
      switch (arguments.length) {
        case 0:
          return this.$$search;
        case 1:
          if (isString(search) || isNumber(search)) {
            search = search.toString();
            this.$$search = parseKeyValue(search);
          } else if (isObject(search)) {
            search = copy(search, {});
            forEach(search, function (value, key) {
              if (value == null) delete search[key];
            });
            this.$$search = search;
          } else {
            throw $locationMinErr(
              "isrcharg",
              "The first argument of the `$location#search()` call must be a string or an object."
            );
          }
          break;
        default:
          if (isUndefined(paramValue) || paramValue === null) {
            delete this.$$search[search];
          } else {
            this.$$search[search] = paramValue;
          }
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter("$$hash", function (hash) {
      return hash !== null ? hash.toString() : "";
    }),
    replace: function () {
      this.$$replace = true;
      return this;
    },
  };
  forEach(
    [LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url],
    function (Location) {
      Location.prototype = Object.create(locationPrototype);
      Location.prototype.state = function (state) {
        if (!arguments.length) {
          return this.$$state;
        }
        if (Location !== LocationHtml5Url || !this.$$html5) {
          throw $locationMinErr(
            "nostate",
            "History API state support is available only " +
              "in HTML5 mode and only in browsers supporting HTML5 History API"
          );
        }
        this.$$state = isUndefined(state) ? null : state;
        return this;
      };
    }
  );
  function locationGetter(property) {
    return function () {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function (value) {
      if (isUndefined(value)) {
        return this[property];
      }
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = "",
      html5Mode = { enabled: false, requireBase: true, rewriteLinks: true };
    this.hashPrefix = function (prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function (mode) {
      if (isBoolean(mode)) {
        html5Mode.enabled = mode;
        return this;
      } else if (isObject(mode)) {
        if (isBoolean(mode.enabled)) {
          html5Mode.enabled = mode.enabled;
        }
        if (isBoolean(mode.requireBase)) {
          html5Mode.requireBase = mode.requireBase;
        }
        if (isBoolean(mode.rewriteLinks)) {
          html5Mode.rewriteLinks = mode.rewriteLinks;
        }
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [
      "$rootScope",
      "$browser",
      "$sniffer",
      "$rootElement",
      "$window",
      function ($rootScope, $browser, $sniffer, $rootElement, $window) {
        var $location,
          LocationMode,
          baseHref = $browser.baseHref(),
          initialUrl = $browser.url(),
          appBase;
        if (html5Mode.enabled) {
          if (!baseHref && html5Mode.requireBase) {
            throw $locationMinErr(
              "nobase",
              "$location in HTML5 mode requires a <base> tag to be present!"
            );
          }
          appBase = serverBase(initialUrl) + (baseHref || "/");
          LocationMode = $sniffer.history
            ? LocationHtml5Url
            : LocationHashbangInHtml5Url;
        } else {
          appBase = stripHash(initialUrl);
          LocationMode = LocationHashbangUrl;
        }
        var appBaseNoFile = stripFile(appBase);
        $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
        $location.$$parseLinkUrl(initialUrl, initialUrl);
        $location.$$state = $browser.state();
        var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
        function setBrowserUrlWithFallback(url, replace, state) {
          var oldUrl = $location.url();
          var oldState = $location.$$state;
          try {
            $browser.url(url, replace, state);
            $location.$$state = $browser.state();
          } catch (e) {
            $location.url(oldUrl);
            $location.$$state = oldState;
            throw e;
          }
        }
        $rootElement.on("click", function (event) {
          if (
            !html5Mode.rewriteLinks ||
            event.ctrlKey ||
            event.metaKey ||
            event.shiftKey ||
            event.which == 2 ||
            event.button == 2
          )
            return;
          var elm = jqLite(event.target);
          while (nodeName_(elm[0]) !== "a") {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
          }
          var absHref = elm.prop("href");
          var relHref = elm.attr("href") || elm.attr("xlink:href");
          if (
            isObject(absHref) &&
            absHref.toString() === "[object SVGAnimatedString]"
          ) {
            absHref = urlResolve(absHref.animVal).href;
          }
          if (IGNORE_URI_REGEXP.test(absHref)) return;
          if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
            if ($location.$$parseLinkUrl(absHref, relHref)) {
              event.preventDefault();
              if ($location.absUrl() != $browser.url()) {
                $rootScope.$apply();
                $window.angular["ff-684208-preventDefault"] = true;
              }
            }
          }
        });
        if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
          $browser.url($location.absUrl(), true);
        }
        var initializing = true;
        $browser.onUrlChange(function (newUrl, newState) {
          if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
            $window.location.href = newUrl;
            return;
          }
          $rootScope.$evalAsync(function () {
            var oldUrl = $location.absUrl();
            var oldState = $location.$$state;
            var defaultPrevented;
            newUrl = trimEmptyHash(newUrl);
            $location.$$parse(newUrl);
            $location.$$state = newState;
            defaultPrevented = $rootScope.$broadcast(
              "$locationChangeStart",
              newUrl,
              oldUrl,
              newState,
              oldState
            ).defaultPrevented;
            if ($location.absUrl() !== newUrl) return;
            if (defaultPrevented) {
              $location.$$parse(oldUrl);
              $location.$$state = oldState;
              setBrowserUrlWithFallback(oldUrl, false, oldState);
            } else {
              initializing = false;
              afterLocationChange(oldUrl, oldState);
            }
          });
          if (!$rootScope.$$phase) $rootScope.$digest();
        });
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = trimEmptyHash($browser.url());
          var newUrl = trimEmptyHash($location.absUrl());
          var oldState = $browser.state();
          var currentReplace = $location.$$replace;
          var urlOrStateChanged =
            oldUrl !== newUrl ||
            ($location.$$html5 &&
              $sniffer.history &&
              oldState !== $location.$$state);
          if (initializing || urlOrStateChanged) {
            initializing = false;
            $rootScope.$evalAsync(function () {
              var newUrl = $location.absUrl();
              var defaultPrevented = $rootScope.$broadcast(
                "$locationChangeStart",
                newUrl,
                oldUrl,
                $location.$$state,
                oldState
              ).defaultPrevented;
              if ($location.absUrl() !== newUrl) return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
              } else {
                if (urlOrStateChanged) {
                  setBrowserUrlWithFallback(
                    newUrl,
                    currentReplace,
                    oldState === $location.$$state ? null : $location.$$state
                  );
                }
                afterLocationChange(oldUrl, oldState);
              }
            });
          }
          $location.$$replace = false;
        });
        return $location;
        function afterLocationChange(oldUrl, oldState) {
          $rootScope.$broadcast(
            "$locationChangeSuccess",
            $location.absUrl(),
            oldUrl,
            $location.$$state,
            oldState
          );
        }
      },
    ];
  }
  function $LogProvider() {
    var debug = true,
      self = this;
    this.debugEnabled = function (flag) {
      if (isDefined(flag)) {
        debug = flag;
        return this;
      } else {
        return debug;
      }
    };
    this.$get = [
      "$window",
      function ($window) {
        return {
          log: consoleLog("log"),
          info: consoleLog("info"),
          warn: consoleLog("warn"),
          error: consoleLog("error"),
          debug: (function () {
            var fn = consoleLog("debug");
            return function () {
              if (debug) {
                fn.apply(self, arguments);
              }
            };
          })(),
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg =
                arg.message && arg.stack.indexOf(arg.message) === -1
                  ? "Error: " + arg.message + "\n" + arg.stack
                  : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {},
            logFn = console[type] || console.log || noop,
            hasApply = false;
          try {
            hasApply = !!logFn.apply;
          } catch (e) {}
          if (hasApply) {
            return function () {
              var args = [];
              forEach(arguments, function (arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function (arg1, arg2) {
            logFn(arg1, arg2 == null ? "" : arg2);
          };
        }
      },
    ];
  }
  var $parseMinErr = minErr("$parse");
  function ensureSafeMemberName(name, fullExpression) {
    if (
      name === "__defineGetter__" ||
      name === "__defineSetter__" ||
      name === "__lookupGetter__" ||
      name === "__lookupSetter__" ||
      name === "__proto__"
    ) {
      throw $parseMinErr(
        "isecfld",
        "Attempting to access a disallowed field in Angular expressions! " +
          "Expression: {0}",
        fullExpression
      );
    }
    return name;
  }
  function getStringValue(name, fullExpression) {
    name = name + "";
    if (!isString(name)) {
      throw $parseMinErr(
        "iseccst",
        "Cannot convert object to primitive value! " + "Expression: {0}",
        fullExpression
      );
    }
    return name;
  }
  function ensureSafeObject(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr(
          "isecfn",
          "Referencing Function in Angular expressions is disallowed! Expression: {0}",
          fullExpression
        );
      } else if (obj.window === obj) {
        throw $parseMinErr(
          "isecwindow",
          "Referencing the Window in Angular expressions is disallowed! Expression: {0}",
          fullExpression
        );
      } else if (
        obj.children &&
        (obj.nodeName || (obj.prop && obj.attr && obj.find))
      ) {
        throw $parseMinErr(
          "isecdom",
          "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}",
          fullExpression
        );
      } else if (obj === Object) {
        throw $parseMinErr(
          "isecobj",
          "Referencing Object in Angular expressions is disallowed! Expression: {0}",
          fullExpression
        );
      }
    }
    return obj;
  }
  var CALL = Function.prototype.call;
  var APPLY = Function.prototype.apply;
  var BIND = Function.prototype.bind;
  function ensureSafeFunction(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr(
          "isecfn",
          "Referencing Function in Angular expressions is disallowed! Expression: {0}",
          fullExpression
        );
      } else if (obj === CALL || obj === APPLY || obj === BIND) {
        throw $parseMinErr(
          "isecff",
          "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}",
          fullExpression
        );
      }
    }
  }
  function ensureSafeAssignContext(obj, fullExpression) {
    if (obj) {
      if (
        obj === (0).constructor ||
        obj === false.constructor ||
        obj === "".constructor ||
        obj === {}.constructor ||
        obj === [].constructor ||
        obj === Function.constructor
      ) {
        throw $parseMinErr(
          "isecaf",
          "Assigning to a constructor is disallowed! Expression: {0}",
          fullExpression
        );
      }
    }
  }
  var OPERATORS = createMap();
  forEach(
    "+ - * / % === !== == != < > <= >= && || ! = |".split(" "),
    function (operator) {
      OPERATORS[operator] = true;
    }
  );
  var ESCAPE = {
    n: "\n",
    f: "\f",
    r: "\r",
    t: "\t",
    v: "\v",
    "'": "'",
    '"': '"',
  };
  var Lexer = function (options) {
    this.options = options;
  };
  Lexer.prototype = {
    constructor: Lexer,
    lex: function (text) {
      this.text = text;
      this.index = 0;
      this.tokens = [];
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        if (ch === '"' || ch === "'") {
          this.readString(ch);
        } else if (
          this.isNumber(ch) ||
          (ch === "." && this.isNumber(this.peek()))
        ) {
          this.readNumber();
        } else if (this.isIdent(ch)) {
          this.readIdent();
        } else if (this.is(ch, "(){}[].,;:?")) {
          this.tokens.push({ index: this.index, text: ch });
          this.index++;
        } else if (this.isWhitespace(ch)) {
          this.index++;
        } else {
          var ch2 = ch + this.peek();
          var ch3 = ch2 + this.peek(2);
          var op1 = OPERATORS[ch];
          var op2 = OPERATORS[ch2];
          var op3 = OPERATORS[ch3];
          if (op1 || op2 || op3) {
            var token = op3 ? ch3 : op2 ? ch2 : ch;
            this.tokens.push({
              index: this.index,
              text: token,
              operator: true,
            });
            this.index += token.length;
          } else {
            this.throwError(
              "Unexpected next character ",
              this.index,
              this.index + 1
            );
          }
        }
      }
      return this.tokens;
    },
    is: function (ch, chars) {
      return chars.indexOf(ch) !== -1;
    },
    peek: function (i) {
      var num = i || 1;
      return this.index + num < this.text.length
        ? this.text.charAt(this.index + num)
        : false;
    },
    isNumber: function (ch) {
      return "0" <= ch && ch <= "9" && typeof ch === "string";
    },
    isWhitespace: function (ch) {
      return (
        ch === " " ||
        ch === "\r" ||
        ch === "\t" ||
        ch === "\n" ||
        ch === "\v" ||
        ch === "\u00A0"
      );
    },
    isIdent: function (ch) {
      return (
        ("a" <= ch && ch <= "z") ||
        ("A" <= ch && ch <= "Z") ||
        "_" === ch ||
        ch === "$"
      );
    },
    isExpOperator: function (ch) {
      return ch === "-" || ch === "+" || this.isNumber(ch);
    },
    throwError: function (error, start, end) {
      end = end || this.index;
      var colStr = isDefined(start)
        ? "s " +
          start +
          "-" +
          this.index +
          " [" +
          this.text.substring(start, end) +
          "]"
        : " " + end;
      throw $parseMinErr(
        "lexerr",
        "Lexer Error: {0} at column{1} in expression [{2}].",
        error,
        colStr,
        this.text
      );
    },
    readNumber: function () {
      var number = "";
      var start = this.index;
      while (this.index < this.text.length) {
        var ch = lowercase(this.text.charAt(this.index));
        if (ch == "." || this.isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = this.peek();
          if (ch == "e" && this.isExpOperator(peekCh)) {
            number += ch;
          } else if (
            this.isExpOperator(ch) &&
            peekCh &&
            this.isNumber(peekCh) &&
            number.charAt(number.length - 1) == "e"
          ) {
            number += ch;
          } else if (
            this.isExpOperator(ch) &&
            (!peekCh || !this.isNumber(peekCh)) &&
            number.charAt(number.length - 1) == "e"
          ) {
            this.throwError("Invalid exponent");
          } else {
            break;
          }
        }
        this.index++;
      }
      this.tokens.push({
        index: start,
        text: number,
        constant: true,
        value: Number(number),
      });
    },
    readIdent: function () {
      var start = this.index;
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        if (!(this.isIdent(ch) || this.isNumber(ch))) {
          break;
        }
        this.index++;
      }
      this.tokens.push({
        index: start,
        text: this.text.slice(start, this.index),
        identifier: true,
      });
    },
    readString: function (quote) {
      var start = this.index;
      this.index++;
      var string = "";
      var rawString = quote;
      var escape = false;
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        rawString += ch;
        if (escape) {
          if (ch === "u") {
            var hex = this.text.substring(this.index + 1, this.index + 5);
            if (!hex.match(/[\da-f]{4}/i)) {
              this.throwError("Invalid unicode escape [\\u" + hex + "]");
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            string = string + (rep || ch);
          }
          escape = false;
        } else if (ch === "\\") {
          escape = true;
        } else if (ch === quote) {
          this.index++;
          this.tokens.push({
            index: start,
            text: rawString,
            constant: true,
            value: string,
          });
          return;
        } else {
          string += ch;
        }
        this.index++;
      }
      this.throwError("Unterminated quote", start);
    },
  };
  var AST = function (lexer, options) {
    this.lexer = lexer;
    this.options = options;
  };
  AST.Program = "Program";
  AST.ExpressionStatement = "ExpressionStatement";
  AST.AssignmentExpression = "AssignmentExpression";
  AST.ConditionalExpression = "ConditionalExpression";
  AST.LogicalExpression = "LogicalExpression";
  AST.BinaryExpression = "BinaryExpression";
  AST.UnaryExpression = "UnaryExpression";
  AST.CallExpression = "CallExpression";
  AST.MemberExpression = "MemberExpression";
  AST.Identifier = "Identifier";
  AST.Literal = "Literal";
  AST.ArrayExpression = "ArrayExpression";
  AST.Property = "Property";
  AST.ObjectExpression = "ObjectExpression";
  AST.ThisExpression = "ThisExpression";
  AST.NGValueParameter = "NGValueParameter";
  AST.prototype = {
    ast: function (text) {
      this.text = text;
      this.tokens = this.lexer.lex(text);
      var value = this.program();
      if (this.tokens.length !== 0) {
        this.throwError("is an unexpected token", this.tokens[0]);
      }
      return value;
    },
    program: function () {
      var body = [];
      while (true) {
        if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))
          body.push(this.expressionStatement());
        if (!this.expect(";")) {
          return { type: AST.Program, body: body };
        }
      }
    },
    expressionStatement: function () {
      return { type: AST.ExpressionStatement, expression: this.filterChain() };
    },
    filterChain: function () {
      var left = this.expression();
      var token;
      while ((token = this.expect("|"))) {
        left = this.filter(left);
      }
      return left;
    },
    expression: function () {
      return this.assignment();
    },
    assignment: function () {
      var result = this.ternary();
      if (this.expect("=")) {
        result = {
          type: AST.AssignmentExpression,
          left: result,
          right: this.assignment(),
          operator: "=",
        };
      }
      return result;
    },
    ternary: function () {
      var test = this.logicalOR();
      var alternate;
      var consequent;
      if (this.expect("?")) {
        alternate = this.expression();
        if (this.consume(":")) {
          consequent = this.expression();
          return {
            type: AST.ConditionalExpression,
            test: test,
            alternate: alternate,
            consequent: consequent,
          };
        }
      }
      return test;
    },
    logicalOR: function () {
      var left = this.logicalAND();
      while (this.expect("||")) {
        left = {
          type: AST.LogicalExpression,
          operator: "||",
          left: left,
          right: this.logicalAND(),
        };
      }
      return left;
    },
    logicalAND: function () {
      var left = this.equality();
      while (this.expect("&&")) {
        left = {
          type: AST.LogicalExpression,
          operator: "&&",
          left: left,
          right: this.equality(),
        };
      }
      return left;
    },
    equality: function () {
      var left = this.relational();
      var token;
      while ((token = this.expect("==", "!=", "===", "!=="))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.relational(),
        };
      }
      return left;
    },
    relational: function () {
      var left = this.additive();
      var token;
      while ((token = this.expect("<", ">", "<=", ">="))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.additive(),
        };
      }
      return left;
    },
    additive: function () {
      var left = this.multiplicative();
      var token;
      while ((token = this.expect("+", "-"))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.multiplicative(),
        };
      }
      return left;
    },
    multiplicative: function () {
      var left = this.unary();
      var token;
      while ((token = this.expect("*", "/", "%"))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.unary(),
        };
      }
      return left;
    },
    unary: function () {
      var token;
      if ((token = this.expect("+", "-", "!"))) {
        return {
          type: AST.UnaryExpression,
          operator: token.text,
          prefix: true,
          argument: this.unary(),
        };
      } else {
        return this.primary();
      }
    },
    primary: function () {
      var primary;
      if (this.expect("(")) {
        primary = this.filterChain();
        this.consume(")");
      } else if (this.expect("[")) {
        primary = this.arrayDeclaration();
      } else if (this.expect("{")) {
        primary = this.object();
      } else if (this.constants.hasOwnProperty(this.peek().text)) {
        primary = copy(this.constants[this.consume().text]);
      } else if (this.peek().identifier) {
        primary = this.identifier();
      } else if (this.peek().constant) {
        primary = this.constant();
      } else {
        this.throwError("not a primary expression", this.peek());
      }
      var next;
      while ((next = this.expect("(", "[", "."))) {
        if (next.text === "(") {
          primary = {
            type: AST.CallExpression,
            callee: primary,
            arguments: this.parseArguments(),
          };
          this.consume(")");
        } else if (next.text === "[") {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.expression(),
            computed: true,
          };
          this.consume("]");
        } else if (next.text === ".") {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.identifier(),
            computed: false,
          };
        } else {
          this.throwError("IMPOSSIBLE");
        }
      }
      return primary;
    },
    filter: function (baseExpression) {
      var args = [baseExpression];
      var result = {
        type: AST.CallExpression,
        callee: this.identifier(),
        arguments: args,
        filter: true,
      };
      while (this.expect(":")) {
        args.push(this.expression());
      }
      return result;
    },
    parseArguments: function () {
      var args = [];
      if (this.peekToken().text !== ")") {
        do {
          args.push(this.expression());
        } while (this.expect(","));
      }
      return args;
    },
    identifier: function () {
      var token = this.consume();
      if (!token.identifier) {
        this.throwError("is not a valid identifier", token);
      }
      return { type: AST.Identifier, name: token.text };
    },
    constant: function () {
      return { type: AST.Literal, value: this.consume().value };
    },
    arrayDeclaration: function () {
      var elements = [];
      if (this.peekToken().text !== "]") {
        do {
          if (this.peek("]")) {
            break;
          }
          elements.push(this.expression());
        } while (this.expect(","));
      }
      this.consume("]");
      return { type: AST.ArrayExpression, elements: elements };
    },
    object: function () {
      var properties = [],
        property;
      if (this.peekToken().text !== "}") {
        do {
          if (this.peek("}")) {
            break;
          }
          property = { type: AST.Property, kind: "init" };
          if (this.peek().constant) {
            property.key = this.constant();
          } else if (this.peek().identifier) {
            property.key = this.identifier();
          } else {
            this.throwError("invalid key", this.peek());
          }
          this.consume(":");
          property.value = this.expression();
          properties.push(property);
        } while (this.expect(","));
      }
      this.consume("}");
      return { type: AST.ObjectExpression, properties: properties };
    },
    throwError: function (msg, token) {
      throw $parseMinErr(
        "syntax",
        "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
        token.text,
        msg,
        token.index + 1,
        this.text,
        this.text.substring(token.index)
      );
    },
    consume: function (e1) {
      if (this.tokens.length === 0) {
        throw $parseMinErr(
          "ueoe",
          "Unexpected end of expression: {0}",
          this.text
        );
      }
      var token = this.expect(e1);
      if (!token) {
        this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
      }
      return token;
    },
    peekToken: function () {
      if (this.tokens.length === 0) {
        throw $parseMinErr(
          "ueoe",
          "Unexpected end of expression: {0}",
          this.text
        );
      }
      return this.tokens[0];
    },
    peek: function (e1, e2, e3, e4) {
      return this.peekAhead(0, e1, e2, e3, e4);
    },
    peekAhead: function (i, e1, e2, e3, e4) {
      if (this.tokens.length > i) {
        var token = this.tokens[i];
        var t = token.text;
        if (
          t === e1 ||
          t === e2 ||
          t === e3 ||
          t === e4 ||
          (!e1 && !e2 && !e3 && !e4)
        ) {
          return token;
        }
      }
      return false;
    },
    expect: function (e1, e2, e3, e4) {
      var token = this.peek(e1, e2, e3, e4);
      if (token) {
        this.tokens.shift();
        return token;
      }
      return false;
    },
    constants: {
      true: { type: AST.Literal, value: true },
      false: { type: AST.Literal, value: false },
      null: { type: AST.Literal, value: null },
      undefined: { type: AST.Literal, value: undefined },
      this: { type: AST.ThisExpression },
    },
  };
  function ifDefined(v, d) {
    return typeof v !== "undefined" ? v : d;
  }
  function plusFn(l, r) {
    if (typeof l === "undefined") return r;
    if (typeof r === "undefined") return l;
    return l + r;
  }
  function isStateless($filter, filterName) {
    var fn = $filter(filterName);
    return !fn.$stateful;
  }
  function findConstantAndWatchExpressions(ast, $filter) {
    var allConstants;
    var argsToWatch;
    switch (ast.type) {
      case AST.Program:
        allConstants = true;
        forEach(ast.body, function (expr) {
          findConstantAndWatchExpressions(expr.expression, $filter);
          allConstants = allConstants && expr.expression.constant;
        });
        ast.constant = allConstants;
        break;
      case AST.Literal:
        ast.constant = true;
        ast.toWatch = [];
        break;
      case AST.UnaryExpression:
        findConstantAndWatchExpressions(ast.argument, $filter);
        ast.constant = ast.argument.constant;
        ast.toWatch = ast.argument.toWatch;
        break;
      case AST.BinaryExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
        break;
      case AST.LogicalExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.ConditionalExpression:
        findConstantAndWatchExpressions(ast.test, $filter);
        findConstantAndWatchExpressions(ast.alternate, $filter);
        findConstantAndWatchExpressions(ast.consequent, $filter);
        ast.constant =
          ast.test.constant &&
          ast.alternate.constant &&
          ast.consequent.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.Identifier:
        ast.constant = false;
        ast.toWatch = [ast];
        break;
      case AST.MemberExpression:
        findConstantAndWatchExpressions(ast.object, $filter);
        if (ast.computed) {
          findConstantAndWatchExpressions(ast.property, $filter);
        }
        ast.constant =
          ast.object.constant && (!ast.computed || ast.property.constant);
        ast.toWatch = [ast];
        break;
      case AST.CallExpression:
        allConstants = ast.filter
          ? isStateless($filter, ast.callee.name)
          : false;
        argsToWatch = [];
        forEach(ast.arguments, function (expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants && expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch =
          ast.filter && isStateless($filter, ast.callee.name)
            ? argsToWatch
            : [ast];
        break;
      case AST.AssignmentExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = [ast];
        break;
      case AST.ArrayExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.elements, function (expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants && expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ObjectExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.properties, function (property) {
          findConstantAndWatchExpressions(property.value, $filter);
          allConstants = allConstants && property.value.constant;
          if (!property.value.constant) {
            argsToWatch.push.apply(argsToWatch, property.value.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ThisExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
    }
  }
  function getInputs(body) {
    if (body.length != 1) return;
    var lastExpression = body[0].expression;
    var candidate = lastExpression.toWatch;
    if (candidate.length !== 1) return candidate;
    return candidate[0] !== lastExpression ? candidate : undefined;
  }
  function isAssignable(ast) {
    return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
  }
  function assignableAST(ast) {
    if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
      return {
        type: AST.AssignmentExpression,
        left: ast.body[0].expression,
        right: { type: AST.NGValueParameter },
        operator: "=",
      };
    }
  }
  function isLiteral(ast) {
    return (
      ast.body.length === 0 ||
      (ast.body.length === 1 &&
        (ast.body[0].expression.type === AST.Literal ||
          ast.body[0].expression.type === AST.ArrayExpression ||
          ast.body[0].expression.type === AST.ObjectExpression))
    );
  }
  function isConstant(ast) {
    return ast.constant;
  }
  function ASTCompiler(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTCompiler.prototype = {
    compile: function (expression, expensiveChecks) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      this.state = {
        nextId: 0,
        filters: {},
        expensiveChecks: expensiveChecks,
        fn: { vars: [], body: [], own: {} },
        assign: { vars: [], body: [], own: {} },
        inputs: [],
      };
      findConstantAndWatchExpressions(ast, self.$filter);
      var extra = "";
      var assignable;
      this.stage = "assign";
      if ((assignable = assignableAST(ast))) {
        this.state.computing = "assign";
        var result = this.nextId();
        this.recurse(assignable, result);
        this.return_(result);
        extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
      }
      var toWatch = getInputs(ast.body);
      self.stage = "inputs";
      forEach(toWatch, function (watch, key) {
        var fnKey = "fn" + key;
        self.state[fnKey] = { vars: [], body: [], own: {} };
        self.state.computing = fnKey;
        var intoId = self.nextId();
        self.recurse(watch, intoId);
        self.return_(intoId);
        self.state.inputs.push(fnKey);
        watch.watchId = key;
      });
      this.state.computing = "fn";
      this.stage = "main";
      this.recurse(ast);
      var fnString =
        '"' +
        this.USE +
        " " +
        this.STRICT +
        '";\n' +
        this.filterPrefix() +
        "var fn=" +
        this.generateFunction("fn", "s,l,a,i") +
        extra +
        this.watchFns() +
        "return fn;";
      var fn = new Function(
        "$filter",
        "ensureSafeMemberName",
        "ensureSafeObject",
        "ensureSafeFunction",
        "getStringValue",
        "ensureSafeAssignContext",
        "ifDefined",
        "plus",
        "text",
        fnString
      )(
        this.$filter,
        ensureSafeMemberName,
        ensureSafeObject,
        ensureSafeFunction,
        getStringValue,
        ensureSafeAssignContext,
        ifDefined,
        plusFn,
        expression
      );
      this.state = this.stage = undefined;
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    USE: "use",
    STRICT: "strict",
    watchFns: function () {
      var result = [];
      var fns = this.state.inputs;
      var self = this;
      forEach(fns, function (name) {
        result.push("var " + name + "=" + self.generateFunction(name, "s"));
      });
      if (fns.length) {
        result.push("fn.inputs=[" + fns.join(",") + "];");
      }
      return result.join("");
    },
    generateFunction: function (name, params) {
      return (
        "function(" +
        params +
        "){" +
        this.varsPrefix(name) +
        this.body(name) +
        "};"
      );
    },
    filterPrefix: function () {
      var parts = [];
      var self = this;
      forEach(this.state.filters, function (id, filter) {
        parts.push(id + "=$filter(" + self.escape(filter) + ")");
      });
      if (parts.length) return "var " + parts.join(",") + ";";
      return "";
    },
    varsPrefix: function (section) {
      return this.state[section].vars.length
        ? "var " + this.state[section].vars.join(",") + ";"
        : "";
    },
    body: function (section) {
      return this.state[section].body.join("");
    },
    recurse: function (
      ast,
      intoId,
      nameId,
      recursionFn,
      create,
      skipWatchIdCheck
    ) {
      var left,
        right,
        self = this,
        args,
        expression;
      recursionFn = recursionFn || noop;
      if (!skipWatchIdCheck && isDefined(ast.watchId)) {
        intoId = intoId || this.nextId();
        this.if_(
          "i",
          this.lazyAssign(intoId, this.computedMember("i", ast.watchId)),
          this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)
        );
        return;
      }
      switch (ast.type) {
        case AST.Program:
          forEach(ast.body, function (expression, pos) {
            self.recurse(
              expression.expression,
              undefined,
              undefined,
              function (expr) {
                right = expr;
              }
            );
            if (pos !== ast.body.length - 1) {
              self.current().body.push(right, ";");
            } else {
              self.return_(right);
            }
          });
          break;
        case AST.Literal:
          expression = this.escape(ast.value);
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.UnaryExpression:
          this.recurse(ast.argument, undefined, undefined, function (expr) {
            right = expr;
          });
          expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.BinaryExpression:
          this.recurse(ast.left, undefined, undefined, function (expr) {
            left = expr;
          });
          this.recurse(ast.right, undefined, undefined, function (expr) {
            right = expr;
          });
          if (ast.operator === "+") {
            expression = this.plus(left, right);
          } else if (ast.operator === "-") {
            expression =
              this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
          } else {
            expression = "(" + left + ")" + ast.operator + "(" + right + ")";
          }
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.LogicalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.left, intoId);
          self.if_(
            ast.operator === "&&" ? intoId : self.not(intoId),
            self.lazyRecurse(ast.right, intoId)
          );
          recursionFn(intoId);
          break;
        case AST.ConditionalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.test, intoId);
          self.if_(
            intoId,
            self.lazyRecurse(ast.alternate, intoId),
            self.lazyRecurse(ast.consequent, intoId)
          );
          recursionFn(intoId);
          break;
        case AST.Identifier:
          intoId = intoId || this.nextId();
          if (nameId) {
            nameId.context =
              self.stage === "inputs"
                ? "s"
                : this.assign(
                    this.nextId(),
                    this.getHasOwnProperty("l", ast.name) + "?l:s"
                  );
            nameId.computed = false;
            nameId.name = ast.name;
          }
          ensureSafeMemberName(ast.name);
          self.if_(
            self.stage === "inputs" ||
              self.not(self.getHasOwnProperty("l", ast.name)),
            function () {
              self.if_(self.stage === "inputs" || "s", function () {
                if (create && create !== 1) {
                  self.if_(
                    self.not(self.nonComputedMember("s", ast.name)),
                    self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")
                  );
                }
                self.assign(intoId, self.nonComputedMember("s", ast.name));
              });
            },
            intoId &&
              self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))
          );
          if (
            self.state.expensiveChecks ||
            isPossiblyDangerousMemberName(ast.name)
          ) {
            self.addEnsureSafeObject(intoId);
          }
          recursionFn(intoId);
          break;
        case AST.MemberExpression:
          left = (nameId && (nameId.context = this.nextId())) || this.nextId();
          intoId = intoId || this.nextId();
          self.recurse(
            ast.object,
            left,
            undefined,
            function () {
              self.if_(
                self.notNull(left),
                function () {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(
                        self.not(self.computedMember(left, right)),
                        self.lazyAssign(self.computedMember(left, right), "{}")
                      );
                    }
                    expression = self.ensureSafeObject(
                      self.computedMember(left, right)
                    );
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(
                        self.not(
                          self.nonComputedMember(left, ast.property.name)
                        ),
                        self.lazyAssign(
                          self.nonComputedMember(left, ast.property.name),
                          "{}"
                        )
                      );
                    }
                    expression = self.nonComputedMember(
                      left,
                      ast.property.name
                    );
                    if (
                      self.state.expensiveChecks ||
                      isPossiblyDangerousMemberName(ast.property.name)
                    ) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                },
                function () {
                  self.assign(intoId, "undefined");
                }
              );
              recursionFn(intoId);
            },
            !!create
          );
          break;
        case AST.CallExpression:
          intoId = intoId || this.nextId();
          if (ast.filter) {
            right = self.filter(ast.callee.name);
            args = [];
            forEach(ast.arguments, function (expr) {
              var argument = self.nextId();
              self.recurse(expr, argument);
              args.push(argument);
            });
            expression = right + "(" + args.join(",") + ")";
            self.assign(intoId, expression);
            recursionFn(intoId);
          } else {
            right = self.nextId();
            left = {};
            args = [];
            self.recurse(ast.callee, right, left, function () {
              self.if_(
                self.notNull(right),
                function () {
                  self.addEnsureSafeFunction(right);
                  forEach(ast.arguments, function (expr) {
                    self.recurse(
                      expr,
                      self.nextId(),
                      undefined,
                      function (argument) {
                        args.push(self.ensureSafeObject(argument));
                      }
                    );
                  });
                  if (left.name) {
                    if (!self.state.expensiveChecks) {
                      self.addEnsureSafeObject(left.context);
                    }
                    expression =
                      self.member(left.context, left.name, left.computed) +
                      "(" +
                      args.join(",") +
                      ")";
                  } else {
                    expression = right + "(" + args.join(",") + ")";
                  }
                  expression = self.ensureSafeObject(expression);
                  self.assign(intoId, expression);
                },
                function () {
                  self.assign(intoId, "undefined");
                }
              );
              recursionFn(intoId);
            });
          }
          break;
        case AST.AssignmentExpression:
          right = this.nextId();
          left = {};
          if (!isAssignable(ast.left)) {
            throw $parseMinErr(
              "lval",
              "Trying to assign a value to a non l-value"
            );
          }
          this.recurse(
            ast.left,
            undefined,
            left,
            function () {
              self.if_(self.notNull(left.context), function () {
                self.recurse(ast.right, right);
                self.addEnsureSafeObject(
                  self.member(left.context, left.name, left.computed)
                );
                self.addEnsureSafeAssignContext(left.context);
                expression =
                  self.member(left.context, left.name, left.computed) +
                  ast.operator +
                  right;
                self.assign(intoId, expression);
                recursionFn(intoId || expression);
              });
            },
            1
          );
          break;
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function (expr) {
            self.recurse(expr, self.nextId(), undefined, function (argument) {
              args.push(argument);
            });
          });
          expression = "[" + args.join(",") + "]";
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.ObjectExpression:
          args = [];
          forEach(ast.properties, function (property) {
            self.recurse(
              property.value,
              self.nextId(),
              undefined,
              function (expr) {
                args.push(
                  self.escape(
                    property.key.type === AST.Identifier
                      ? property.key.name
                      : "" + property.key.value
                  ) +
                    ":" +
                    expr
                );
              }
            );
          });
          expression = "{" + args.join(",") + "}";
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.ThisExpression:
          this.assign(intoId, "s");
          recursionFn("s");
          break;
        case AST.NGValueParameter:
          this.assign(intoId, "v");
          recursionFn("v");
          break;
      }
    },
    getHasOwnProperty: function (element, property) {
      var key = element + "." + property;
      var own = this.current().own;
      if (!own.hasOwnProperty(key)) {
        own[key] = this.nextId(
          false,
          element + "&&(" + this.escape(property) + " in " + element + ")"
        );
      }
      return own[key];
    },
    assign: function (id, value) {
      if (!id) return;
      this.current().body.push(id, "=", value, ";");
      return id;
    },
    filter: function (filterName) {
      if (!this.state.filters.hasOwnProperty(filterName)) {
        this.state.filters[filterName] = this.nextId(true);
      }
      return this.state.filters[filterName];
    },
    ifDefined: function (id, defaultValue) {
      return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
    },
    plus: function (left, right) {
      return "plus(" + left + "," + right + ")";
    },
    return_: function (id) {
      this.current().body.push("return ", id, ";");
    },
    if_: function (test, alternate, consequent) {
      if (test === true) {
        alternate();
      } else {
        var body = this.current().body;
        body.push("if(", test, "){");
        alternate();
        body.push("}");
        if (consequent) {
          body.push("else{");
          consequent();
          body.push("}");
        }
      }
    },
    not: function (expression) {
      return "!(" + expression + ")";
    },
    notNull: function (expression) {
      return expression + "!=null";
    },
    nonComputedMember: function (left, right) {
      return left + "." + right;
    },
    computedMember: function (left, right) {
      return left + "[" + right + "]";
    },
    member: function (left, right, computed) {
      if (computed) return this.computedMember(left, right);
      return this.nonComputedMember(left, right);
    },
    addEnsureSafeObject: function (item) {
      this.current().body.push(this.ensureSafeObject(item), ";");
    },
    addEnsureSafeMemberName: function (item) {
      this.current().body.push(this.ensureSafeMemberName(item), ";");
    },
    addEnsureSafeFunction: function (item) {
      this.current().body.push(this.ensureSafeFunction(item), ";");
    },
    addEnsureSafeAssignContext: function (item) {
      this.current().body.push(this.ensureSafeAssignContext(item), ";");
    },
    ensureSafeObject: function (item) {
      return "ensureSafeObject(" + item + ",text)";
    },
    ensureSafeMemberName: function (item) {
      return "ensureSafeMemberName(" + item + ",text)";
    },
    ensureSafeFunction: function (item) {
      return "ensureSafeFunction(" + item + ",text)";
    },
    getStringValue: function (item) {
      this.assign(item, "getStringValue(" + item + ",text)");
    },
    ensureSafeAssignContext: function (item) {
      return "ensureSafeAssignContext(" + item + ",text)";
    },
    lazyRecurse: function (
      ast,
      intoId,
      nameId,
      recursionFn,
      create,
      skipWatchIdCheck
    ) {
      var self = this;
      return function () {
        self.recurse(
          ast,
          intoId,
          nameId,
          recursionFn,
          create,
          skipWatchIdCheck
        );
      };
    },
    lazyAssign: function (id, value) {
      var self = this;
      return function () {
        self.assign(id, value);
      };
    },
    stringEscapeRegex: /[^ a-zA-Z0-9]/g,
    stringEscapeFn: function (c) {
      return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    },
    escape: function (value) {
      if (isString(value))
        return (
          "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"
        );
      if (isNumber(value)) return value.toString();
      if (value === true) return "true";
      if (value === false) return "false";
      if (value === null) return "null";
      if (typeof value === "undefined") return "undefined";
      throw $parseMinErr("esc", "IMPOSSIBLE");
    },
    nextId: function (skip, init) {
      var id = "v" + this.state.nextId++;
      if (!skip) {
        this.current().vars.push(id + (init ? "=" + init : ""));
      }
      return id;
    },
    current: function () {
      return this.state[this.state.computing];
    },
  };
  function ASTInterpreter(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTInterpreter.prototype = {
    compile: function (expression, expensiveChecks) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      this.expression = expression;
      this.expensiveChecks = expensiveChecks;
      findConstantAndWatchExpressions(ast, self.$filter);
      var assignable;
      var assign;
      if ((assignable = assignableAST(ast))) {
        assign = this.recurse(assignable);
      }
      var toWatch = getInputs(ast.body);
      var inputs;
      if (toWatch) {
        inputs = [];
        forEach(toWatch, function (watch, key) {
          var input = self.recurse(watch);
          watch.input = input;
          inputs.push(input);
          watch.watchId = key;
        });
      }
      var expressions = [];
      forEach(ast.body, function (expression) {
        expressions.push(self.recurse(expression.expression));
      });
      var fn =
        ast.body.length === 0
          ? function () {}
          : ast.body.length === 1
          ? expressions[0]
          : function (scope, locals) {
              var lastValue;
              forEach(expressions, function (exp) {
                lastValue = exp(scope, locals);
              });
              return lastValue;
            };
      if (assign) {
        fn.assign = function (scope, value, locals) {
          return assign(scope, locals, value);
        };
      }
      if (inputs) {
        fn.inputs = inputs;
      }
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    recurse: function (ast, context, create) {
      var left,
        right,
        self = this,
        args,
        expression;
      if (ast.input) {
        return this.inputs(ast.input, ast.watchId);
      }
      switch (ast.type) {
        case AST.Literal:
          return this.value(ast.value, context);
        case AST.UnaryExpression:
          right = this.recurse(ast.argument);
          return this["unary" + ast.operator](right, context);
        case AST.BinaryExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this["binary" + ast.operator](left, right, context);
        case AST.LogicalExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this["binary" + ast.operator](left, right, context);
        case AST.ConditionalExpression:
          return this["ternary?:"](
            this.recurse(ast.test),
            this.recurse(ast.alternate),
            this.recurse(ast.consequent),
            context
          );
        case AST.Identifier:
          ensureSafeMemberName(ast.name, self.expression);
          return self.identifier(
            ast.name,
            self.expensiveChecks || isPossiblyDangerousMemberName(ast.name),
            context,
            create,
            self.expression
          );
        case AST.MemberExpression:
          left = this.recurse(ast.object, false, !!create);
          if (!ast.computed) {
            ensureSafeMemberName(ast.property.name, self.expression);
            right = ast.property.name;
          }
          if (ast.computed) right = this.recurse(ast.property);
          return ast.computed
            ? this.computedMember(left, right, context, create, self.expression)
            : this.nonComputedMember(
                left,
                right,
                self.expensiveChecks,
                context,
                create,
                self.expression
              );
        case AST.CallExpression:
          args = [];
          forEach(ast.arguments, function (expr) {
            args.push(self.recurse(expr));
          });
          if (ast.filter) right = this.$filter(ast.callee.name);
          if (!ast.filter) right = this.recurse(ast.callee, true);
          return ast.filter
            ? function (scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context
                  ? { context: undefined, name: undefined, value: value }
                  : value;
              }
            : function (scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(
                      ensureSafeObject(
                        args[i](scope, locals, assign, inputs),
                        self.expression
                      )
                    );
                  }
                  value = ensureSafeObject(
                    rhs.value.apply(rhs.context, values),
                    self.expression
                  );
                }
                return context ? { value: value } : value;
              };
        case AST.AssignmentExpression:
          left = this.recurse(ast.left, true, 1);
          right = this.recurse(ast.right);
          return function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            ensureSafeObject(lhs.value, self.expression);
            ensureSafeAssignContext(lhs.context);
            lhs.context[lhs.name] = rhs;
            return context ? { value: rhs } : rhs;
          };
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function (expr) {
            args.push(self.recurse(expr));
          });
          return function (scope, locals, assign, inputs) {
            var value = [];
            for (var i = 0; i < args.length; ++i) {
              value.push(args[i](scope, locals, assign, inputs));
            }
            return context ? { value: value } : value;
          };
        case AST.ObjectExpression:
          args = [];
          forEach(ast.properties, function (property) {
            args.push({
              key:
                property.key.type === AST.Identifier
                  ? property.key.name
                  : "" + property.key.value,
              value: self.recurse(property.value),
            });
          });
          return function (scope, locals, assign, inputs) {
            var value = {};
            for (var i = 0; i < args.length; ++i) {
              value[args[i].key] = args[i].value(scope, locals, assign, inputs);
            }
            return context ? { value: value } : value;
          };
        case AST.ThisExpression:
          return function (scope) {
            return context ? { value: scope } : scope;
          };
        case AST.NGValueParameter:
          return function (scope, locals, assign, inputs) {
            return context ? { value: assign } : assign;
          };
      }
    },
    "unary+": function (argument, context) {
      return function (scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = +arg;
        } else {
          arg = 0;
        }
        return context ? { value: arg } : arg;
      };
    },
    "unary-": function (argument, context) {
      return function (scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = -arg;
        } else {
          arg = 0;
        }
        return context ? { value: arg } : arg;
      };
    },
    "unary!": function (argument, context) {
      return function (scope, locals, assign, inputs) {
        var arg = !argument(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary+": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = plusFn(lhs, rhs);
        return context ? { value: arg } : arg;
      };
    },
    "binary-": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
        return context ? { value: arg } : arg;
      };
    },
    "binary*": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) *
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary/": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) /
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary%": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) %
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary===": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) ===
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary!==": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) !==
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary==": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) ==
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary!=": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) !=
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary<": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) <
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary>": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) >
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary<=": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) <=
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary>=": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) >=
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary&&": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) &&
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary||": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) ||
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "ternary?:": function (test, alternate, consequent, context) {
      return function (scope, locals, assign, inputs) {
        var arg = test(scope, locals, assign, inputs)
          ? alternate(scope, locals, assign, inputs)
          : consequent(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    value: function (value, context) {
      return function () {
        return context
          ? { context: undefined, name: undefined, value: value }
          : value;
      };
    },
    identifier: function (name, expensiveChecks, context, create, expression) {
      return function (scope, locals, assign, inputs) {
        var base = locals && name in locals ? locals : scope;
        if (create && create !== 1 && base && !base[name]) {
          base[name] = {};
        }
        var value = base ? base[name] : undefined;
        if (expensiveChecks) {
          ensureSafeObject(value, expression);
        }
        if (context) {
          return { context: base, name: name, value: value };
        } else {
          return value;
        }
      };
    },
    computedMember: function (left, right, context, create, expression) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs;
        var value;
        if (lhs != null) {
          rhs = right(scope, locals, assign, inputs);
          rhs = getStringValue(rhs);
          ensureSafeMemberName(rhs, expression);
          if (create && create !== 1) {
            ensureSafeAssignContext(lhs);
            if (lhs && !lhs[rhs]) {
              lhs[rhs] = {};
            }
          }
          value = lhs[rhs];
          ensureSafeObject(value, expression);
        }
        if (context) {
          return { context: lhs, name: rhs, value: value };
        } else {
          return value;
        }
      };
    },
    nonComputedMember: function (
      left,
      right,
      expensiveChecks,
      context,
      create,
      expression
    ) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        if (create && create !== 1) {
          ensureSafeAssignContext(lhs);
          if (lhs && !lhs[right]) {
            lhs[right] = {};
          }
        }
        var value = lhs != null ? lhs[right] : undefined;
        if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
          ensureSafeObject(value, expression);
        }
        if (context) {
          return { context: lhs, name: right, value: value };
        } else {
          return value;
        }
      };
    },
    inputs: function (input, watchId) {
      return function (scope, value, locals, inputs) {
        if (inputs) return inputs[watchId];
        return input(scope, value, locals);
      };
    },
  };
  var Parser = function (lexer, $filter, options) {
    this.lexer = lexer;
    this.$filter = $filter;
    this.options = options;
    this.ast = new AST(this.lexer);
    this.astCompiler = options.csp
      ? new ASTInterpreter(this.ast, $filter)
      : new ASTCompiler(this.ast, $filter);
  };
  Parser.prototype = {
    constructor: Parser,
    parse: function (text) {
      return this.astCompiler.compile(text, this.options.expensiveChecks);
    },
  };
  function isPossiblyDangerousMemberName(name) {
    return name == "constructor";
  }
  var objectValueOf = Object.prototype.valueOf;
  function getValueOf(value) {
    return isFunction(value.valueOf)
      ? value.valueOf()
      : objectValueOf.call(value);
  }
  function $ParseProvider() {
    var cacheDefault = createMap();
    var cacheExpensive = createMap();
    this.$get = [
      "$filter",
      function ($filter) {
        var noUnsafeEval = csp().noUnsafeEval;
        var $parseOptions = { csp: noUnsafeEval, expensiveChecks: false },
          $parseOptionsExpensive = { csp: noUnsafeEval, expensiveChecks: true };
        var runningChecksEnabled = false;
        $parse.$$runningExpensiveChecks = function () {
          return runningChecksEnabled;
        };
        return $parse;
        function $parse(exp, interceptorFn, expensiveChecks) {
          var parsedExpression, oneTime, cacheKey;
          expensiveChecks = expensiveChecks || runningChecksEnabled;
          switch (typeof exp) {
            case "string":
              exp = exp.trim();
              cacheKey = exp;
              var cache = expensiveChecks ? cacheExpensive : cacheDefault;
              parsedExpression = cache[cacheKey];
              if (!parsedExpression) {
                if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                  oneTime = true;
                  exp = exp.substring(2);
                }
                var parseOptions = expensiveChecks
                  ? $parseOptionsExpensive
                  : $parseOptions;
                var lexer = new Lexer(parseOptions);
                var parser = new Parser(lexer, $filter, parseOptions);
                parsedExpression = parser.parse(exp);
                if (parsedExpression.constant) {
                  parsedExpression.$$watchDelegate = constantWatchDelegate;
                } else if (oneTime) {
                  parsedExpression.$$watchDelegate = parsedExpression.literal
                    ? oneTimeLiteralWatchDelegate
                    : oneTimeWatchDelegate;
                } else if (parsedExpression.inputs) {
                  parsedExpression.$$watchDelegate = inputsWatchDelegate;
                }
                if (expensiveChecks) {
                  parsedExpression =
                    expensiveChecksInterceptor(parsedExpression);
                }
                cache[cacheKey] = parsedExpression;
              }
              return addInterceptor(parsedExpression, interceptorFn);
            case "function":
              return addInterceptor(exp, interceptorFn);
            default:
              return addInterceptor(noop, interceptorFn);
          }
        }
        function expensiveChecksInterceptor(fn) {
          if (!fn) return fn;
          expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
          expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
          expensiveCheckFn.constant = fn.constant;
          expensiveCheckFn.literal = fn.literal;
          for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
            fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
          }
          expensiveCheckFn.inputs = fn.inputs;
          return expensiveCheckFn;
          function expensiveCheckFn(scope, locals, assign, inputs) {
            var expensiveCheckOldValue = runningChecksEnabled;
            runningChecksEnabled = true;
            try {
              return fn(scope, locals, assign, inputs);
            } finally {
              runningChecksEnabled = expensiveCheckOldValue;
            }
          }
        }
        function expressionInputDirtyCheck(newValue, oldValueOfValue) {
          if (newValue == null || oldValueOfValue == null) {
            return newValue === oldValueOfValue;
          }
          if (typeof newValue === "object") {
            newValue = getValueOf(newValue);
            if (typeof newValue === "object") {
              return false;
            }
          }
          return (
            newValue === oldValueOfValue ||
            (newValue !== newValue && oldValueOfValue !== oldValueOfValue)
          );
        }
        function inputsWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression,
          prettyPrintExpression
        ) {
          var inputExpressions = parsedExpression.inputs;
          var lastResult;
          if (inputExpressions.length === 1) {
            var oldInputValueOf = expressionInputDirtyCheck;
            inputExpressions = inputExpressions[0];
            return scope.$watch(
              function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (
                  !expressionInputDirtyCheck(newInputValue, oldInputValueOf)
                ) {
                  lastResult = parsedExpression(scope, undefined, undefined, [
                    newInputValue,
                  ]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              },
              listener,
              objectEquality,
              prettyPrintExpression
            );
          }
          var oldInputValueOfValues = [];
          var oldInputValues = [];
          for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
            oldInputValueOfValues[i] = expressionInputDirtyCheck;
            oldInputValues[i] = null;
          }
          return scope.$watch(
            function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (
                  changed ||
                  (changed = !expressionInputDirtyCheck(
                    newInputValue,
                    oldInputValueOfValues[i]
                  ))
                ) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] =
                    newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(
                  scope,
                  undefined,
                  undefined,
                  oldInputValues
                );
              }
              return lastResult;
            },
            listener,
            objectEquality,
            prettyPrintExpression
          );
        }
        function oneTimeWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression
        ) {
          var unwatch, lastValue;
          return (unwatch = scope.$watch(
            function oneTimeWatch(scope) {
              return parsedExpression(scope);
            },
            function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function () {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            },
            objectEquality
          ));
        }
        function oneTimeLiteralWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression
        ) {
          var unwatch, lastValue;
          return (unwatch = scope.$watch(
            function oneTimeWatch(scope) {
              return parsedExpression(scope);
            },
            function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function () {
                  if (isAllDefined(lastValue)) unwatch();
                });
              }
            },
            objectEquality
          ));
          function isAllDefined(value) {
            var allDefined = true;
            forEach(value, function (val) {
              if (!isDefined(val)) allDefined = false;
            });
            return allDefined;
          }
        }
        function constantWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression
        ) {
          var unwatch;
          return (unwatch = scope.$watch(
            function constantWatch(scope) {
              return parsedExpression(scope);
            },
            function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            },
            objectEquality
          ));
        }
        function addInterceptor(parsedExpression, interceptorFn) {
          if (!interceptorFn) return parsedExpression;
          var watchDelegate = parsedExpression.$$watchDelegate;
          var useInputs = false;
          var regularWatch =
            watchDelegate !== oneTimeLiteralWatchDelegate &&
            watchDelegate !== oneTimeWatchDelegate;
          var fn = regularWatch
            ? function regularInterceptedExpression(
                scope,
                locals,
                assign,
                inputs
              ) {
                var value =
                  useInputs && inputs
                    ? inputs[0]
                    : parsedExpression(scope, locals, assign, inputs);
                return interceptorFn(value, scope, locals);
              }
            : function oneTimeInterceptedExpression(
                scope,
                locals,
                assign,
                inputs
              ) {
                var value = parsedExpression(scope, locals, assign, inputs);
                var result = interceptorFn(value, scope, locals);
                return isDefined(value) ? result : value;
              };
          if (
            parsedExpression.$$watchDelegate &&
            parsedExpression.$$watchDelegate !== inputsWatchDelegate
          ) {
            fn.$$watchDelegate = parsedExpression.$$watchDelegate;
          } else if (!interceptorFn.$stateful) {
            fn.$$watchDelegate = inputsWatchDelegate;
            useInputs = !parsedExpression.inputs;
            fn.inputs = parsedExpression.inputs
              ? parsedExpression.inputs
              : [parsedExpression];
          }
          return fn;
        }
      },
    ];
  }
  function $QProvider() {
    this.$get = [
      "$rootScope",
      "$exceptionHandler",
      function ($rootScope, $exceptionHandler) {
        return qFactory(function (callback) {
          $rootScope.$evalAsync(callback);
        }, $exceptionHandler);
      },
    ];
  }
  function $$QProvider() {
    this.$get = [
      "$browser",
      "$exceptionHandler",
      function ($browser, $exceptionHandler) {
        return qFactory(function (callback) {
          $browser.defer(callback);
        }, $exceptionHandler);
      },
    ];
  }
  function qFactory(nextTick, exceptionHandler) {
    var $qMinErr = minErr("$q", TypeError);
    function callOnce(self, resolveFn, rejectFn) {
      var called = false;
      function wrap(fn) {
        return function (value) {
          if (called) return;
          called = true;
          fn.call(self, value);
        };
      }
      return [wrap(resolveFn), wrap(rejectFn)];
    }
    var defer = function () {
      return new Deferred();
    };
    function Promise() {
      this.$$state = { status: 0 };
    }
    extend(Promise.prototype, {
      then: function (onFulfilled, onRejected, progressBack) {
        if (
          isUndefined(onFulfilled) &&
          isUndefined(onRejected) &&
          isUndefined(progressBack)
        ) {
          return this;
        }
        var result = new Deferred();
        this.$$state.pending = this.$$state.pending || [];
        this.$$state.pending.push([
          result,
          onFulfilled,
          onRejected,
          progressBack,
        ]);
        if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
        return result.promise;
      },
      catch: function (callback) {
        return this.then(null, callback);
      },
      finally: function (callback, progressBack) {
        return this.then(
          function (value) {
            return handleCallback(value, true, callback);
          },
          function (error) {
            return handleCallback(error, false, callback);
          },
          progressBack
        );
      },
    });
    function simpleBind(context, fn) {
      return function (value) {
        fn.call(context, value);
      };
    }
    function processQueue(state) {
      var fn, deferred, pending;
      pending = state.pending;
      state.processScheduled = false;
      state.pending = undefined;
      for (var i = 0, ii = pending.length; i < ii; ++i) {
        deferred = pending[i][0];
        fn = pending[i][state.status];
        try {
          if (isFunction(fn)) {
            deferred.resolve(fn(state.value));
          } else if (state.status === 1) {
            deferred.resolve(state.value);
          } else {
            deferred.reject(state.value);
          }
        } catch (e) {
          deferred.reject(e);
          exceptionHandler(e);
        }
      }
    }
    function scheduleProcessQueue(state) {
      if (state.processScheduled || !state.pending) return;
      state.processScheduled = true;
      nextTick(function () {
        processQueue(state);
      });
    }
    function Deferred() {
      this.promise = new Promise();
      this.resolve = simpleBind(this, this.resolve);
      this.reject = simpleBind(this, this.reject);
      this.notify = simpleBind(this, this.notify);
    }
    extend(Deferred.prototype, {
      resolve: function (val) {
        if (this.promise.$$state.status) return;
        if (val === this.promise) {
          this.$$reject(
            $qMinErr(
              "qcycle",
              "Expected promise to be resolved with value other than itself '{0}'",
              val
            )
          );
        } else {
          this.$$resolve(val);
        }
      },
      $$resolve: function (val) {
        var then, fns;
        fns = callOnce(this, this.$$resolve, this.$$reject);
        try {
          if (isObject(val) || isFunction(val)) then = val && val.then;
          if (isFunction(then)) {
            this.promise.$$state.status = -1;
            then.call(val, fns[0], fns[1], this.notify);
          } else {
            this.promise.$$state.value = val;
            this.promise.$$state.status = 1;
            scheduleProcessQueue(this.promise.$$state);
          }
        } catch (e) {
          fns[1](e);
          exceptionHandler(e);
        }
      },
      reject: function (reason) {
        if (this.promise.$$state.status) return;
        this.$$reject(reason);
      },
      $$reject: function (reason) {
        this.promise.$$state.value = reason;
        this.promise.$$state.status = 2;
        scheduleProcessQueue(this.promise.$$state);
      },
      notify: function (progress) {
        var callbacks = this.promise.$$state.pending;
        if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
          nextTick(function () {
            var callback, result;
            for (var i = 0, ii = callbacks.length; i < ii; i++) {
              result = callbacks[i][0];
              callback = callbacks[i][3];
              try {
                result.notify(
                  isFunction(callback) ? callback(progress) : progress
                );
              } catch (e) {
                exceptionHandler(e);
              }
            }
          });
        }
      },
    });
    var reject = function (reason) {
      var result = new Deferred();
      result.reject(reason);
      return result.promise;
    };
    var makePromise = function makePromise(value, resolved) {
      var result = new Deferred();
      if (resolved) {
        result.resolve(value);
      } else {
        result.reject(value);
      }
      return result.promise;
    };
    var handleCallback = function handleCallback(value, isResolved, callback) {
      var callbackOutput = null;
      try {
        if (isFunction(callback)) callbackOutput = callback();
      } catch (e) {
        return makePromise(e, false);
      }
      if (isPromiseLike(callbackOutput)) {
        return callbackOutput.then(
          function () {
            return makePromise(value, isResolved);
          },
          function (error) {
            return makePromise(error, false);
          }
        );
      } else {
        return makePromise(value, isResolved);
      }
    };
    var when = function (value, callback, errback, progressBack) {
      var result = new Deferred();
      result.resolve(value);
      return result.promise.then(callback, errback, progressBack);
    };
    var resolve = when;
    function all(promises) {
      var deferred = new Deferred(),
        counter = 0,
        results = isArray(promises) ? [] : {};
      forEach(promises, function (promise, key) {
        counter++;
        when(promise).then(
          function (value) {
            if (results.hasOwnProperty(key)) return;
            results[key] = value;
            if (!--counter) deferred.resolve(results);
          },
          function (reason) {
            if (results.hasOwnProperty(key)) return;
            deferred.reject(reason);
          }
        );
      });
      if (counter === 0) {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    var $Q = function Q(resolver) {
      if (!isFunction(resolver)) {
        throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
      }
      if (!(this instanceof Q)) {
        return new Q(resolver);
      }
      var deferred = new Deferred();
      function resolveFn(value) {
        deferred.resolve(value);
      }
      function rejectFn(reason) {
        deferred.reject(reason);
      }
      resolver(resolveFn, rejectFn);
      return deferred.promise;
    };
    $Q.defer = defer;
    $Q.reject = reject;
    $Q.when = when;
    $Q.resolve = resolve;
    $Q.all = all;
    return $Q;
  }
  function $$RAFProvider() {
    this.$get = [
      "$window",
      "$timeout",
      function ($window, $timeout) {
        var requestAnimationFrame =
          $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
        var cancelAnimationFrame =
          $window.cancelAnimationFrame ||
          $window.webkitCancelAnimationFrame ||
          $window.webkitCancelRequestAnimationFrame;
        var rafSupported = !!requestAnimationFrame;
        var raf = rafSupported
          ? function (fn) {
              var id = requestAnimationFrame(fn);
              return function () {
                cancelAnimationFrame(id);
              };
            }
          : function (fn) {
              var timer = $timeout(fn, 16.66, false);
              return function () {
                $timeout.cancel(timer);
              };
            };
        raf.supported = rafSupported;
        return raf;
      },
    ];
  }
  function $RootScopeProvider() {
    var TTL = 10;
    var $rootScopeMinErr = minErr("$rootScope");
    var lastDirtyWatch = null;
    var applyAsyncId = null;
    this.digestTtl = function (value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    function createChildScopeClass(parent) {
      function ChildScope() {
        this.$$watchers =
          this.$$nextSibling =
          this.$$childHead =
          this.$$childTail =
            null;
        this.$$listeners = {};
        this.$$listenerCount = {};
        this.$$watchersCount = 0;
        this.$id = nextUid();
        this.$$ChildScope = null;
      }
      ChildScope.prototype = parent;
      return ChildScope;
    }
    this.$get = [
      "$injector",
      "$exceptionHandler",
      "$parse",
      "$browser",
      function ($injector, $exceptionHandler, $parse, $browser) {
        function destroyChildScope($event) {
          $event.currentScope.$$destroyed = true;
        }
        function cleanUpScope($scope) {
          if (msie === 9) {
            $scope.$$childHead && cleanUpScope($scope.$$childHead);
            $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
          }
          $scope.$parent =
            $scope.$$nextSibling =
            $scope.$$prevSibling =
            $scope.$$childHead =
            $scope.$$childTail =
            $scope.$root =
            $scope.$$watchers =
              null;
        }
        function Scope() {
          this.$id = nextUid();
          this.$$phase =
            this.$parent =
            this.$$watchers =
            this.$$nextSibling =
            this.$$prevSibling =
            this.$$childHead =
            this.$$childTail =
              null;
          this.$root = this;
          this.$$destroyed = false;
          this.$$listeners = {};
          this.$$listenerCount = {};
          this.$$watchersCount = 0;
          this.$$isolateBindings = null;
        }
        Scope.prototype = {
          constructor: Scope,
          $new: function (isolate, parent) {
            var child;
            parent = parent || this;
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              if (!this.$$ChildScope) {
                this.$$ChildScope = createChildScopeClass(this);
              }
              child = new this.$$ChildScope();
            }
            child.$parent = parent;
            child.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = child;
              parent.$$childTail = child;
            } else {
              parent.$$childHead = parent.$$childTail = child;
            }
            if (isolate || parent != this)
              child.$on("$destroy", destroyChildScope);
            return child;
          },
          $watch: function (
            watchExp,
            listener,
            objectEquality,
            prettyPrintExpression
          ) {
            var get = $parse(watchExp);
            if (get.$$watchDelegate) {
              return get.$$watchDelegate(
                this,
                listener,
                objectEquality,
                get,
                watchExp
              );
            }
            var scope = this,
              array = scope.$$watchers,
              watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: prettyPrintExpression || watchExp,
                eq: !!objectEquality,
              };
            lastDirtyWatch = null;
            if (!isFunction(listener)) {
              watcher.fn = noop;
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            incrementWatchersCount(this, 1);
            return function deregisterWatch() {
              if (arrayRemove(array, watcher) >= 0) {
                incrementWatchersCount(scope, -1);
              }
              lastDirtyWatch = null;
            };
          },
          $watchGroup: function (watchExpressions, listener) {
            var oldValues = new Array(watchExpressions.length);
            var newValues = new Array(watchExpressions.length);
            var deregisterFns = [];
            var self = this;
            var changeReactionScheduled = false;
            var firstRun = true;
            if (!watchExpressions.length) {
              var shouldCall = true;
              self.$evalAsync(function () {
                if (shouldCall) listener(newValues, newValues, self);
              });
              return function deregisterWatchGroup() {
                shouldCall = false;
              };
            }
            if (watchExpressions.length === 1) {
              return this.$watch(
                watchExpressions[0],
                function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(
                    newValues,
                    value === oldValue ? newValues : oldValues,
                    scope
                  );
                }
              );
            }
            forEach(watchExpressions, function (expr, i) {
              var unwatchFn = self.$watch(
                expr,
                function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                }
              );
              deregisterFns.push(unwatchFn);
            });
            function watchGroupAction() {
              changeReactionScheduled = false;
              if (firstRun) {
                firstRun = false;
                listener(newValues, newValues, self);
              } else {
                listener(newValues, oldValues, self);
              }
            }
            return function deregisterWatchGroup() {
              while (deregisterFns.length) {
                deregisterFns.shift()();
              }
            };
          },
          $watchCollection: function (obj, listener) {
            $watchCollectionInterceptor.$stateful = true;
            var self = this;
            var newValue;
            var oldValue;
            var veryOldValue;
            var trackVeryOldValue = listener.length > 1;
            var changeDetected = 0;
            var changeDetector = $parse(obj, $watchCollectionInterceptor);
            var internalArray = [];
            var internalObject = {};
            var initRun = true;
            var oldLength = 0;
            function $watchCollectionInterceptor(_value) {
              newValue = _value;
              var newLength, key, bothNaN, newItem, oldItem;
              if (isUndefined(newValue)) return;
              if (!isObject(newValue)) {
                if (oldValue !== newValue) {
                  oldValue = newValue;
                  changeDetected++;
                }
              } else if (isArrayLike(newValue)) {
                if (oldValue !== internalArray) {
                  oldValue = internalArray;
                  oldLength = oldValue.length = 0;
                  changeDetected++;
                }
                newLength = newValue.length;
                if (oldLength !== newLength) {
                  changeDetected++;
                  oldValue.length = oldLength = newLength;
                }
                for (var i = 0; i < newLength; i++) {
                  oldItem = oldValue[i];
                  newItem = newValue[i];
                  bothNaN = oldItem !== oldItem && newItem !== newItem;
                  if (!bothNaN && oldItem !== newItem) {
                    changeDetected++;
                    oldValue[i] = newItem;
                  }
                }
              } else {
                if (oldValue !== internalObject) {
                  oldValue = internalObject = {};
                  oldLength = 0;
                  changeDetected++;
                }
                newLength = 0;
                for (key in newValue) {
                  if (hasOwnProperty.call(newValue, key)) {
                    newLength++;
                    newItem = newValue[key];
                    oldItem = oldValue[key];
                    if (key in oldValue) {
                      bothNaN = oldItem !== oldItem && newItem !== newItem;
                      if (!bothNaN && oldItem !== newItem) {
                        changeDetected++;
                        oldValue[key] = newItem;
                      }
                    } else {
                      oldLength++;
                      oldValue[key] = newItem;
                      changeDetected++;
                    }
                  }
                }
                if (oldLength > newLength) {
                  changeDetected++;
                  for (key in oldValue) {
                    if (!hasOwnProperty.call(newValue, key)) {
                      oldLength--;
                      delete oldValue[key];
                    }
                  }
                }
              }
              return changeDetected;
            }
            function $watchCollectionAction() {
              if (initRun) {
                initRun = false;
                listener(newValue, newValue, self);
              } else {
                listener(newValue, veryOldValue, self);
              }
              if (trackVeryOldValue) {
                if (!isObject(newValue)) {
                  veryOldValue = newValue;
                } else if (isArrayLike(newValue)) {
                  veryOldValue = new Array(newValue.length);
                  for (var i = 0; i < newValue.length; i++) {
                    veryOldValue[i] = newValue[i];
                  }
                } else {
                  veryOldValue = {};
                  for (var key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      veryOldValue[key] = newValue[key];
                    }
                  }
                }
              }
            }
            return this.$watch(changeDetector, $watchCollectionAction);
          },
          $digest: function () {
            var watch,
              value,
              last,
              fn,
              get,
              watchers,
              length,
              dirty,
              ttl = TTL,
              next,
              current,
              target = this,
              watchLog = [],
              logIdx,
              logMsg,
              asyncTask;
            beginPhase("$digest");
            $browser.$$checkUrlChange();
            if (this === $rootScope && applyAsyncId !== null) {
              $browser.defer.cancel(applyAsyncId);
              flushApplyAsync();
            }
            lastDirtyWatch = null;
            do {
              dirty = false;
              current = target;
              while (asyncQueue.length) {
                try {
                  asyncTask = asyncQueue.shift();
                  asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                } catch (e) {
                  $exceptionHandler(e);
                }
                lastDirtyWatch = null;
              }
              traverseScopesLoop: do {
                if ((watchers = current.$$watchers)) {
                  length = watchers.length;
                  while (length--) {
                    try {
                      watch = watchers[length];
                      if (watch) {
                        get = watch.get;
                        if (
                          (value = get(current)) !== (last = watch.last) &&
                          !(watch.eq
                            ? equals(value, last)
                            : typeof value === "number" &&
                              typeof last === "number" &&
                              isNaN(value) &&
                              isNaN(last))
                        ) {
                          dirty = true;
                          lastDirtyWatch = watch;
                          watch.last = watch.eq ? copy(value, null) : value;
                          fn = watch.fn;
                          fn(
                            value,
                            last === initWatchVal ? value : last,
                            current
                          );
                          if (ttl < 5) {
                            logIdx = 4 - ttl;
                            if (!watchLog[logIdx]) watchLog[logIdx] = [];
                            watchLog[logIdx].push({
                              msg: isFunction(watch.exp)
                                ? "fn: " +
                                  (watch.exp.name || watch.exp.toString())
                                : watch.exp,
                              newVal: value,
                              oldVal: last,
                            });
                          }
                        } else if (watch === lastDirtyWatch) {
                          dirty = false;
                          break traverseScopesLoop;
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (
                  !(next =
                    (current.$$watchersCount && current.$$childHead) ||
                    (current !== target && current.$$nextSibling))
                ) {
                  while (
                    current !== target &&
                    !(next = current.$$nextSibling)
                  ) {
                    current = current.$parent;
                  }
                }
              } while ((current = next));
              if ((dirty || asyncQueue.length) && !ttl--) {
                clearPhase();
                throw $rootScopeMinErr(
                  "infdig",
                  "{0} $digest() iterations reached. Aborting!\n" +
                    "Watchers fired in the last 5 iterations: {1}",
                  TTL,
                  watchLog
                );
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
            while (postDigestQueue.length) {
              try {
                postDigestQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          },
          $destroy: function () {
            if (this.$$destroyed) return;
            var parent = this.$parent;
            this.$broadcast("$destroy");
            this.$$destroyed = true;
            if (this === $rootScope) {
              $browser.$$applicationDestroyed();
            }
            incrementWatchersCount(this, -this.$$watchersCount);
            for (var eventName in this.$$listenerCount) {
              decrementListenerCount(
                this,
                this.$$listenerCount[eventName],
                eventName
              );
            }
            if (parent && parent.$$childHead == this)
              parent.$$childHead = this.$$nextSibling;
            if (parent && parent.$$childTail == this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$destroy =
              this.$digest =
              this.$apply =
              this.$evalAsync =
              this.$applyAsync =
                noop;
            this.$on =
              this.$watch =
              this.$watchGroup =
                function () {
                  return noop;
                };
            this.$$listeners = {};
            this.$$nextSibling = null;
            cleanUpScope(this);
          },
          $eval: function (expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function (expr, locals) {
            if (!$rootScope.$$phase && !asyncQueue.length) {
              $browser.defer(function () {
                if (asyncQueue.length) {
                  $rootScope.$digest();
                }
              });
            }
            asyncQueue.push({
              scope: this,
              expression: $parse(expr),
              locals: locals,
            });
          },
          $$postDigest: function (fn) {
            postDigestQueue.push(fn);
          },
          $apply: function (expr) {
            try {
              beginPhase("$apply");
              try {
                return this.$eval(expr);
              } finally {
                clearPhase();
              }
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $applyAsync: function (expr) {
            var scope = this;
            expr && applyAsyncQueue.push($applyAsyncExpression);
            expr = $parse(expr);
            scheduleApplyAsync();
            function $applyAsyncExpression() {
              scope.$eval(expr);
            }
          },
          $on: function (name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            var current = this;
            do {
              if (!current.$$listenerCount[name]) {
                current.$$listenerCount[name] = 0;
              }
              current.$$listenerCount[name]++;
            } while ((current = current.$parent));
            var self = this;
            return function () {
              var indexOfListener = namedListeners.indexOf(listener);
              if (indexOfListener !== -1) {
                namedListeners[indexOfListener] = null;
                decrementListenerCount(self, 1, name);
              }
            };
          },
          $emit: function (name, args) {
            var empty = [],
              namedListeners,
              scope = this,
              stopPropagation = false,
              event = {
                name: name,
                targetScope: scope,
                stopPropagation: function () {
                  stopPropagation = true;
                },
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false,
              },
              listenerArgs = concat([event], arguments, 1),
              i,
              length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (stopPropagation) {
                event.currentScope = null;
                return event;
              }
              scope = scope.$parent;
            } while (scope);
            event.currentScope = null;
            return event;
          },
          $broadcast: function (name, args) {
            var target = this,
              current = target,
              next = target,
              event = {
                name: name,
                targetScope: target,
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false,
              };
            if (!target.$$listenerCount[name]) return event;
            var listenerArgs = concat([event], arguments, 1),
              listeners,
              i,
              length;
            while ((current = next)) {
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (
                !(next =
                  (current.$$listenerCount[name] && current.$$childHead) ||
                  (current !== target && current.$$nextSibling))
              ) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            }
            event.currentScope = null;
            return event;
          },
        };
        var $rootScope = new Scope();
        var asyncQueue = ($rootScope.$$asyncQueue = []);
        var postDigestQueue = ($rootScope.$$postDigestQueue = []);
        var applyAsyncQueue = ($rootScope.$$applyAsyncQueue = []);
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw $rootScopeMinErr(
              "inprog",
              "{0} already in progress",
              $rootScope.$$phase
            );
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function incrementWatchersCount(current, count) {
          do {
            current.$$watchersCount += count;
          } while ((current = current.$parent));
        }
        function decrementListenerCount(current, count, name) {
          do {
            current.$$listenerCount[name] -= count;
            if (current.$$listenerCount[name] === 0) {
              delete current.$$listenerCount[name];
            }
          } while ((current = current.$parent));
        }
        function initWatchVal() {}
        function flushApplyAsync() {
          while (applyAsyncQueue.length) {
            try {
              applyAsyncQueue.shift()();
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          applyAsyncId = null;
        }
        function scheduleApplyAsync() {
          if (applyAsyncId === null) {
            applyAsyncId = $browser.defer(function () {
              $rootScope.$apply(flushApplyAsync);
            });
          }
        }
      },
    ];
  }
  function $$SanitizeUriProvider() {
    var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
      imgSrcSanitizationWhitelist =
        /^\s*((https?|ftp|file|blob):|data:image\/)/;
    this.aHrefSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        aHrefSanitizationWhitelist = regexp;
        return this;
      }
      return aHrefSanitizationWhitelist;
    };
    this.imgSrcSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        imgSrcSanitizationWhitelist = regexp;
        return this;
      }
      return imgSrcSanitizationWhitelist;
    };
    this.$get = function () {
      return function sanitizeUri(uri, isImage) {
        var regex = isImage
          ? imgSrcSanitizationWhitelist
          : aHrefSanitizationWhitelist;
        var normalizedVal;
        normalizedVal = urlResolve(uri).href;
        if (normalizedVal !== "" && !normalizedVal.match(regex)) {
          return "unsafe:" + normalizedVal;
        }
        return uri;
      };
    };
  }
  var $sceMinErr = minErr("$sce");
  var SCE_CONTEXTS = {
    HTML: "html",
    CSS: "css",
    URL: "url",
    RESOURCE_URL: "resourceUrl",
    JS: "js",
  };
  function adjustMatcher(matcher) {
    if (matcher === "self") {
      return matcher;
    } else if (isString(matcher)) {
      if (matcher.indexOf("***") > -1) {
        throw $sceMinErr(
          "iwcard",
          "Illegal sequence *** in string matcher.  String: {0}",
          matcher
        );
      }
      matcher = escapeForRegexp(matcher)
        .replace("\\*\\*", ".*")
        .replace("\\*", "[^:/.?&;]*");
      return new RegExp("^" + matcher + "$");
    } else if (isRegExp(matcher)) {
      return new RegExp("^" + matcher.source + "$");
    } else {
      throw $sceMinErr(
        "imatcher",
        'Matchers may only be "self", string patterns or RegExp objects'
      );
    }
  }
  function adjustMatchers(matchers) {
    var adjustedMatchers = [];
    if (isDefined(matchers)) {
      forEach(matchers, function (matcher) {
        adjustedMatchers.push(adjustMatcher(matcher));
      });
    }
    return adjustedMatchers;
  }
  function $SceDelegateProvider() {
    this.SCE_CONTEXTS = SCE_CONTEXTS;
    var resourceUrlWhitelist = ["self"],
      resourceUrlBlacklist = [];
    this.resourceUrlWhitelist = function (value) {
      if (arguments.length) {
        resourceUrlWhitelist = adjustMatchers(value);
      }
      return resourceUrlWhitelist;
    };
    this.resourceUrlBlacklist = function (value) {
      if (arguments.length) {
        resourceUrlBlacklist = adjustMatchers(value);
      }
      return resourceUrlBlacklist;
    };
    this.$get = [
      "$injector",
      function ($injector) {
        var htmlSanitizer = function htmlSanitizer(html) {
          throw $sceMinErr(
            "unsafe",
            "Attempting to use an unsafe value in a safe context."
          );
        };
        if ($injector.has("$sanitize")) {
          htmlSanitizer = $injector.get("$sanitize");
        }
        function matchUrl(matcher, parsedUrl) {
          if (matcher === "self") {
            return urlIsSameOrigin(parsedUrl);
          } else {
            return !!matcher.exec(parsedUrl.href);
          }
        }
        function isResourceUrlAllowedByPolicy(url) {
          var parsedUrl = urlResolve(url.toString());
          var i,
            n,
            allowed = false;
          for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
              allowed = true;
              break;
            }
          }
          if (allowed) {
            for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
              if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                allowed = false;
                break;
              }
            }
          }
          return allowed;
        }
        function generateHolderType(Base) {
          var holderType = function TrustedValueHolderType(trustedValue) {
            this.$$unwrapTrustedValue = function () {
              return trustedValue;
            };
          };
          if (Base) {
            holderType.prototype = new Base();
          }
          holderType.prototype.valueOf = function sceValueOf() {
            return this.$$unwrapTrustedValue();
          };
          holderType.prototype.toString = function sceToString() {
            return this.$$unwrapTrustedValue().toString();
          };
          return holderType;
        }
        var trustedValueHolderBase = generateHolderType(),
          byType = {};
        byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(
          byType[SCE_CONTEXTS.URL]
        );
        function trustAs(type, trustedValue) {
          var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
          if (!Constructor) {
            throw $sceMinErr(
              "icontext",
              "Attempted to trust a value in invalid context. Context: {0}; Value: {1}",
              type,
              trustedValue
            );
          }
          if (
            trustedValue === null ||
            isUndefined(trustedValue) ||
            trustedValue === ""
          ) {
            return trustedValue;
          }
          if (typeof trustedValue !== "string") {
            throw $sceMinErr(
              "itype",
              "Attempted to trust a non-string value in a content requiring a string: Context: {0}",
              type
            );
          }
          return new Constructor(trustedValue);
        }
        function valueOf(maybeTrusted) {
          if (maybeTrusted instanceof trustedValueHolderBase) {
            return maybeTrusted.$$unwrapTrustedValue();
          } else {
            return maybeTrusted;
          }
        }
        function getTrusted(type, maybeTrusted) {
          if (
            maybeTrusted === null ||
            isUndefined(maybeTrusted) ||
            maybeTrusted === ""
          ) {
            return maybeTrusted;
          }
          var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
          if (constructor && maybeTrusted instanceof constructor) {
            return maybeTrusted.$$unwrapTrustedValue();
          }
          if (type === SCE_CONTEXTS.RESOURCE_URL) {
            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
              return maybeTrusted;
            } else {
              throw $sceMinErr(
                "insecurl",
                "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}",
                maybeTrusted.toString()
              );
            }
          } else if (type === SCE_CONTEXTS.HTML) {
            return htmlSanitizer(maybeTrusted);
          }
          throw $sceMinErr(
            "unsafe",
            "Attempting to use an unsafe value in a safe context."
          );
        }
        return { trustAs: trustAs, getTrusted: getTrusted, valueOf: valueOf };
      },
    ];
  }
  function $SceProvider() {
    var enabled = true;
    this.enabled = function (value) {
      if (arguments.length) {
        enabled = !!value;
      }
      return enabled;
    };
    this.$get = [
      "$parse",
      "$sceDelegate",
      function ($parse, $sceDelegate) {
        if (enabled && msie < 8) {
          throw $sceMinErr(
            "iequirks",
            "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " +
              "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " +
              "document.  See http://docs.angularjs.org/api/ng.$sce for more information."
          );
        }
        var sce = shallowCopy(SCE_CONTEXTS);
        sce.isEnabled = function () {
          return enabled;
        };
        sce.trustAs = $sceDelegate.trustAs;
        sce.getTrusted = $sceDelegate.getTrusted;
        sce.valueOf = $sceDelegate.valueOf;
        if (!enabled) {
          sce.trustAs = sce.getTrusted = function (type, value) {
            return value;
          };
          sce.valueOf = identity;
        }
        sce.parseAs = function sceParseAs(type, expr) {
          var parsed = $parse(expr);
          if (parsed.literal && parsed.constant) {
            return parsed;
          } else {
            return $parse(expr, function (value) {
              return sce.getTrusted(type, value);
            });
          }
        };
        var parse = sce.parseAs,
          getTrusted = sce.getTrusted,
          trustAs = sce.trustAs;
        forEach(SCE_CONTEXTS, function (enumValue, name) {
          var lName = lowercase(name);
          sce[camelCase("parse_as_" + lName)] = function (expr) {
            return parse(enumValue, expr);
          };
          sce[camelCase("get_trusted_" + lName)] = function (value) {
            return getTrusted(enumValue, value);
          };
          sce[camelCase("trust_as_" + lName)] = function (value) {
            return trustAs(enumValue, value);
          };
        });
        return sce;
      },
    ];
  }
  function $SnifferProvider() {
    this.$get = [
      "$window",
      "$document",
      function ($window, $document) {
        var eventSupport = {},
          android = toInt(
            (/android (\d+)/.exec(
              lowercase(($window.navigator || {}).userAgent)
            ) || [])[1]
          ),
          boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
          document = $document[0] || {},
          vendorPrefix,
          vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
          bodyStyle = document.body && document.body.style,
          transitions = false,
          animations = false,
          match;
        if (bodyStyle) {
          for (var prop in bodyStyle) {
            if ((match = vendorRegex.exec(prop))) {
              vendorPrefix = match[0];
              vendorPrefix =
                vendorPrefix.substr(0, 1).toUpperCase() +
                vendorPrefix.substr(1);
              break;
            }
          }
          if (!vendorPrefix) {
            vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
          }
          transitions = !!(
            "transition" in bodyStyle ||
            vendorPrefix + "Transition" in bodyStyle
          );
          animations = !!(
            "animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle
          );
          if (android && (!transitions || !animations)) {
            transitions = isString(bodyStyle.webkitTransition);
            animations = isString(bodyStyle.webkitAnimation);
          }
        }
        return {
          history: !!(
            $window.history &&
            $window.history.pushState &&
            !(android < 4) &&
            !boxee
          ),
          hasEvent: function (event) {
            if (event === "input" && msie <= 11) return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = document.createElement("div");
              eventSupport[event] = "on" + event in divElm;
            }
            return eventSupport[event];
          },
          csp: csp(),
          vendorPrefix: vendorPrefix,
          transitions: transitions,
          animations: animations,
          android: android,
        };
      },
    ];
  }
  var $compileMinErr = minErr("$compile");
  function $TemplateRequestProvider() {
    this.$get = [
      "$templateCache",
      "$http",
      "$q",
      "$sce",
      function ($templateCache, $http, $q, $sce) {
        function handleRequestFn(tpl, ignoreRequestError) {
          handleRequestFn.totalPendingRequests++;
          if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
            tpl = $sce.getTrustedResourceUrl(tpl);
          }
          var transformResponse =
            $http.defaults && $http.defaults.transformResponse;
          if (isArray(transformResponse)) {
            transformResponse = transformResponse.filter(function (
              transformer
            ) {
              return transformer !== defaultHttpResponseTransform;
            });
          } else if (transformResponse === defaultHttpResponseTransform) {
            transformResponse = null;
          }
          var httpOptions = {
            cache: $templateCache,
            transformResponse: transformResponse,
          };
          return $http
            .get(tpl, httpOptions)
            ["finally"](function () {
              handleRequestFn.totalPendingRequests--;
            })
            .then(function (response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
          function handleError(resp) {
            if (!ignoreRequestError) {
              throw $compileMinErr(
                "tpload",
                "Failed to load template: {0} (HTTP status: {1} {2})",
                tpl,
                resp.status,
                resp.statusText
              );
            }
            return $q.reject(resp);
          }
        }
        handleRequestFn.totalPendingRequests = 0;
        return handleRequestFn;
      },
    ];
  }
  function $$TestabilityProvider() {
    this.$get = [
      "$rootScope",
      "$browser",
      "$location",
      function ($rootScope, $browser, $location) {
        var testability = {};
        testability.findBindings = function (
          element,
          expression,
          opt_exactMatch
        ) {
          var bindings = element.getElementsByClassName("ng-binding");
          var matches = [];
          forEach(bindings, function (binding) {
            var dataBinding = angular.element(binding).data("$binding");
            if (dataBinding) {
              forEach(dataBinding, function (bindingName) {
                if (opt_exactMatch) {
                  var matcher = new RegExp(
                    "(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)"
                  );
                  if (matcher.test(bindingName)) {
                    matches.push(binding);
                  }
                } else {
                  if (bindingName.indexOf(expression) != -1) {
                    matches.push(binding);
                  }
                }
              });
            }
          });
          return matches;
        };
        testability.findModels = function (
          element,
          expression,
          opt_exactMatch
        ) {
          var prefixes = ["ng-", "data-ng-", "ng\\:"];
          for (var p = 0; p < prefixes.length; ++p) {
            var attributeEquals = opt_exactMatch ? "=" : "*=";
            var selector =
              "[" +
              prefixes[p] +
              "model" +
              attributeEquals +
              '"' +
              expression +
              '"]';
            var elements = element.querySelectorAll(selector);
            if (elements.length) {
              return elements;
            }
          }
        };
        testability.getLocation = function () {
          return $location.url();
        };
        testability.setLocation = function (url) {
          if (url !== $location.url()) {
            $location.url(url);
            $rootScope.$digest();
          }
        };
        testability.whenStable = function (callback) {
          $browser.notifyWhenNoOutstandingRequests(callback);
        };
        return testability;
      },
    ];
  }
  function $TimeoutProvider() {
    this.$get = [
      "$rootScope",
      "$browser",
      "$q",
      "$$q",
      "$exceptionHandler",
      function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          if (!isFunction(fn)) {
            invokeApply = delay;
            delay = fn;
            fn = noop;
          }
          var args = sliceArgs(arguments, 3),
            skipApply = isDefined(invokeApply) && !invokeApply,
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise,
            timeoutId;
          timeoutId = $browser.defer(function () {
            try {
              deferred.resolve(fn.apply(null, args));
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            } finally {
              delete deferreds[promise.$$timeoutId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          return promise;
        }
        timeout.cancel = function (promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject("canceled");
            delete deferreds[promise.$$timeoutId];
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      },
    ];
  }
  var urlParsingNode = document.createElement("a");
  var originUrl = urlResolve(window.location.href);
  function urlResolve(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol
        ? urlParsingNode.protocol.replace(/:$/, "")
        : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search
        ? urlParsingNode.search.replace(/^\?/, "")
        : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname:
        urlParsingNode.pathname.charAt(0) === "/"
          ? urlParsingNode.pathname
          : "/" + urlParsingNode.pathname,
    };
  }
  function urlIsSameOrigin(requestUrl) {
    var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
    return (
      parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
    );
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  function $$CookieReader($document) {
    var rawDocument = $document[0] || {};
    var lastCookies = {};
    var lastCookieString = "";
    function safeDecodeURIComponent(str) {
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    return function () {
      var cookieArray, cookie, i, index, name;
      var currentCookieString = rawDocument.cookie || "";
      if (currentCookieString !== lastCookieString) {
        lastCookieString = currentCookieString;
        cookieArray = lastCookieString.split("; ");
        lastCookies = {};
        for (i = 0; i < cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf("=");
          if (index > 0) {
            name = safeDecodeURIComponent(cookie.substring(0, index));
            if (isUndefined(lastCookies[name])) {
              lastCookies[name] = safeDecodeURIComponent(
                cookie.substring(index + 1)
              );
            }
          }
        }
      }
      return lastCookies;
    };
  }
  $$CookieReader.$inject = ["$document"];
  function $$CookieReaderProvider() {
    this.$get = $$CookieReader;
  }
  $FilterProvider.$inject = ["$provide"];
  function $FilterProvider($provide) {
    var suffix = "Filter";
    function register(name, factory) {
      if (isObject(name)) {
        var filters = {};
        forEach(name, function (filter, key) {
          filters[key] = register(key, filter);
        });
        return filters;
      } else {
        return $provide.factory(name + suffix, factory);
      }
    }
    this.register = register;
    this.$get = [
      "$injector",
      function ($injector) {
        return function (name) {
          return $injector.get(name + suffix);
        };
      },
    ];
    register("currency", currencyFilter);
    register("date", dateFilter);
    register("filter", filterFilter);
    register("json", jsonFilter);
    register("limitTo", limitToFilter);
    register("lowercase", lowercaseFilter);
    register("number", numberFilter);
    register("orderBy", orderByFilter);
    register("uppercase", uppercaseFilter);
  }
  function filterFilter() {
    return function (array, expression, comparator) {
      if (!isArrayLike(array)) {
        if (array == null) {
          return array;
        } else {
          throw minErr("filter")(
            "notarray",
            "Expected array but received: {0}",
            array
          );
        }
      }
      var expressionType = getTypeForFilter(expression);
      var predicateFn;
      var matchAgainstAnyProp;
      switch (expressionType) {
        case "function":
          predicateFn = expression;
          break;
        case "boolean":
        case "null":
        case "number":
        case "string":
          matchAgainstAnyProp = true;
        case "object":
          predicateFn = createPredicateFn(
            expression,
            comparator,
            matchAgainstAnyProp
          );
          break;
        default:
          return array;
      }
      return Array.prototype.filter.call(array, predicateFn);
    };
  }
  function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
    var shouldMatchPrimitives = isObject(expression) && "$" in expression;
    var predicateFn;
    if (comparator === true) {
      comparator = equals;
    } else if (!isFunction(comparator)) {
      comparator = function (actual, expected) {
        if (isUndefined(actual)) {
          return false;
        }
        if (actual === null || expected === null) {
          return actual === expected;
        }
        if (
          isObject(expected) ||
          (isObject(actual) && !hasCustomToString(actual))
        ) {
          return false;
        }
        actual = lowercase("" + actual);
        expected = lowercase("" + expected);
        return actual.indexOf(expected) !== -1;
      };
    }
    predicateFn = function (item) {
      if (shouldMatchPrimitives && !isObject(item)) {
        return deepCompare(item, expression.$, comparator, false);
      }
      return deepCompare(item, expression, comparator, matchAgainstAnyProp);
    };
    return predicateFn;
  }
  function deepCompare(
    actual,
    expected,
    comparator,
    matchAgainstAnyProp,
    dontMatchWholeObject
  ) {
    var actualType = getTypeForFilter(actual);
    var expectedType = getTypeForFilter(expected);
    if (expectedType === "string" && expected.charAt(0) === "!") {
      return !deepCompare(
        actual,
        expected.substring(1),
        comparator,
        matchAgainstAnyProp
      );
    } else if (isArray(actual)) {
      return actual.some(function (item) {
        return deepCompare(item, expected, comparator, matchAgainstAnyProp);
      });
    }
    switch (actualType) {
      case "object":
        var key;
        if (matchAgainstAnyProp) {
          for (key in actual) {
            if (
              key.charAt(0) !== "$" &&
              deepCompare(actual[key], expected, comparator, true)
            ) {
              return true;
            }
          }
          return dontMatchWholeObject
            ? false
            : deepCompare(actual, expected, comparator, false);
        } else if (expectedType === "object") {
          for (key in expected) {
            var expectedVal = expected[key];
            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
              continue;
            }
            var matchAnyProperty = key === "$";
            var actualVal = matchAnyProperty ? actual : actual[key];
            if (
              !deepCompare(
                actualVal,
                expectedVal,
                comparator,
                matchAnyProperty,
                matchAnyProperty
              )
            ) {
              return false;
            }
          }
          return true;
        } else {
          return comparator(actual, expected);
        }
        break;
      case "function":
        return false;
      default:
        return comparator(actual, expected);
    }
  }
  function getTypeForFilter(val) {
    return val === null ? "null" : typeof val;
  }
  var MAX_DIGITS = 22;
  var DECIMAL_SEP = ".";
  var ZERO_CHAR = "0";
  currencyFilter.$inject = ["$locale"];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol, fractionSize) {
      if (isUndefined(currencySymbol)) {
        currencySymbol = formats.CURRENCY_SYM;
      }
      if (isUndefined(fractionSize)) {
        fractionSize = formats.PATTERNS[1].maxFrac;
      }
      return amount == null
        ? amount
        : formatNumber(
            amount,
            formats.PATTERNS[1],
            formats.GROUP_SEP,
            formats.DECIMAL_SEP,
            fractionSize
          ).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ["$locale"];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
      return number == null
        ? number
        : formatNumber(
            number,
            formats.PATTERNS[0],
            formats.GROUP_SEP,
            formats.DECIMAL_SEP,
            fractionSize
          );
    };
  }
  function parse(numStr) {
    var exponent = 0,
      digits,
      numberOfIntegerDigits;
    var i, j, zeros;
    if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
      numStr = numStr.replace(DECIMAL_SEP, "");
    }
    if ((i = numStr.search(/e/i)) > 0) {
      if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i;
      numberOfIntegerDigits += +numStr.slice(i + 1);
      numStr = numStr.substring(0, i);
    } else if (numberOfIntegerDigits < 0) {
      numberOfIntegerDigits = numStr.length;
    }
    for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
    if (i == (zeros = numStr.length)) {
      digits = [0];
      numberOfIntegerDigits = 1;
    } else {
      zeros--;
      while (numStr.charAt(zeros) == ZERO_CHAR) zeros--;
      numberOfIntegerDigits -= i;
      digits = [];
      for (j = 0; i <= zeros; i++, j++) {
        digits[j] = +numStr.charAt(i);
      }
    }
    if (numberOfIntegerDigits > MAX_DIGITS) {
      digits = digits.splice(0, MAX_DIGITS - 1);
      exponent = numberOfIntegerDigits - 1;
      numberOfIntegerDigits = 1;
    }
    return { d: digits, e: exponent, i: numberOfIntegerDigits };
  }
  function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
    var digits = parsedNumber.d;
    var fractionLen = digits.length - parsedNumber.i;
    fractionSize = isUndefined(fractionSize)
      ? Math.min(Math.max(minFrac, fractionLen), maxFrac)
      : +fractionSize;
    var roundAt = fractionSize + parsedNumber.i;
    var digit = digits[roundAt];
    if (roundAt > 0) {
      digits.splice(roundAt);
    } else {
      parsedNumber.i = 1;
      digits.length = roundAt = fractionSize + 1;
      for (var i = 0; i < roundAt; i++) digits[i] = 0;
    }
    if (digit >= 5) digits[roundAt - 1]++;
    for (; fractionLen < fractionSize; fractionLen++) digits.push(0);
    var carry = digits.reduceRight(function (carry, d, i, digits) {
      d = d + carry;
      digits[i] = d % 10;
      return Math.floor(d / 10);
    }, 0);
    if (carry) {
      digits.unshift(carry);
      parsedNumber.i++;
    }
  }
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (!(isString(number) || isNumber(number)) || isNaN(number)) return "";
    var isInfinity = !isFinite(number);
    var isZero = false;
    var numStr = Math.abs(number) + "",
      formattedText = "",
      parsedNumber;
    if (isInfinity) {
      formattedText = "\u221e";
    } else {
      parsedNumber = parse(numStr);
      roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
      var digits = parsedNumber.d;
      var integerLen = parsedNumber.i;
      var exponent = parsedNumber.e;
      var decimals = [];
      isZero = digits.reduce(function (isZero, d) {
        return isZero && !d;
      }, true);
      while (integerLen < 0) {
        digits.unshift(0);
        integerLen++;
      }
      if (integerLen > 0) {
        decimals = digits.splice(integerLen, digits.length);
      } else {
        decimals = digits;
        digits = [0];
      }
      var groups = [];
      if (digits.length >= pattern.lgSize) {
        groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
      }
      while (digits.length > pattern.gSize) {
        groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
      }
      if (digits.length) {
        groups.unshift(digits.join(""));
      }
      formattedText = groups.join(groupSep);
      if (decimals.length) {
        formattedText += decimalSep + decimals.join("");
      }
      if (exponent) {
        formattedText += "e+" + exponent;
      }
    }
    if (number < 0 && !isZero) {
      return pattern.negPre + formattedText + pattern.negSuf;
    } else {
      return pattern.posPre + formattedText + pattern.posSuf;
    }
  }
  function padNumber(num, digits, trim) {
    var neg = "";
    if (num < 0) {
      neg = "-";
      num = -num;
    }
    num = "" + num;
    while (num.length < digits) num = ZERO_CHAR + num;
    if (trim) {
      num = num.substr(num.length - digits);
    }
    return neg + num;
  }
  function dateGetter(name, size, offset, trim) {
    offset = offset || 0;
    return function (date) {
      var value = date["get" + name]();
      if (offset > 0 || value > -offset) {
        value += offset;
      }
      if (value === 0 && offset == -12) value = 12;
      return padNumber(value, size, trim);
    };
  }
  function dateStrGetter(name, shortForm) {
    return function (date, formats) {
      var value = date["get" + name]();
      var get = uppercase(shortForm ? "SHORT" + name : name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date, formats, offset) {
    var zone = -1 * offset;
    var paddedZone = zone >= 0 ? "+" : "";
    paddedZone +=
      padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) +
      padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function getFirstThursdayOfYear(year) {
    var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
    return new Date(
      year,
      0,
      (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst
    );
  }
  function getThursdayThisWeek(datetime) {
    return new Date(
      datetime.getFullYear(),
      datetime.getMonth(),
      datetime.getDate() + (4 - datetime.getDay())
    );
  }
  function weekGetter(size) {
    return function (date) {
      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
        thisThurs = getThursdayThisWeek(date);
      var diff = +thisThurs - +firstThurs,
        result = 1 + Math.round(diff / 6.048e8);
      return padNumber(result, size);
    };
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  function eraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
  }
  function longEraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
  }
  var DATE_FORMATS = {
    yyyy: dateGetter("FullYear", 4),
    yy: dateGetter("FullYear", 2, 0, true),
    y: dateGetter("FullYear", 1),
    MMMM: dateStrGetter("Month"),
    MMM: dateStrGetter("Month", true),
    MM: dateGetter("Month", 2, 1),
    M: dateGetter("Month", 1, 1),
    dd: dateGetter("Date", 2),
    d: dateGetter("Date", 1),
    HH: dateGetter("Hours", 2),
    H: dateGetter("Hours", 1),
    hh: dateGetter("Hours", 2, -12),
    h: dateGetter("Hours", 1, -12),
    mm: dateGetter("Minutes", 2),
    m: dateGetter("Minutes", 1),
    ss: dateGetter("Seconds", 2),
    s: dateGetter("Seconds", 1),
    sss: dateGetter("Milliseconds", 3),
    EEEE: dateStrGetter("Day"),
    EEE: dateStrGetter("Day", true),
    a: ampmGetter,
    Z: timeZoneGetter,
    ww: weekGetter(2),
    w: weekGetter(1),
    G: eraGetter,
    GG: eraGetter,
    GGG: eraGetter,
    GGGG: longEraGetter,
  };
  var DATE_FORMATS_SPLIT =
      /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
    NUMBER_STRING = /^\-?\d+$/;
  dateFilter.$inject = ["$locale"];
  function dateFilter($locale) {
    var R_ISO8601_STR =
      /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if ((match = string.match(R_ISO8601_STR))) {
        var date = new Date(0),
          tzHour = 0,
          tzMin = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;
        if (match[9]) {
          tzHour = toInt(match[9] + match[10]);
          tzMin = toInt(match[9] + match[11]);
        }
        dateSetter.call(
          date,
          toInt(match[1]),
          toInt(match[2]) - 1,
          toInt(match[3])
        );
        var h = toInt(match[4] || 0) - tzHour;
        var m = toInt(match[5] || 0) - tzMin;
        var s = toInt(match[6] || 0);
        var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1000);
        timeSetter.call(date, h, m, s, ms);
        return date;
      }
      return string;
    }
    return function (date, format, timezone) {
      var text = "",
        parts = [],
        fn,
        match;
      format = format || "mediumDate";
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date) || !isFinite(date.getTime())) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      var dateTimezoneOffset = date.getTimezoneOffset();
      if (timezone) {
        dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        date = convertTimezoneToLocal(date, timezone, true);
      }
      forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn
          ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset)
          : value === "''"
          ? "'"
          : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
      });
      return text;
    };
  }
  function jsonFilter() {
    return function (object, spacing) {
      if (isUndefined(spacing)) {
        spacing = 2;
      }
      return toJson(object, spacing);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function (input, limit, begin) {
      if (Math.abs(Number(limit)) === Infinity) {
        limit = Number(limit);
      } else {
        limit = toInt(limit);
      }
      if (isNaN(limit)) return input;
      if (isNumber(input)) input = input.toString();
      if (!isArray(input) && !isString(input)) return input;
      begin = !begin || isNaN(begin) ? 0 : toInt(begin);
      begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
      if (limit >= 0) {
        return input.slice(begin, begin + limit);
      } else {
        if (begin === 0) {
          return input.slice(limit, input.length);
        } else {
          return input.slice(Math.max(0, begin + limit), begin);
        }
      }
    };
  }
  orderByFilter.$inject = ["$parse"];
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder) {
      if (!isArrayLike(array)) return array;
      if (!isArray(sortPredicate)) {
        sortPredicate = [sortPredicate];
      }
      if (sortPredicate.length === 0) {
        sortPredicate = ["+"];
      }
      var predicates = processPredicates(sortPredicate, reverseOrder);
      predicates.push({
        get: function () {
          return {};
        },
        descending: reverseOrder ? -1 : 1,
      });
      var compareValues = Array.prototype.map.call(array, getComparisonObject);
      compareValues.sort(doComparison);
      array = compareValues.map(function (item) {
        return item.value;
      });
      return array;
      function getComparisonObject(value, index) {
        return {
          value: value,
          predicateValues: predicates.map(function (predicate) {
            return getPredicateValue(predicate.get(value), index);
          }),
        };
      }
      function doComparison(v1, v2) {
        var result = 0;
        for (
          var index = 0, length = predicates.length;
          index < length;
          ++index
        ) {
          result =
            compare(v1.predicateValues[index], v2.predicateValues[index]) *
            predicates[index].descending;
          if (result) break;
        }
        return result;
      }
    };
    function processPredicates(sortPredicate, reverseOrder) {
      reverseOrder = reverseOrder ? -1 : 1;
      return sortPredicate.map(function (predicate) {
        var descending = 1,
          get = identity;
        if (isFunction(predicate)) {
          get = predicate;
        } else if (isString(predicate)) {
          if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
            descending = predicate.charAt(0) == "-" ? -1 : 1;
            predicate = predicate.substring(1);
          }
          if (predicate !== "") {
            get = $parse(predicate);
            if (get.constant) {
              var key = get();
              get = function (value) {
                return value[key];
              };
            }
          }
        }
        return { get: get, descending: descending * reverseOrder };
      });
    }
    function isPrimitive(value) {
      switch (typeof value) {
        case "number":
        case "boolean":
        case "string":
          return true;
        default:
          return false;
      }
    }
    function objectValue(value, index) {
      if (typeof value.valueOf === "function") {
        value = value.valueOf();
        if (isPrimitive(value)) return value;
      }
      if (hasCustomToString(value)) {
        value = value.toString();
        if (isPrimitive(value)) return value;
      }
      return index;
    }
    function getPredicateValue(value, index) {
      var type = typeof value;
      if (value === null) {
        type = "string";
        value = "null";
      } else if (type === "string") {
        value = value.toLowerCase();
      } else if (type === "object") {
        value = objectValue(value, index);
      }
      return { value: value, type: type };
    }
    function compare(v1, v2) {
      var result = 0;
      if (v1.type === v2.type) {
        if (v1.value !== v2.value) {
          result = v1.value < v2.value ? -1 : 1;
        }
      } else {
        result = v1.type < v2.type ? -1 : 1;
      }
      return result;
    }
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = { link: directive };
    }
    directive.restrict = directive.restrict || "AC";
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
    restrict: "E",
    compile: function (element, attr) {
      if (!attr.href && !attr.xlinkHref) {
        return function (scope, element) {
          if (element[0].nodeName.toLowerCase() !== "a") return;
          var href =
            toString.call(element.prop("href")) === "[object SVGAnimatedString]"
              ? "xlink:href"
              : "href";
          element.on("click", function (event) {
            if (!element.attr(href)) {
              event.preventDefault();
            }
          });
        };
      }
    },
  });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function (propName, attrName) {
    if (propName == "multiple") return;
    function defaultLinkFn(scope, element, attr) {
      scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
        attr.$set(attrName, !!value);
      });
    }
    var normalized = directiveNormalize("ng-" + attrName);
    var linkFn = defaultLinkFn;
    if (propName === "checked") {
      linkFn = function (scope, element, attr) {
        if (attr.ngModel !== attr[normalized]) {
          defaultLinkFn(scope, element, attr);
        }
      };
    }
    ngAttributeAliasDirectives[normalized] = function () {
      return { restrict: "A", priority: 100, link: linkFn };
    };
  });
  forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
    ngAttributeAliasDirectives[ngAttr] = function () {
      return {
        priority: 100,
        link: function (scope, element, attr) {
          if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
              attr.$set("ngPattern", new RegExp(match[1], match[2]));
              return;
            }
          }
          scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
          });
        },
      };
    };
  });
  forEach(["src", "srcset", "href"], function (attrName) {
    var normalized = directiveNormalize("ng-" + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 99,
        link: function (scope, element, attr) {
          var propName = attrName,
            name = attrName;
          if (
            attrName === "href" &&
            toString.call(element.prop("href")) === "[object SVGAnimatedString]"
          ) {
            name = "xlinkHref";
            attr.$attr[name] = "xlink:href";
            propName = null;
          }
          attr.$observe(normalized, function (value) {
            if (!value) {
              if (attrName === "href") {
                attr.$set(name, null);
              }
              return;
            }
            attr.$set(name, value);
            if (msie && propName) element.prop(propName, attr[name]);
          });
        },
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $$renameControl: nullFormRenameControl,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop,
      $setPristine: noop,
      $setSubmitted: noop,
    },
    SUBMITTED_CLASS = "ng-submitted";
  function nullFormRenameControl(control, name) {
    control.$name = name;
  }
  FormController.$inject = [
    "$element",
    "$attrs",
    "$scope",
    "$animate",
    "$interpolate",
  ];
  function FormController(element, attrs, $scope, $animate, $interpolate) {
    var form = this,
      controls = [];
    form.$error = {};
    form.$$success = {};
    form.$pending = undefined;
    form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope);
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    form.$submitted = false;
    form.$$parentForm = nullFormCtrl;
    form.$rollbackViewValue = function () {
      forEach(controls, function (control) {
        control.$rollbackViewValue();
      });
    };
    form.$commitViewValue = function () {
      forEach(controls, function (control) {
        control.$commitViewValue();
      });
    };
    form.$addControl = function (control) {
      assertNotHasOwnProperty(control.$name, "input");
      controls.push(control);
      if (control.$name) {
        form[control.$name] = control;
      }
      control.$$parentForm = form;
    };
    form.$$renameControl = function (control, newName) {
      var oldName = control.$name;
      if (form[oldName] === control) {
        delete form[oldName];
      }
      form[newName] = control;
      control.$name = newName;
    };
    form.$removeControl = function (control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(form.$pending, function (value, name) {
        form.$setValidity(name, null, control);
      });
      forEach(form.$error, function (value, name) {
        form.$setValidity(name, null, control);
      });
      forEach(form.$$success, function (value, name) {
        form.$setValidity(name, null, control);
      });
      arrayRemove(controls, control);
      control.$$parentForm = nullFormCtrl;
    };
    addSetValidityMethod({
      ctrl: this,
      $element: element,
      set: function (object, property, controller) {
        var list = object[property];
        if (!list) {
          object[property] = [controller];
        } else {
          var index = list.indexOf(controller);
          if (index === -1) {
            list.push(controller);
          }
        }
      },
      unset: function (object, property, controller) {
        var list = object[property];
        if (!list) {
          return;
        }
        arrayRemove(list, controller);
        if (list.length === 0) {
          delete object[property];
        }
      },
      $animate: $animate,
    });
    form.$setDirty = function () {
      $animate.removeClass(element, PRISTINE_CLASS);
      $animate.addClass(element, DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      form.$$parentForm.$setDirty();
    };
    form.$setPristine = function () {
      $animate.setClass(
        element,
        PRISTINE_CLASS,
        DIRTY_CLASS + " " + SUBMITTED_CLASS
      );
      form.$dirty = false;
      form.$pristine = true;
      form.$submitted = false;
      forEach(controls, function (control) {
        control.$setPristine();
      });
    };
    form.$setUntouched = function () {
      forEach(controls, function (control) {
        control.$setUntouched();
      });
    };
    form.$setSubmitted = function () {
      $animate.addClass(element, SUBMITTED_CLASS);
      form.$submitted = true;
      form.$$parentForm.$setSubmitted();
    };
  }
  var formDirectiveFactory = function (isNgForm) {
    return [
      "$timeout",
      "$parse",
      function ($timeout, $parse) {
        var formDirective = {
          name: "form",
          restrict: isNgForm ? "EAC" : "E",
          require: ["form", "^^?form"],
          controller: FormController,
          compile: function ngFormCompile(formElement, attr) {
            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
            var nameAttr = attr.name
              ? "name"
              : isNgForm && attr.ngForm
              ? "ngForm"
              : false;
            return {
              pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                var controller = ctrls[0];
                if (!("action" in attr)) {
                  var handleFormSubmission = function (event) {
                    scope.$apply(function () {
                      controller.$commitViewValue();
                      controller.$setSubmitted();
                    });
                    event.preventDefault();
                  };
                  addEventListenerFn(
                    formElement[0],
                    "submit",
                    handleFormSubmission
                  );
                  formElement.on("$destroy", function () {
                    $timeout(
                      function () {
                        removeEventListenerFn(
                          formElement[0],
                          "submit",
                          handleFormSubmission
                        );
                      },
                      0,
                      false
                    );
                  });
                }
                var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                parentFormCtrl.$addControl(controller);
                var setter = nameAttr ? getSetter(controller.$name) : noop;
                if (nameAttr) {
                  setter(scope, controller);
                  attr.$observe(nameAttr, function (newValue) {
                    if (controller.$name === newValue) return;
                    setter(scope, undefined);
                    controller.$$parentForm.$$renameControl(
                      controller,
                      newValue
                    );
                    setter = getSetter(controller.$name);
                    setter(scope, controller);
                  });
                }
                formElement.on("$destroy", function () {
                  controller.$$parentForm.$removeControl(controller);
                  setter(scope, undefined);
                  extend(controller, nullFormCtrl);
                });
              },
            };
          },
        };
        return formDirective;
        function getSetter(expression) {
          if (expression === "") {
            return $parse('this[""]').assign;
          }
          return $parse(expression).assign || noop;
        }
      },
    ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var ISO_DATE_REGEXP =
    /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
  var URL_REGEXP =
    /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
  var EMAIL_REGEXP =
    /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
  var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
  var DATETIMELOCAL_REGEXP =
    /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
  var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
  var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
  var PARTIAL_VALIDATION_TYPES = createMap();
  forEach("date,datetime-local,month,time,week".split(","), function (type) {
    PARTIAL_VALIDATION_TYPES[type] = true;
  });
  var inputType = {
    text: textInputType,
    date: createDateInputType(
      "date",
      DATE_REGEXP,
      createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]),
      "yyyy-MM-dd"
    ),
    "datetime-local": createDateInputType(
      "datetimelocal",
      DATETIMELOCAL_REGEXP,
      createDateParser(DATETIMELOCAL_REGEXP, [
        "yyyy",
        "MM",
        "dd",
        "HH",
        "mm",
        "ss",
        "sss",
      ]),
      "yyyy-MM-ddTHH:mm:ss.sss"
    ),
    time: createDateInputType(
      "time",
      TIME_REGEXP,
      createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]),
      "HH:mm:ss.sss"
    ),
    week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
    month: createDateInputType(
      "month",
      MONTH_REGEXP,
      createDateParser(MONTH_REGEXP, ["yyyy", "MM"]),
      "yyyy-MM"
    ),
    number: numberInputType,
    url: urlInputType,
    email: emailInputType,
    radio: radioInputType,
    checkbox: checkboxInputType,
    hidden: noop,
    button: noop,
    submit: noop,
    reset: noop,
    file: noop,
  };
  function stringBasedInputType(ctrl) {
    ctrl.$formatters.push(function (value) {
      return ctrl.$isEmpty(value) ? value : value.toString();
    });
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
  }
  function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var type = lowercase(element[0].type);
    if (!$sniffer.android) {
      var composing = false;
      element.on("compositionstart", function (data) {
        composing = true;
      });
      element.on("compositionend", function () {
        composing = false;
        listener();
      });
    }
    var timeout;
    var listener = function (ev) {
      if (timeout) {
        $browser.defer.cancel(timeout);
        timeout = null;
      }
      if (composing) return;
      var value = element.val(),
        event = ev && ev.type;
      if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
        value = trim(value);
      }
      if (
        ctrl.$viewValue !== value ||
        (value === "" && ctrl.$$hasNativeValidators)
      ) {
        ctrl.$setViewValue(value, event);
      }
    };
    if ($sniffer.hasEvent("input")) {
      element.on("input", listener);
    } else {
      var deferListener = function (ev, input, origValue) {
        if (!timeout) {
          timeout = $browser.defer(function () {
            timeout = null;
            if (!input || input.value !== origValue) {
              listener(ev);
            }
          });
        }
      };
      element.on("keydown", function (event) {
        var key = event.keyCode;
        if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
          return;
        deferListener(event, this, this.value);
      });
      if ($sniffer.hasEvent("paste")) {
        element.on("paste cut", deferListener);
      }
    }
    element.on("change", listener);
    if (
      PARTIAL_VALIDATION_TYPES[type] &&
      ctrl.$$hasNativeValidators &&
      type === attr.type
    ) {
      element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
        if (!timeout) {
          var validity = this[VALIDITY_STATE_PROPERTY];
          var origBadInput = validity.badInput;
          var origTypeMismatch = validity.typeMismatch;
          timeout = $browser.defer(function () {
            timeout = null;
            if (
              validity.badInput !== origBadInput ||
              validity.typeMismatch !== origTypeMismatch
            ) {
              listener(ev);
            }
          });
        }
      });
    }
    ctrl.$render = function () {
      var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
      if (element.val() !== value) {
        element.val(value);
      }
    };
  }
  function weekParser(isoWeek, existingDate) {
    if (isDate(isoWeek)) {
      return isoWeek;
    }
    if (isString(isoWeek)) {
      WEEK_REGEXP.lastIndex = 0;
      var parts = WEEK_REGEXP.exec(isoWeek);
      if (parts) {
        var year = +parts[1],
          week = +parts[2],
          hours = 0,
          minutes = 0,
          seconds = 0,
          milliseconds = 0,
          firstThurs = getFirstThursdayOfYear(year),
          addDays = (week - 1) * 7;
        if (existingDate) {
          hours = existingDate.getHours();
          minutes = existingDate.getMinutes();
          seconds = existingDate.getSeconds();
          milliseconds = existingDate.getMilliseconds();
        }
        return new Date(
          year,
          0,
          firstThurs.getDate() + addDays,
          hours,
          minutes,
          seconds,
          milliseconds
        );
      }
    }
    return NaN;
  }
  function createDateParser(regexp, mapping) {
    return function (iso, date) {
      var parts, map;
      if (isDate(iso)) {
        return iso;
      }
      if (isString(iso)) {
        if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
          iso = iso.substring(1, iso.length - 1);
        }
        if (ISO_DATE_REGEXP.test(iso)) {
          return new Date(iso);
        }
        regexp.lastIndex = 0;
        parts = regexp.exec(iso);
        if (parts) {
          parts.shift();
          if (date) {
            map = {
              yyyy: date.getFullYear(),
              MM: date.getMonth() + 1,
              dd: date.getDate(),
              HH: date.getHours(),
              mm: date.getMinutes(),
              ss: date.getSeconds(),
              sss: date.getMilliseconds() / 1000,
            };
          } else {
            map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
          }
          forEach(parts, function (part, index) {
            if (index < mapping.length) {
              map[mapping[index]] = +part;
            }
          });
          return new Date(
            map.yyyy,
            map.MM - 1,
            map.dd,
            map.HH,
            map.mm,
            map.ss || 0,
            map.sss * 1000 || 0
          );
        }
      }
      return NaN;
    };
  }
  function createDateInputType(type, regexp, parseDate, format) {
    return function dynamicDateInputType(
      scope,
      element,
      attr,
      ctrl,
      $sniffer,
      $browser,
      $filter
    ) {
      badInputChecker(scope, element, attr, ctrl);
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
      var previousDate;
      ctrl.$$parserName = type;
      ctrl.$parsers.push(function (value) {
        if (ctrl.$isEmpty(value)) return null;
        if (regexp.test(value)) {
          var parsedDate = parseDate(value, previousDate);
          if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
          }
          return parsedDate;
        }
        return undefined;
      });
      ctrl.$formatters.push(function (value) {
        if (value && !isDate(value)) {
          throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
        }
        if (isValidDate(value)) {
          previousDate = value;
          if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
          }
          return $filter("date")(value, format, timezone);
        } else {
          previousDate = null;
          return "";
        }
      });
      if (isDefined(attr.min) || attr.ngMin) {
        var minVal;
        ctrl.$validators.min = function (value) {
          return (
            !isValidDate(value) ||
            isUndefined(minVal) ||
            parseDate(value) >= minVal
          );
        };
        attr.$observe("min", function (val) {
          minVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }
      if (isDefined(attr.max) || attr.ngMax) {
        var maxVal;
        ctrl.$validators.max = function (value) {
          return (
            !isValidDate(value) ||
            isUndefined(maxVal) ||
            parseDate(value) <= maxVal
          );
        };
        attr.$observe("max", function (val) {
          maxVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }
      function isValidDate(value) {
        return value && !(value.getTime && value.getTime() !== value.getTime());
      }
      function parseObservedDateValue(val) {
        return isDefined(val) && !isDate(val)
          ? parseDate(val) || undefined
          : val;
      }
    };
  }
  function badInputChecker(scope, element, attr, ctrl) {
    var node = element[0];
    var nativeValidation = (ctrl.$$hasNativeValidators = isObject(
      node.validity
    ));
    if (nativeValidation) {
      ctrl.$parsers.push(function (value) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
        return validity.badInput && !validity.typeMismatch ? undefined : value;
      });
    }
  }
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    badInputChecker(scope, element, attr, ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$$parserName = "number";
    ctrl.$parsers.push(function (value) {
      if (ctrl.$isEmpty(value)) return null;
      if (NUMBER_REGEXP.test(value)) return parseFloat(value);
      return undefined;
    });
    ctrl.$formatters.push(function (value) {
      if (!ctrl.$isEmpty(value)) {
        if (!isNumber(value)) {
          throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
        }
        value = value.toString();
      }
      return value;
    });
    if (isDefined(attr.min) || attr.ngMin) {
      var minVal;
      ctrl.$validators.min = function (value) {
        return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
      };
      attr.$observe("min", function (val) {
        if (isDefined(val) && !isNumber(val)) {
          val = parseFloat(val, 10);
        }
        minVal = isNumber(val) && !isNaN(val) ? val : undefined;
        ctrl.$validate();
      });
    }
    if (isDefined(attr.max) || attr.ngMax) {
      var maxVal;
      ctrl.$validators.max = function (value) {
        return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
      };
      attr.$observe("max", function (val) {
        if (isDefined(val) && !isNumber(val)) {
          val = parseFloat(val, 10);
        }
        maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
        ctrl.$validate();
      });
    }
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = "url";
    ctrl.$validators.url = function (modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
    };
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = "email";
    ctrl.$validators.email = function (modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
    };
  }
  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr("name", nextUid());
    }
    var listener = function (ev) {
      if (element[0].checked) {
        ctrl.$setViewValue(attr.value, ev && ev.type);
      }
    };
    element.on("click", listener);
    ctrl.$render = function () {
      var value = attr.value;
      element[0].checked = value == ctrl.$viewValue;
    };
    attr.$observe("value", ctrl.$render);
  }
  function parseConstantExpr($parse, context, name, expression, fallback) {
    var parseFn;
    if (isDefined(expression)) {
      parseFn = $parse(expression);
      if (!parseFn.constant) {
        throw ngModelMinErr(
          "constexpr",
          "Expected constant expression for `{0}`, but saw " + "`{1}`.",
          name,
          expression
        );
      }
      return parseFn(context);
    }
    return fallback;
  }
  function checkboxInputType(
    scope,
    element,
    attr,
    ctrl,
    $sniffer,
    $browser,
    $filter,
    $parse
  ) {
    var trueValue = parseConstantExpr(
      $parse,
      scope,
      "ngTrueValue",
      attr.ngTrueValue,
      true
    );
    var falseValue = parseConstantExpr(
      $parse,
      scope,
      "ngFalseValue",
      attr.ngFalseValue,
      false
    );
    var listener = function (ev) {
      ctrl.$setViewValue(element[0].checked, ev && ev.type);
    };
    element.on("click", listener);
    ctrl.$render = function () {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$isEmpty = function (value) {
      return value === false;
    };
    ctrl.$formatters.push(function (value) {
      return equals(value, trueValue);
    });
    ctrl.$parsers.push(function (value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [
    "$browser",
    "$sniffer",
    "$filter",
    "$parse",
    function ($browser, $sniffer, $filter, $parse) {
      return {
        restrict: "E",
        require: ["?ngModel"],
        link: {
          pre: function (scope, element, attr, ctrls) {
            if (ctrls[0]) {
              (inputType[lowercase(attr.type)] || inputType.text)(
                scope,
                element,
                attr,
                ctrls[0],
                $sniffer,
                $browser,
                $filter,
                $parse
              );
            }
          },
        },
      };
    },
  ];
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function () {
    return {
      restrict: "A",
      priority: 100,
      compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function ngValueConstantLink(scope, elm, attr) {
            attr.$set("value", scope.$eval(attr.ngValue));
          };
        } else {
          return function ngValueLink(scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set("value", value);
            });
          };
        }
      },
    };
  };
  var ngBindDirective = [
    "$compile",
    function ($compile) {
      return {
        restrict: "AC",
        compile: function ngBindCompile(templateElement) {
          $compile.$$addBindingClass(templateElement);
          return function ngBindLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBind);
            element = element[0];
            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
              element.textContent = isUndefined(value) ? "" : value;
            });
          };
        },
      };
    },
  ];
  var ngBindTemplateDirective = [
    "$interpolate",
    "$compile",
    function ($interpolate, $compile) {
      return {
        compile: function ngBindTemplateCompile(templateElement) {
          $compile.$$addBindingClass(templateElement);
          return function ngBindTemplateLink(scope, element, attr) {
            var interpolateFn = $interpolate(
              element.attr(attr.$attr.ngBindTemplate)
            );
            $compile.$$addBindingInfo(element, interpolateFn.expressions);
            element = element[0];
            attr.$observe("ngBindTemplate", function (value) {
              element.textContent = isUndefined(value) ? "" : value;
            });
          };
        },
      };
    },
  ];
  var ngBindHtmlDirective = [
    "$sce",
    "$parse",
    "$compile",
    function ($sce, $parse, $compile) {
      return {
        restrict: "A",
        compile: function ngBindHtmlCompile(tElement, tAttrs) {
          var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
          var ngBindHtmlWatch = $parse(
            tAttrs.ngBindHtml,
            function sceValueOf(val) {
              return $sce.valueOf(val);
            }
          );
          $compile.$$addBindingClass(tElement);
          return function ngBindHtmlLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBindHtml);
            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
              var value = ngBindHtmlGetter(scope);
              element.html($sce.getTrustedHtml(value) || "");
            });
          };
        },
      };
    },
  ];
  var ngChangeDirective = valueFn({
    restrict: "A",
    require: "ngModel",
    link: function (scope, element, attr, ctrl) {
      ctrl.$viewChangeListeners.push(function () {
        scope.$eval(attr.ngChange);
      });
    },
  });
  function classDirective(name, selector) {
    name = "ngClass" + name;
    return [
      "$animate",
      function ($animate) {
        return {
          restrict: "AC",
          link: function (scope, element, attr) {
            var oldVal;
            scope.$watch(attr[name], ngClassWatchAction, true);
            attr.$observe("class", function (value) {
              ngClassWatchAction(scope.$eval(attr[name]));
            });
            if (name !== "ngClass") {
              scope.$watch("$index", function ($index, old$index) {
                var mod = $index & 1;
                if (mod !== (old$index & 1)) {
                  var classes = arrayClasses(scope.$eval(attr[name]));
                  mod === selector
                    ? addClasses(classes)
                    : removeClasses(classes);
                }
              });
            }
            function addClasses(classes) {
              var newClasses = digestClassCounts(classes, 1);
              attr.$addClass(newClasses);
            }
            function removeClasses(classes) {
              var newClasses = digestClassCounts(classes, -1);
              attr.$removeClass(newClasses);
            }
            function digestClassCounts(classes, count) {
              var classCounts = element.data("$classCounts") || createMap();
              var classesToUpdate = [];
              forEach(classes, function (className) {
                if (count > 0 || classCounts[className]) {
                  classCounts[className] =
                    (classCounts[className] || 0) + count;
                  if (classCounts[className] === +(count > 0)) {
                    classesToUpdate.push(className);
                  }
                }
              });
              element.data("$classCounts", classCounts);
              return classesToUpdate.join(" ");
            }
            function updateClasses(oldClasses, newClasses) {
              var toAdd = arrayDifference(newClasses, oldClasses);
              var toRemove = arrayDifference(oldClasses, newClasses);
              toAdd = digestClassCounts(toAdd, 1);
              toRemove = digestClassCounts(toRemove, -1);
              if (toAdd && toAdd.length) {
                $animate.addClass(element, toAdd);
              }
              if (toRemove && toRemove.length) {
                $animate.removeClass(element, toRemove);
              }
            }
            function ngClassWatchAction(newVal) {
              if (selector === true || scope.$index % 2 === selector) {
                var newClasses = arrayClasses(newVal || []);
                if (!oldVal) {
                  addClasses(newClasses);
                } else if (!equals(newVal, oldVal)) {
                  var oldClasses = arrayClasses(oldVal);
                  updateClasses(oldClasses, newClasses);
                }
              }
              if (isArray(newVal)) {
                oldVal = newVal.map(function (v) {
                  return shallowCopy(v);
                });
              } else {
                oldVal = shallowCopy(newVal);
              }
            }
          },
        };
        function arrayDifference(tokens1, tokens2) {
          var values = [];
          outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
              if (token == tokens2[j]) continue outer;
            }
            values.push(token);
          }
          return values;
        }
        function arrayClasses(classVal) {
          var classes = [];
          if (isArray(classVal)) {
            forEach(classVal, function (v) {
              classes = classes.concat(arrayClasses(v));
            });
            return classes;
          } else if (isString(classVal)) {
            return classVal.split(" ");
          } else if (isObject(classVal)) {
            forEach(classVal, function (v, k) {
              if (v) {
                classes = classes.concat(k.split(" "));
              }
            });
            return classes;
          }
          return classVal;
        }
      },
    ];
  }
  var ngClassDirective = classDirective("", true);
  var ngClassOddDirective = classDirective("Odd", 0);
  var ngClassEvenDirective = classDirective("Even", 1);
  var ngCloakDirective = ngDirective({
    compile: function (element, attr) {
      attr.$set("ngCloak", undefined);
      element.removeClass("ng-cloak");
    },
  });
  var ngControllerDirective = [
    function () {
      return { restrict: "A", scope: true, controller: "@", priority: 500 };
    },
  ];
  var ngEventDirectives = {};
  var forceAsyncEvents = { blur: true, focus: true };
  forEach(
    "click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(
      " "
    ),
    function (eventName) {
      var directiveName = directiveNormalize("ng-" + eventName);
      ngEventDirectives[directiveName] = [
        "$parse",
        "$rootScope",
        function ($parse, $rootScope) {
          return {
            restrict: "A",
            compile: function ($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function (event) {
                  var callback = function () {
                    fn(scope, { $event: event });
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            },
          };
        },
      ];
    }
  );
  var ngIfDirective = [
    "$animate",
    function ($animate) {
      return {
        multiElement: true,
        transclude: "element",
        priority: 600,
        terminal: true,
        restrict: "A",
        $$tlb: true,
        link: function ($scope, $element, $attr, ctrl, $transclude) {
          var block, childScope, previousElements;
          $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
            if (value) {
              if (!childScope) {
                $transclude(function (clone, newScope) {
                  childScope = newScope;
                  clone[clone.length++] = document.createComment(
                    " end ngIf: " + $attr.ngIf + " "
                  );
                  block = { clone: clone };
                  $animate.enter(clone, $element.parent(), $element);
                });
              }
            } else {
              if (previousElements) {
                previousElements.remove();
                previousElements = null;
              }
              if (childScope) {
                childScope.$destroy();
                childScope = null;
              }
              if (block) {
                previousElements = getBlockNodes(block.clone);
                $animate.leave(previousElements).then(function () {
                  previousElements = null;
                });
                block = null;
              }
            }
          });
        },
      };
    },
  ];
  var ngIncludeDirective = [
    "$templateRequest",
    "$anchorScroll",
    "$animate",
    function ($templateRequest, $anchorScroll, $animate) {
      return {
        restrict: "ECA",
        priority: 400,
        terminal: true,
        transclude: "element",
        controller: angular.noop,
        compile: function (element, attr) {
          var srcExp = attr.ngInclude || attr.src,
            onloadExp = attr.onload || "",
            autoScrollExp = attr.autoscroll;
          return function (scope, $element, $attr, ctrl, $transclude) {
            var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
            var cleanupLastIncludeContent = function () {
              if (previousElement) {
                previousElement.remove();
                previousElement = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentElement) {
                $animate.leave(currentElement).then(function () {
                  previousElement = null;
                });
                previousElement = currentElement;
                currentElement = null;
              }
            };
            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
              var afterAnimation = function () {
                if (
                  isDefined(autoScrollExp) &&
                  (!autoScrollExp || scope.$eval(autoScrollExp))
                ) {
                  $anchorScroll();
                }
              };
              var thisChangeId = ++changeCounter;
              if (src) {
                $templateRequest(src, true).then(
                  function (response) {
                    if (scope.$$destroyed) return;
                    if (thisChangeId !== changeCounter) return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function (clone) {
                      cleanupLastIncludeContent();
                      $animate
                        .enter(clone, null, $element)
                        .then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit("$includeContentLoaded", src);
                    scope.$eval(onloadExp);
                  },
                  function () {
                    if (scope.$$destroyed) return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit("$includeContentError", src);
                    }
                  }
                );
                scope.$emit("$includeContentRequested", src);
              } else {
                cleanupLastIncludeContent();
                ctrl.template = null;
              }
            });
          };
        },
      };
    },
  ];
  var ngIncludeFillContentDirective = [
    "$compile",
    function ($compile) {
      return {
        restrict: "ECA",
        priority: -400,
        require: "ngInclude",
        link: function (scope, $element, $attr, ctrl) {
          if (/SVG/.test($element[0].toString())) {
            $element.empty();
            $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(
              scope,
              function namespaceAdaptedClone(clone) {
                $element.append(clone);
              },
              { futureParentElement: $element }
            );
            return;
          }
          $element.html(ctrl.template);
          $compile($element.contents())(scope);
        },
      };
    },
  ];
  var ngInitDirective = ngDirective({
    priority: 450,
    compile: function () {
      return {
        pre: function (scope, element, attrs) {
          scope.$eval(attrs.ngInit);
        },
      };
    },
  });
  var ngListDirective = function () {
    return {
      restrict: "A",
      priority: 100,
      require: "ngModel",
      link: function (scope, element, attr, ctrl) {
        var ngList = element.attr(attr.$attr.ngList) || ", ";
        var trimValues = attr.ngTrim !== "false";
        var separator = trimValues ? trim(ngList) : ngList;
        var parse = function (viewValue) {
          if (isUndefined(viewValue)) return;
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function (value) {
              if (value) list.push(trimValues ? trim(value) : value);
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
          if (isArray(value)) {
            return value.join(ngList);
          }
          return undefined;
        });
        ctrl.$isEmpty = function (value) {
          return !value || !value.length;
        };
      },
    };
  };
  var VALID_CLASS = "ng-valid",
    INVALID_CLASS = "ng-invalid",
    PRISTINE_CLASS = "ng-pristine",
    DIRTY_CLASS = "ng-dirty",
    UNTOUCHED_CLASS = "ng-untouched",
    TOUCHED_CLASS = "ng-touched",
    PENDING_CLASS = "ng-pending";
  var ngModelMinErr = minErr("ngModel");
  var NgModelController = [
    "$scope",
    "$exceptionHandler",
    "$attrs",
    "$element",
    "$parse",
    "$animate",
    "$timeout",
    "$rootScope",
    "$q",
    "$interpolate",
    function (
      $scope,
      $exceptionHandler,
      $attr,
      $element,
      $parse,
      $animate,
      $timeout,
      $rootScope,
      $q,
      $interpolate
    ) {
      this.$viewValue = Number.NaN;
      this.$modelValue = Number.NaN;
      this.$$rawModelValue = undefined;
      this.$validators = {};
      this.$asyncValidators = {};
      this.$parsers = [];
      this.$formatters = [];
      this.$viewChangeListeners = [];
      this.$untouched = true;
      this.$touched = false;
      this.$pristine = true;
      this.$dirty = false;
      this.$valid = true;
      this.$invalid = false;
      this.$error = {};
      this.$$success = {};
      this.$pending = undefined;
      this.$name = $interpolate($attr.name || "", false)($scope);
      this.$$parentForm = nullFormCtrl;
      var parsedNgModel = $parse($attr.ngModel),
        parsedNgModelAssign = parsedNgModel.assign,
        ngModelGet = parsedNgModel,
        ngModelSet = parsedNgModelAssign,
        pendingDebounce = null,
        parserValid,
        ctrl = this;
      this.$$setOptions = function (options) {
        ctrl.$options = options;
        if (options && options.getterSetter) {
          var invokeModelGetter = $parse($attr.ngModel + "()"),
            invokeModelSetter = $parse($attr.ngModel + "($$$p)");
          ngModelGet = function ($scope) {
            var modelValue = parsedNgModel($scope);
            if (isFunction(modelValue)) {
              modelValue = invokeModelGetter($scope);
            }
            return modelValue;
          };
          ngModelSet = function ($scope, newValue) {
            if (isFunction(parsedNgModel($scope))) {
              invokeModelSetter($scope, { $$$p: ctrl.$modelValue });
            } else {
              parsedNgModelAssign($scope, ctrl.$modelValue);
            }
          };
        } else if (!parsedNgModel.assign) {
          throw ngModelMinErr(
            "nonassign",
            "Expression '{0}' is non-assignable. Element: {1}",
            $attr.ngModel,
            startingTag($element)
          );
        }
      };
      this.$render = noop;
      this.$isEmpty = function (value) {
        return (
          isUndefined(value) ||
          value === "" ||
          value === null ||
          value !== value
        );
      };
      var currentValidationRunId = 0;
      addSetValidityMethod({
        ctrl: this,
        $element: $element,
        set: function (object, property) {
          object[property] = true;
        },
        unset: function (object, property) {
          delete object[property];
        },
        $animate: $animate,
      });
      this.$setPristine = function () {
        ctrl.$dirty = false;
        ctrl.$pristine = true;
        $animate.removeClass($element, DIRTY_CLASS);
        $animate.addClass($element, PRISTINE_CLASS);
      };
      this.$setDirty = function () {
        ctrl.$dirty = true;
        ctrl.$pristine = false;
        $animate.removeClass($element, PRISTINE_CLASS);
        $animate.addClass($element, DIRTY_CLASS);
        ctrl.$$parentForm.$setDirty();
      };
      this.$setUntouched = function () {
        ctrl.$touched = false;
        ctrl.$untouched = true;
        $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
      };
      this.$setTouched = function () {
        ctrl.$touched = true;
        ctrl.$untouched = false;
        $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
      };
      this.$rollbackViewValue = function () {
        $timeout.cancel(pendingDebounce);
        ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
        ctrl.$render();
      };
      this.$validate = function () {
        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
          return;
        }
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = ctrl.$$rawModelValue;
        var prevValid = ctrl.$valid;
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
        ctrl.$$runValidators(modelValue, viewValue, function (allValid) {
          if (!allowInvalid && prevValid !== allValid) {
            ctrl.$modelValue = allValid ? modelValue : undefined;
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        });
      };
      this.$$runValidators = function (modelValue, viewValue, doneCallback) {
        currentValidationRunId++;
        var localValidationRunId = currentValidationRunId;
        if (!processParseErrors()) {
          validationDone(false);
          return;
        }
        if (!processSyncValidators()) {
          validationDone(false);
          return;
        }
        processAsyncValidators();
        function processParseErrors() {
          var errorKey = ctrl.$$parserName || "parse";
          if (isUndefined(parserValid)) {
            setValidity(errorKey, null);
          } else {
            if (!parserValid) {
              forEach(ctrl.$validators, function (v, name) {
                setValidity(name, null);
              });
              forEach(ctrl.$asyncValidators, function (v, name) {
                setValidity(name, null);
              });
            }
            setValidity(errorKey, parserValid);
            return parserValid;
          }
          return true;
        }
        function processSyncValidators() {
          var syncValidatorsValid = true;
          forEach(ctrl.$validators, function (validator, name) {
            var result = validator(modelValue, viewValue);
            syncValidatorsValid = syncValidatorsValid && result;
            setValidity(name, result);
          });
          if (!syncValidatorsValid) {
            forEach(ctrl.$asyncValidators, function (v, name) {
              setValidity(name, null);
            });
            return false;
          }
          return true;
        }
        function processAsyncValidators() {
          var validatorPromises = [];
          var allValid = true;
          forEach(ctrl.$asyncValidators, function (validator, name) {
            var promise = validator(modelValue, viewValue);
            if (!isPromiseLike(promise)) {
              throw ngModelMinErr(
                "nopromise",
                "Expected asynchronous validator to return a promise but got '{0}' instead.",
                promise
              );
            }
            setValidity(name, undefined);
            validatorPromises.push(
              promise.then(
                function () {
                  setValidity(name, true);
                },
                function (error) {
                  allValid = false;
                  setValidity(name, false);
                }
              )
            );
          });
          if (!validatorPromises.length) {
            validationDone(true);
          } else {
            $q.all(validatorPromises).then(function () {
              validationDone(allValid);
            }, noop);
          }
        }
        function setValidity(name, isValid) {
          if (localValidationRunId === currentValidationRunId) {
            ctrl.$setValidity(name, isValid);
          }
        }
        function validationDone(allValid) {
          if (localValidationRunId === currentValidationRunId) {
            doneCallback(allValid);
          }
        }
      };
      this.$commitViewValue = function () {
        var viewValue = ctrl.$viewValue;
        $timeout.cancel(pendingDebounce);
        if (
          ctrl.$$lastCommittedViewValue === viewValue &&
          (viewValue !== "" || !ctrl.$$hasNativeValidators)
        ) {
          return;
        }
        ctrl.$$lastCommittedViewValue = viewValue;
        if (ctrl.$pristine) {
          this.$setDirty();
        }
        this.$$parseAndValidate();
      };
      this.$$parseAndValidate = function () {
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = viewValue;
        parserValid = isUndefined(modelValue) ? undefined : true;
        if (parserValid) {
          for (var i = 0; i < ctrl.$parsers.length; i++) {
            modelValue = ctrl.$parsers[i](modelValue);
            if (isUndefined(modelValue)) {
              parserValid = false;
              break;
            }
          }
        }
        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
          ctrl.$modelValue = ngModelGet($scope);
        }
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
        ctrl.$$rawModelValue = modelValue;
        if (allowInvalid) {
          ctrl.$modelValue = modelValue;
          writeToModelIfNeeded();
        }
        ctrl.$$runValidators(
          modelValue,
          ctrl.$$lastCommittedViewValue,
          function (allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          }
        );
        function writeToModelIfNeeded() {
          if (ctrl.$modelValue !== prevModelValue) {
            ctrl.$$writeModelToScope();
          }
        }
      };
      this.$$writeModelToScope = function () {
        ngModelSet($scope, ctrl.$modelValue);
        forEach(ctrl.$viewChangeListeners, function (listener) {
          try {
            listener();
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      };
      this.$setViewValue = function (value, trigger) {
        ctrl.$viewValue = value;
        if (!ctrl.$options || ctrl.$options.updateOnDefault) {
          ctrl.$$debounceViewValueCommit(trigger);
        }
      };
      this.$$debounceViewValueCommit = function (trigger) {
        var debounceDelay = 0,
          options = ctrl.$options,
          debounce;
        if (options && isDefined(options.debounce)) {
          debounce = options.debounce;
          if (isNumber(debounce)) {
            debounceDelay = debounce;
          } else if (isNumber(debounce[trigger])) {
            debounceDelay = debounce[trigger];
          } else if (isNumber(debounce["default"])) {
            debounceDelay = debounce["default"];
          }
        }
        $timeout.cancel(pendingDebounce);
        if (debounceDelay) {
          pendingDebounce = $timeout(function () {
            ctrl.$commitViewValue();
          }, debounceDelay);
        } else if ($rootScope.$$phase) {
          ctrl.$commitViewValue();
        } else {
          $scope.$apply(function () {
            ctrl.$commitViewValue();
          });
        }
      };
      $scope.$watch(function ngModelWatch() {
        var modelValue = ngModelGet($scope);
        if (
          modelValue !== ctrl.$modelValue &&
          (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
        ) {
          ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
          parserValid = undefined;
          var formatters = ctrl.$formatters,
            idx = formatters.length;
          var viewValue = modelValue;
          while (idx--) {
            viewValue = formatters[idx](viewValue);
          }
          if (ctrl.$viewValue !== viewValue) {
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
            ctrl.$render();
            ctrl.$$runValidators(modelValue, viewValue, noop);
          }
        }
        return modelValue;
      });
    },
  ];
  var ngModelDirective = [
    "$rootScope",
    function ($rootScope) {
      return {
        restrict: "A",
        require: ["ngModel", "^?form", "^?ngModelOptions"],
        controller: NgModelController,
        priority: 1,
        compile: function ngModelCompile(element) {
          element
            .addClass(PRISTINE_CLASS)
            .addClass(UNTOUCHED_CLASS)
            .addClass(VALID_CLASS);
          return {
            pre: function ngModelPreLink(scope, element, attr, ctrls) {
              var modelCtrl = ctrls[0],
                formCtrl = ctrls[1] || modelCtrl.$$parentForm;
              modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
              formCtrl.$addControl(modelCtrl);
              attr.$observe("name", function (newValue) {
                if (modelCtrl.$name !== newValue) {
                  modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                }
              });
              scope.$on("$destroy", function () {
                modelCtrl.$$parentForm.$removeControl(modelCtrl);
              });
            },
            post: function ngModelPostLink(scope, element, attr, ctrls) {
              var modelCtrl = ctrls[0];
              if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                element.on(modelCtrl.$options.updateOn, function (ev) {
                  modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                });
              }
              element.on("blur", function (ev) {
                if (modelCtrl.$touched) return;
                if ($rootScope.$$phase) {
                  scope.$evalAsync(modelCtrl.$setTouched);
                } else {
                  scope.$apply(modelCtrl.$setTouched);
                }
              });
            },
          };
        },
      };
    },
  ];
  var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
  var ngModelOptionsDirective = function () {
    return {
      restrict: "A",
      controller: [
        "$scope",
        "$attrs",
        function ($scope, $attrs) {
          var that = this;
          this.$options = copy($scope.$eval($attrs.ngModelOptions));
          if (isDefined(this.$options.updateOn)) {
            this.$options.updateOnDefault = false;
            this.$options.updateOn = trim(
              this.$options.updateOn.replace(DEFAULT_REGEXP, function () {
                that.$options.updateOnDefault = true;
                return " ";
              })
            );
          } else {
            this.$options.updateOnDefault = true;
          }
        },
      ],
    };
  };
  function addSetValidityMethod(context) {
    var ctrl = context.ctrl,
      $element = context.$element,
      classCache = {},
      set = context.set,
      unset = context.unset,
      $animate = context.$animate;
    classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] =
      $element.hasClass(VALID_CLASS));
    ctrl.$setValidity = setValidity;
    function setValidity(validationErrorKey, state, controller) {
      if (isUndefined(state)) {
        createAndSet("$pending", validationErrorKey, controller);
      } else {
        unsetAndCleanup("$pending", validationErrorKey, controller);
      }
      if (!isBoolean(state)) {
        unset(ctrl.$error, validationErrorKey, controller);
        unset(ctrl.$$success, validationErrorKey, controller);
      } else {
        if (state) {
          unset(ctrl.$error, validationErrorKey, controller);
          set(ctrl.$$success, validationErrorKey, controller);
        } else {
          set(ctrl.$error, validationErrorKey, controller);
          unset(ctrl.$$success, validationErrorKey, controller);
        }
      }
      if (ctrl.$pending) {
        cachedToggleClass(PENDING_CLASS, true);
        ctrl.$valid = ctrl.$invalid = undefined;
        toggleValidationCss("", null);
      } else {
        cachedToggleClass(PENDING_CLASS, false);
        ctrl.$valid = isObjectEmpty(ctrl.$error);
        ctrl.$invalid = !ctrl.$valid;
        toggleValidationCss("", ctrl.$valid);
      }
      var combinedState;
      if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
        combinedState = undefined;
      } else if (ctrl.$error[validationErrorKey]) {
        combinedState = false;
      } else if (ctrl.$$success[validationErrorKey]) {
        combinedState = true;
      } else {
        combinedState = null;
      }
      toggleValidationCss(validationErrorKey, combinedState);
      ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
    }
    function createAndSet(name, value, controller) {
      if (!ctrl[name]) {
        ctrl[name] = {};
      }
      set(ctrl[name], value, controller);
    }
    function unsetAndCleanup(name, value, controller) {
      if (ctrl[name]) {
        unset(ctrl[name], value, controller);
      }
      if (isObjectEmpty(ctrl[name])) {
        ctrl[name] = undefined;
      }
    }
    function cachedToggleClass(className, switchValue) {
      if (switchValue && !classCache[className]) {
        $animate.addClass($element, className);
        classCache[className] = true;
      } else if (!switchValue && classCache[className]) {
        $animate.removeClass($element, className);
        classCache[className] = false;
      }
    }
    function toggleValidationCss(validationErrorKey, isValid) {
      validationErrorKey = validationErrorKey
        ? "-" + snake_case(validationErrorKey, "-")
        : "";
      cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
      cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
    }
  }
  function isObjectEmpty(obj) {
    if (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
    }
    return true;
  }
  var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });
  var ngOptionsMinErr = minErr("ngOptions");
  var NG_OPTIONS_REGEXP =
    /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
  var ngOptionsDirective = [
    "$compile",
    "$parse",
    function ($compile, $parse) {
      function parseOptionsExpression(optionsExp, selectElement, scope) {
        var match = optionsExp.match(NG_OPTIONS_REGEXP);
        if (!match) {
          throw ngOptionsMinErr(
            "iexp",
            "Expected expression in form of " +
              "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
              " but got '{0}'. Element: {1}",
            optionsExp,
            startingTag(selectElement)
          );
        }
        var valueName = match[5] || match[7];
        var keyName = match[6];
        var selectAs = / as /.test(match[0]) && match[1];
        var trackBy = match[9];
        var valueFn = $parse(match[2] ? match[1] : valueName);
        var selectAsFn = selectAs && $parse(selectAs);
        var viewValueFn = selectAsFn || valueFn;
        var trackByFn = trackBy && $parse(trackBy);
        var getTrackByValueFn = trackBy
          ? function (value, locals) {
              return trackByFn(scope, locals);
            }
          : function getHashOfValue(value) {
              return hashKey(value);
            };
        var getTrackByValue = function (value, key) {
          return getTrackByValueFn(value, getLocals(value, key));
        };
        var displayFn = $parse(match[2] || match[1]);
        var groupByFn = $parse(match[3] || "");
        var disableWhenFn = $parse(match[4] || "");
        var valuesFn = $parse(match[8]);
        var locals = {};
        var getLocals = keyName
          ? function (value, key) {
              locals[keyName] = key;
              locals[valueName] = value;
              return locals;
            }
          : function (value) {
              locals[valueName] = value;
              return locals;
            };
        function Option(selectValue, viewValue, label, group, disabled) {
          this.selectValue = selectValue;
          this.viewValue = viewValue;
          this.label = label;
          this.group = group;
          this.disabled = disabled;
        }
        function getOptionValuesKeys(optionValues) {
          var optionValuesKeys;
          if (!keyName && isArrayLike(optionValues)) {
            optionValuesKeys = optionValues;
          } else {
            optionValuesKeys = [];
            for (var itemKey in optionValues) {
              if (
                optionValues.hasOwnProperty(itemKey) &&
                itemKey.charAt(0) !== "$"
              ) {
                optionValuesKeys.push(itemKey);
              }
            }
          }
          return optionValuesKeys;
        }
        return {
          trackBy: trackBy,
          getTrackByValue: getTrackByValue,
          getWatchables: $parse(valuesFn, function (optionValues) {
            var watchedArray = [];
            optionValues = optionValues || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
              var key =
                optionValues === optionValuesKeys
                  ? index
                  : optionValuesKeys[index];
              var value = optionValues[key];
              var locals = getLocals(optionValues[key], key);
              var selectValue = getTrackByValueFn(optionValues[key], locals);
              watchedArray.push(selectValue);
              if (match[2] || match[1]) {
                var label = displayFn(scope, locals);
                watchedArray.push(label);
              }
              if (match[4]) {
                var disableWhen = disableWhenFn(scope, locals);
                watchedArray.push(disableWhen);
              }
            }
            return watchedArray;
          }),
          getOptions: function () {
            var optionItems = [];
            var selectValueMap = {};
            var optionValues = valuesFn(scope) || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
              var key =
                optionValues === optionValuesKeys
                  ? index
                  : optionValuesKeys[index];
              var value = optionValues[key];
              var locals = getLocals(value, key);
              var viewValue = viewValueFn(scope, locals);
              var selectValue = getTrackByValueFn(viewValue, locals);
              var label = displayFn(scope, locals);
              var group = groupByFn(scope, locals);
              var disabled = disableWhenFn(scope, locals);
              var optionItem = new Option(
                selectValue,
                viewValue,
                label,
                group,
                disabled
              );
              optionItems.push(optionItem);
              selectValueMap[selectValue] = optionItem;
            }
            return {
              items: optionItems,
              selectValueMap: selectValueMap,
              getOptionFromViewValue: function (value) {
                return selectValueMap[getTrackByValue(value)];
              },
              getViewValueFromOption: function (option) {
                return trackBy
                  ? angular.copy(option.viewValue)
                  : option.viewValue;
              },
            };
          },
        };
      }
      var optionTemplate = document.createElement("option"),
        optGroupTemplate = document.createElement("optgroup");
      function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
        var ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) return;
        var selectCtrl = ctrls[0];
        var multiple = attr.multiple;
        var emptyOption;
        for (
          var i = 0, children = selectElement.children(), ii = children.length;
          i < ii;
          i++
        ) {
          if (children[i].value === "") {
            emptyOption = children.eq(i);
            break;
          }
        }
        var providedEmptyOption = !!emptyOption;
        var unknownOption = jqLite(optionTemplate.cloneNode(false));
        unknownOption.val("?");
        var options;
        var ngOptions = parseOptionsExpression(
          attr.ngOptions,
          selectElement,
          scope
        );
        var renderEmptyOption = function () {
          if (!providedEmptyOption) {
            selectElement.prepend(emptyOption);
          }
          selectElement.val("");
          emptyOption.prop("selected", true);
          emptyOption.attr("selected", true);
        };
        var removeEmptyOption = function () {
          if (!providedEmptyOption) {
            emptyOption.remove();
          }
        };
        var renderUnknownOption = function () {
          selectElement.prepend(unknownOption);
          selectElement.val("?");
          unknownOption.prop("selected", true);
          unknownOption.attr("selected", true);
        };
        var removeUnknownOption = function () {
          unknownOption.remove();
        };
        if (!multiple) {
          selectCtrl.writeValue = function writeNgOptionsValue(value) {
            var option = options.getOptionFromViewValue(value);
            if (option && !option.disabled) {
              if (selectElement[0].value !== option.selectValue) {
                removeUnknownOption();
                removeEmptyOption();
                selectElement[0].value = option.selectValue;
                option.element.selected = true;
              }
              option.element.setAttribute("selected", "selected");
            } else {
              if (value === null || providedEmptyOption) {
                removeUnknownOption();
                renderEmptyOption();
              } else {
                removeEmptyOption();
                renderUnknownOption();
              }
            }
          };
          selectCtrl.readValue = function readNgOptionsValue() {
            var selectedOption = options.selectValueMap[selectElement.val()];
            if (selectedOption && !selectedOption.disabled) {
              removeEmptyOption();
              removeUnknownOption();
              return options.getViewValueFromOption(selectedOption);
            }
            return null;
          };
          if (ngOptions.trackBy) {
            scope.$watch(
              function () {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              },
              function () {
                ngModelCtrl.$render();
              }
            );
          }
        } else {
          ngModelCtrl.$isEmpty = function (value) {
            return !value || value.length === 0;
          };
          selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
            options.items.forEach(function (option) {
              option.element.selected = false;
            });
            if (value) {
              value.forEach(function (item) {
                var option = options.getOptionFromViewValue(item);
                if (option && !option.disabled) option.element.selected = true;
              });
            }
          };
          selectCtrl.readValue = function readNgOptionsMultiple() {
            var selectedValues = selectElement.val() || [],
              selections = [];
            forEach(selectedValues, function (value) {
              var option = options.selectValueMap[value];
              if (option && !option.disabled)
                selections.push(options.getViewValueFromOption(option));
            });
            return selections;
          };
          if (ngOptions.trackBy) {
            scope.$watchCollection(
              function () {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function (value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              },
              function () {
                ngModelCtrl.$render();
              }
            );
          }
        }
        if (providedEmptyOption) {
          emptyOption.remove();
          $compile(emptyOption)(scope);
          emptyOption.removeClass("ng-scope");
        } else {
          emptyOption = jqLite(optionTemplate.cloneNode(false));
        }
        updateOptions();
        scope.$watchCollection(ngOptions.getWatchables, updateOptions);
        function updateOptionElement(option, element) {
          option.element = element;
          element.disabled = option.disabled;
          if (option.label !== element.label) {
            element.label = option.label;
            element.textContent = option.label;
          }
          if (option.value !== element.value)
            element.value = option.selectValue;
        }
        function addOrReuseElement(parent, current, type, templateElement) {
          var element;
          if (current && lowercase(current.nodeName) === type) {
            element = current;
          } else {
            element = templateElement.cloneNode(false);
            if (!current) {
              parent.appendChild(element);
            } else {
              parent.insertBefore(element, current);
            }
          }
          return element;
        }
        function removeExcessElements(current) {
          var next;
          while (current) {
            next = current.nextSibling;
            jqLiteRemove(current);
            current = next;
          }
        }
        function skipEmptyAndUnknownOptions(current) {
          var emptyOption_ = emptyOption && emptyOption[0];
          var unknownOption_ = unknownOption && unknownOption[0];
          if (emptyOption_ || unknownOption_) {
            while (
              current &&
              (current === emptyOption_ ||
                current === unknownOption_ ||
                current.nodeType === NODE_TYPE_COMMENT ||
                (nodeName_(current) === "option" && current.value === ""))
            ) {
              current = current.nextSibling;
            }
          }
          return current;
        }
        function updateOptions() {
          var previousValue = options && selectCtrl.readValue();
          options = ngOptions.getOptions();
          var groupMap = {};
          var currentElement = selectElement[0].firstChild;
          if (providedEmptyOption) {
            selectElement.prepend(emptyOption);
          }
          currentElement = skipEmptyAndUnknownOptions(currentElement);
          options.items.forEach(function updateOption(option) {
            var group;
            var groupElement;
            var optionElement;
            if (option.group) {
              group = groupMap[option.group];
              if (!group) {
                groupElement = addOrReuseElement(
                  selectElement[0],
                  currentElement,
                  "optgroup",
                  optGroupTemplate
                );
                currentElement = groupElement.nextSibling;
                groupElement.label = option.group;
                group = groupMap[option.group] = {
                  groupElement: groupElement,
                  currentOptionElement: groupElement.firstChild,
                };
              }
              optionElement = addOrReuseElement(
                group.groupElement,
                group.currentOptionElement,
                "option",
                optionTemplate
              );
              updateOptionElement(option, optionElement);
              group.currentOptionElement = optionElement.nextSibling;
            } else {
              optionElement = addOrReuseElement(
                selectElement[0],
                currentElement,
                "option",
                optionTemplate
              );
              updateOptionElement(option, optionElement);
              currentElement = optionElement.nextSibling;
            }
          });
          Object.keys(groupMap).forEach(function (key) {
            removeExcessElements(groupMap[key].currentOptionElement);
          });
          removeExcessElements(currentElement);
          ngModelCtrl.$render();
          if (!ngModelCtrl.$isEmpty(previousValue)) {
            var nextValue = selectCtrl.readValue();
            var isNotPrimitive = ngOptions.trackBy || multiple;
            if (
              isNotPrimitive
                ? !equals(previousValue, nextValue)
                : previousValue !== nextValue
            ) {
              ngModelCtrl.$setViewValue(nextValue);
              ngModelCtrl.$render();
            }
          }
        }
      }
      return {
        restrict: "A",
        terminal: true,
        require: ["select", "?ngModel"],
        link: {
          pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
            ctrls[0].registerOption = noop;
          },
          post: ngOptionsPostLink,
        },
      };
    },
  ];
  var ngPluralizeDirective = [
    "$locale",
    "$interpolate",
    "$log",
    function ($locale, $interpolate, $log) {
      var BRACE = /{}/g,
        IS_WHEN = /^when(Minus)?(.+)$/;
      return {
        link: function (scope, element, attr) {
          var numberExp = attr.count,
            whenExp = attr.$attr.when && element.attr(attr.$attr.when),
            offset = attr.offset || 0,
            whens = scope.$eval(whenExp) || {},
            whensExpFns = {},
            startSymbol = $interpolate.startSymbol(),
            endSymbol = $interpolate.endSymbol(),
            braceReplacement =
              startSymbol + numberExp + "-" + offset + endSymbol,
            watchRemover = angular.noop,
            lastCount;
          forEach(attr, function (expression, attributeName) {
            var tmpMatch = IS_WHEN.exec(attributeName);
            if (tmpMatch) {
              var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
              whens[whenKey] = element.attr(attr.$attr[attributeName]);
            }
          });
          forEach(whens, function (expression, key) {
            whensExpFns[key] = $interpolate(
              expression.replace(BRACE, braceReplacement)
            );
          });
          scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
            var count = parseFloat(newVal);
            var countIsNaN = isNaN(count);
            if (!countIsNaN && !(count in whens)) {
              count = $locale.pluralCat(count - offset);
            }
            if (
              count !== lastCount &&
              !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))
            ) {
              watchRemover();
              var whenExpFn = whensExpFns[count];
              if (isUndefined(whenExpFn)) {
                if (newVal != null) {
                  $log.debug(
                    "ngPluralize: no rule defined for '" +
                      count +
                      "' in " +
                      whenExp
                  );
                }
                watchRemover = noop;
                updateElementText();
              } else {
                watchRemover = scope.$watch(whenExpFn, updateElementText);
              }
              lastCount = count;
            }
          });
          function updateElementText(newText) {
            element.text(newText || "");
          }
        },
      };
    },
  ];
  var ngRepeatDirective = [
    "$parse",
    "$animate",
    function ($parse, $animate) {
      var NG_REMOVED = "$$NG_REMOVED";
      var ngRepeatMinErr = minErr("ngRepeat");
      var updateScope = function (
        scope,
        index,
        valueIdentifier,
        value,
        keyIdentifier,
        key,
        arrayLength
      ) {
        scope[valueIdentifier] = value;
        if (keyIdentifier) scope[keyIdentifier] = key;
        scope.$index = index;
        scope.$first = index === 0;
        scope.$last = index === arrayLength - 1;
        scope.$middle = !(scope.$first || scope.$last);
        scope.$odd = !(scope.$even = (index & 1) === 0);
      };
      var getBlockStart = function (block) {
        return block.clone[0];
      };
      var getBlockEnd = function (block) {
        return block.clone[block.clone.length - 1];
      };
      return {
        restrict: "A",
        multiElement: true,
        transclude: "element",
        priority: 1000,
        terminal: true,
        $$tlb: true,
        compile: function ngRepeatCompile($element, $attr) {
          var expression = $attr.ngRepeat;
          var ngRepeatEndComment = document.createComment(
            " end ngRepeat: " + expression + " "
          );
          var match = expression.match(
            /^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/
          );
          if (!match) {
            throw ngRepeatMinErr(
              "iexp",
              "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
              expression
            );
          }
          var lhs = match[1];
          var rhs = match[2];
          var aliasAs = match[3];
          var trackByExp = match[4];
          match = lhs.match(
            /^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/
          );
          if (!match) {
            throw ngRepeatMinErr(
              "iidexp",
              "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
              lhs
            );
          }
          var valueIdentifier = match[3] || match[1];
          var keyIdentifier = match[2];
          if (
            aliasAs &&
            (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
              /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(
                aliasAs
              ))
          ) {
            throw ngRepeatMinErr(
              "badident",
              "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
              aliasAs
            );
          }
          var trackByExpGetter,
            trackByIdExpFn,
            trackByIdArrayFn,
            trackByIdObjFn;
          var hashFnLocals = { $id: hashKey };
          if (trackByExp) {
            trackByExpGetter = $parse(trackByExp);
          } else {
            trackByIdArrayFn = function (key, value) {
              return hashKey(value);
            };
            trackByIdObjFn = function (key) {
              return key;
            };
          }
          return function ngRepeatLink(
            $scope,
            $element,
            $attr,
            ctrl,
            $transclude
          ) {
            if (trackByExpGetter) {
              trackByIdExpFn = function (key, value, index) {
                if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                hashFnLocals[valueIdentifier] = value;
                hashFnLocals.$index = index;
                return trackByExpGetter($scope, hashFnLocals);
              };
            }
            var lastBlockMap = createMap();
            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
              var index,
                length,
                previousNode = $element[0],
                nextNode,
                nextBlockMap = createMap(),
                collectionLength,
                key,
                value,
                trackById,
                trackByIdFn,
                collectionKeys,
                block,
                nextBlockOrder,
                elementsToRemove;
              if (aliasAs) {
                $scope[aliasAs] = collection;
              }
              if (isArrayLike(collection)) {
                collectionKeys = collection;
                trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
              } else {
                trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                collectionKeys = [];
                for (var itemKey in collection) {
                  if (
                    hasOwnProperty.call(collection, itemKey) &&
                    itemKey.charAt(0) !== "$"
                  ) {
                    collectionKeys.push(itemKey);
                  }
                }
              }
              collectionLength = collectionKeys.length;
              nextBlockOrder = new Array(collectionLength);
              for (index = 0; index < collectionLength; index++) {
                key =
                  collection === collectionKeys ? index : collectionKeys[index];
                value = collection[key];
                trackById = trackByIdFn(key, value, index);
                if (lastBlockMap[trackById]) {
                  block = lastBlockMap[trackById];
                  delete lastBlockMap[trackById];
                  nextBlockMap[trackById] = block;
                  nextBlockOrder[index] = block;
                } else if (nextBlockMap[trackById]) {
                  forEach(nextBlockOrder, function (block) {
                    if (block && block.scope) lastBlockMap[block.id] = block;
                  });
                  throw ngRepeatMinErr(
                    "dupes",
                    "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
                    expression,
                    trackById,
                    value
                  );
                } else {
                  nextBlockOrder[index] = {
                    id: trackById,
                    scope: undefined,
                    clone: undefined,
                  };
                  nextBlockMap[trackById] = true;
                }
              }
              for (var blockKey in lastBlockMap) {
                block = lastBlockMap[blockKey];
                elementsToRemove = getBlockNodes(block.clone);
                $animate.leave(elementsToRemove);
                if (elementsToRemove[0].parentNode) {
                  for (
                    index = 0, length = elementsToRemove.length;
                    index < length;
                    index++
                  ) {
                    elementsToRemove[index][NG_REMOVED] = true;
                  }
                }
                block.scope.$destroy();
              }
              for (index = 0; index < collectionLength; index++) {
                key =
                  collection === collectionKeys ? index : collectionKeys[index];
                value = collection[key];
                block = nextBlockOrder[index];
                if (block.scope) {
                  nextNode = previousNode;
                  do {
                    nextNode = nextNode.nextSibling;
                  } while (nextNode && nextNode[NG_REMOVED]);
                  if (getBlockStart(block) != nextNode) {
                    $animate.move(
                      getBlockNodes(block.clone),
                      null,
                      previousNode
                    );
                  }
                  previousNode = getBlockEnd(block);
                  updateScope(
                    block.scope,
                    index,
                    valueIdentifier,
                    value,
                    keyIdentifier,
                    key,
                    collectionLength
                  );
                } else {
                  $transclude(function ngRepeatTransclude(clone, scope) {
                    block.scope = scope;
                    var endNode = ngRepeatEndComment.cloneNode(false);
                    clone[clone.length++] = endNode;
                    $animate.enter(clone, null, previousNode);
                    previousNode = endNode;
                    block.clone = clone;
                    nextBlockMap[block.id] = block;
                    updateScope(
                      block.scope,
                      index,
                      valueIdentifier,
                      value,
                      keyIdentifier,
                      key,
                      collectionLength
                    );
                  });
                }
              }
              lastBlockMap = nextBlockMap;
            });
          };
        },
      };
    },
  ];
  var NG_HIDE_CLASS = "ng-hide";
  var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
  var ngShowDirective = [
    "$animate",
    function ($animate) {
      return {
        restrict: "A",
        multiElement: true,
        link: function (scope, element, attr) {
          scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
            $animate[value ? "removeClass" : "addClass"](
              element,
              NG_HIDE_CLASS,
              { tempClasses: NG_HIDE_IN_PROGRESS_CLASS }
            );
          });
        },
      };
    },
  ];
  var ngHideDirective = [
    "$animate",
    function ($animate) {
      return {
        restrict: "A",
        multiElement: true,
        link: function (scope, element, attr) {
          scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
            $animate[value ? "addClass" : "removeClass"](
              element,
              NG_HIDE_CLASS,
              { tempClasses: NG_HIDE_IN_PROGRESS_CLASS }
            );
          });
        },
      };
    },
  ];
  var ngStyleDirective = ngDirective(function (scope, element, attr) {
    scope.$watch(
      attr.ngStyle,
      function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
          forEach(oldStyles, function (val, style) {
            element.css(style, "");
          });
        }
        if (newStyles) element.css(newStyles);
      },
      true
    );
  });
  var ngSwitchDirective = [
    "$animate",
    function ($animate) {
      return {
        require: "ngSwitch",
        controller: [
          "$scope",
          function ngSwitchController() {
            this.cases = {};
          },
        ],
        link: function (scope, element, attr, ngSwitchController) {
          var watchExpr = attr.ngSwitch || attr.on,
            selectedTranscludes = [],
            selectedElements = [],
            previousLeaveAnimations = [],
            selectedScopes = [];
          var spliceFactory = function (array, index) {
            return function () {
              array.splice(index, 1);
            };
          };
          scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
            var i, ii;
            for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
              $animate.cancel(previousLeaveAnimations[i]);
            }
            previousLeaveAnimations.length = 0;
            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
              var selected = getBlockNodes(selectedElements[i].clone);
              selectedScopes[i].$destroy();
              var promise = (previousLeaveAnimations[i] =
                $animate.leave(selected));
              promise.then(spliceFactory(previousLeaveAnimations, i));
            }
            selectedElements.length = 0;
            selectedScopes.length = 0;
            if (
              (selectedTranscludes =
                ngSwitchController.cases["!" + value] ||
                ngSwitchController.cases["?"])
            ) {
              forEach(selectedTranscludes, function (selectedTransclude) {
                selectedTransclude.transclude(function (
                  caseElement,
                  selectedScope
                ) {
                  selectedScopes.push(selectedScope);
                  var anchor = selectedTransclude.element;
                  caseElement[caseElement.length++] = document.createComment(
                    " end ngSwitchWhen: "
                  );
                  var block = { clone: caseElement };
                  selectedElements.push(block);
                  $animate.enter(caseElement, anchor.parent(), anchor);
                });
              });
            }
          });
        },
      };
    },
  ];
  var ngSwitchWhenDirective = ngDirective({
    transclude: "element",
    priority: 1200,
    require: "^ngSwitch",
    multiElement: true,
    link: function (scope, element, attrs, ctrl, $transclude) {
      ctrl.cases["!" + attrs.ngSwitchWhen] =
        ctrl.cases["!" + attrs.ngSwitchWhen] || [];
      ctrl.cases["!" + attrs.ngSwitchWhen].push({
        transclude: $transclude,
        element: element,
      });
    },
  });
  var ngSwitchDefaultDirective = ngDirective({
    transclude: "element",
    priority: 1200,
    require: "^ngSwitch",
    multiElement: true,
    link: function (scope, element, attr, ctrl, $transclude) {
      ctrl.cases["?"] = ctrl.cases["?"] || [];
      ctrl.cases["?"].push({ transclude: $transclude, element: element });
    },
  });
  var ngTranscludeDirective = ngDirective({
    restrict: "EAC",
    link: function ($scope, $element, $attrs, controller, $transclude) {
      if (!$transclude) {
        throw minErr("ngTransclude")(
          "orphan",
          "Illegal use of ngTransclude directive in the template! " +
            "No parent directive that requires a transclusion found. " +
            "Element: {0}",
          startingTag($element)
        );
      }
      $transclude(function (clone) {
        $element.empty();
        $element.append(clone);
      });
    },
  });
  var scriptDirective = [
    "$templateCache",
    function ($templateCache) {
      return {
        restrict: "E",
        terminal: true,
        compile: function (element, attr) {
          if (attr.type == "text/ng-template") {
            var templateUrl = attr.id,
              text = element[0].text;
            $templateCache.put(templateUrl, text);
          }
        },
      };
    },
  ];
  var noopNgModelController = { $setViewValue: noop, $render: noop };
  function chromeHack(optionElement) {
    if (optionElement[0].hasAttribute("selected")) {
      optionElement[0].selected = true;
    }
  }
  var SelectController = [
    "$element",
    "$scope",
    "$attrs",
    function ($element, $scope, $attrs) {
      var self = this,
        optionsMap = new HashMap();
      self.ngModelCtrl = noopNgModelController;
      self.unknownOption = jqLite(document.createElement("option"));
      self.renderUnknownOption = function (val) {
        var unknownVal = "? " + hashKey(val) + " ?";
        self.unknownOption.val(unknownVal);
        $element.prepend(self.unknownOption);
        $element.val(unknownVal);
      };
      $scope.$on("$destroy", function () {
        self.renderUnknownOption = noop;
      });
      self.removeUnknownOption = function () {
        if (self.unknownOption.parent()) self.unknownOption.remove();
      };
      self.readValue = function readSingleValue() {
        self.removeUnknownOption();
        return $element.val();
      };
      self.writeValue = function writeSingleValue(value) {
        if (self.hasOption(value)) {
          self.removeUnknownOption();
          $element.val(value);
          if (value === "") self.emptyOption.prop("selected", true);
        } else {
          if (value == null && self.emptyOption) {
            self.removeUnknownOption();
            $element.val("");
          } else {
            self.renderUnknownOption(value);
          }
        }
      };
      self.addOption = function (value, element) {
        if (element[0].nodeType === NODE_TYPE_COMMENT) return;
        assertNotHasOwnProperty(value, '"option value"');
        if (value === "") {
          self.emptyOption = element;
        }
        var count = optionsMap.get(value) || 0;
        optionsMap.put(value, count + 1);
        self.ngModelCtrl.$render();
        chromeHack(element);
      };
      self.removeOption = function (value) {
        var count = optionsMap.get(value);
        if (count) {
          if (count === 1) {
            optionsMap.remove(value);
            if (value === "") {
              self.emptyOption = undefined;
            }
          } else {
            optionsMap.put(value, count - 1);
          }
        }
      };
      self.hasOption = function (value) {
        return !!optionsMap.get(value);
      };
      self.registerOption = function (
        optionScope,
        optionElement,
        optionAttrs,
        interpolateValueFn,
        interpolateTextFn
      ) {
        if (interpolateValueFn) {
          var oldVal;
          optionAttrs.$observe(
            "value",
            function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            }
          );
        } else if (interpolateTextFn) {
          optionScope.$watch(
            interpolateTextFn,
            function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set("value", newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            }
          );
        } else {
          self.addOption(optionAttrs.value, optionElement);
        }
        optionElement.on("$destroy", function () {
          self.removeOption(optionAttrs.value);
          self.ngModelCtrl.$render();
        });
      };
    },
  ];
  var selectDirective = function () {
    return {
      restrict: "E",
      require: ["select", "?ngModel"],
      controller: SelectController,
      priority: 1,
      link: { pre: selectPreLink, post: selectPostLink },
    };
    function selectPreLink(scope, element, attr, ctrls) {
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) return;
      var selectCtrl = ctrls[0];
      selectCtrl.ngModelCtrl = ngModelCtrl;
      element.on("change", function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(selectCtrl.readValue());
        });
      });
      if (attr.multiple) {
        selectCtrl.readValue = function readMultipleValue() {
          var array = [];
          forEach(element.find("option"), function (option) {
            if (option.selected) {
              array.push(option.value);
            }
          });
          return array;
        };
        selectCtrl.writeValue = function writeMultipleValue(value) {
          var items = new HashMap(value);
          forEach(element.find("option"), function (option) {
            option.selected = isDefined(items.get(option.value));
          });
        };
        var lastView,
          lastViewRef = NaN;
        scope.$watch(function selectMultipleWatch() {
          if (
            lastViewRef === ngModelCtrl.$viewValue &&
            !equals(lastView, ngModelCtrl.$viewValue)
          ) {
            lastView = shallowCopy(ngModelCtrl.$viewValue);
            ngModelCtrl.$render();
          }
          lastViewRef = ngModelCtrl.$viewValue;
        });
        ngModelCtrl.$isEmpty = function (value) {
          return !value || value.length === 0;
        };
      }
    }
    function selectPostLink(scope, element, attrs, ctrls) {
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) return;
      var selectCtrl = ctrls[0];
      ngModelCtrl.$render = function () {
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
      };
    }
  };
  var optionDirective = [
    "$interpolate",
    function ($interpolate) {
      return {
        restrict: "E",
        priority: 100,
        compile: function (element, attr) {
          if (isDefined(attr.value)) {
            var interpolateValueFn = $interpolate(attr.value, true);
          } else {
            var interpolateTextFn = $interpolate(element.text(), true);
            if (!interpolateTextFn) {
              attr.$set("value", element.text());
            }
          }
          return function (scope, element, attr) {
            var selectCtrlName = "$selectController",
              parent = element.parent(),
              selectCtrl =
                parent.data(selectCtrlName) ||
                parent.parent().data(selectCtrlName);
            if (selectCtrl) {
              selectCtrl.registerOption(
                scope,
                element,
                attr,
                interpolateValueFn,
                interpolateTextFn
              );
            }
          };
        },
      };
    },
  ];
  var styleDirective = valueFn({ restrict: "E", terminal: false });
  var requiredDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        attr.required = true;
        ctrl.$validators.required = function (modelValue, viewValue) {
          return !attr.required || !ctrl.$isEmpty(viewValue);
        };
        attr.$observe("required", function () {
          ctrl.$validate();
        });
      },
    };
  };
  var patternDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var regexp,
          patternExp = attr.ngPattern || attr.pattern;
        attr.$observe("pattern", function (regex) {
          if (isString(regex) && regex.length > 0) {
            regex = new RegExp("^" + regex + "$");
          }
          if (regex && !regex.test) {
            throw minErr("ngPattern")(
              "noregexp",
              "Expected {0} to be a RegExp but was {1}. Element: {2}",
              patternExp,
              regex,
              startingTag(elm)
            );
          }
          regexp = regex || undefined;
          ctrl.$validate();
        });
        ctrl.$validators.pattern = function (modelValue, viewValue) {
          return (
            ctrl.$isEmpty(viewValue) ||
            isUndefined(regexp) ||
            regexp.test(viewValue)
          );
        };
      },
    };
  };
  var maxlengthDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var maxlength = -1;
        attr.$observe("maxlength", function (value) {
          var intVal = toInt(value);
          maxlength = isNaN(intVal) ? -1 : intVal;
          ctrl.$validate();
        });
        ctrl.$validators.maxlength = function (modelValue, viewValue) {
          return (
            maxlength < 0 ||
            ctrl.$isEmpty(viewValue) ||
            viewValue.length <= maxlength
          );
        };
      },
    };
  };
  var minlengthDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var minlength = 0;
        attr.$observe("minlength", function (value) {
          minlength = toInt(value) || 0;
          ctrl.$validate();
        });
        ctrl.$validators.minlength = function (modelValue, viewValue) {
          return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
        };
      },
    };
  };
  if (window.angular.bootstrap) {
    if (window.console) {
      console.log("WARNING: Tried to load angular more than once.");
    }
    return;
  }
  bindJQuery();
  publishExternalAPI(angular);
  angular.module(
    "ngLocale",
    [],
    [
      "$provide",
      function ($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other",
        };
        function getDecimals(n) {
          n = n + "";
          var i = n.indexOf(".");
          return i == -1 ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return { v: v, f: f };
        }
        $provide.value("$locale", {
          DATETIME_FORMATS: {
            AMPMS: ["AM", "PM"],
            DAY: [
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday",
            ],
            ERANAMES: ["Before Christ", "Anno Domini"],
            ERAS: ["BC", "AD"],
            FIRSTDAYOFWEEK: 6,
            MONTH: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
            ],
            SHORTDAY: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            SHORTMONTH: [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
            ],
            STANDALONEMONTH: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
            ],
            WEEKENDRANGE: [5, 6],
            fullDate: "EEEE, MMMM d, y",
            longDate: "MMMM d, y",
            medium: "MMM d, y h:mm:ss a",
            mediumDate: "MMM d, y",
            mediumTime: "h:mm:ss a",
            short: "M/d/yy h:mm a",
            shortDate: "M/d/yy",
            shortTime: "h:mm a",
          },
          NUMBER_FORMATS: {
            CURRENCY_SYM: "$",
            DECIMAL_SEP: ".",
            GROUP_SEP: ",",
            PATTERNS: [
              {
                gSize: 3,
                lgSize: 3,
                maxFrac: 3,
                minFrac: 0,
                minInt: 1,
                negPre: "-",
                negSuf: "",
                posPre: "",
                posSuf: "",
              },
              {
                gSize: 3,
                lgSize: 3,
                maxFrac: 2,
                minFrac: 2,
                minInt: 1,
                negPre: "-\u00a4",
                negSuf: "",
                posPre: "\u00a4",
                posSuf: "",
              },
            ],
          },
          id: "en-us",
          localeID: "en_US",
          pluralCat: function (n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          },
        });
      },
    ]
  );
  jqLite(document).ready(function () {
    angularInit(document, bootstrap);
  });
})(window, document);
!window.angular.$$csp().noInlineStyle &&
  window.angular
    .element(document.head)
    .prepend(
      '<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'
    );
!(function (a, b) {
  if ("function" == typeof define && define.amd)
    define(["module", "exports", "angular"], b);
  else if ("undefined" != typeof exports)
    b(module, exports, require("angular"));
  else {
    var c = { exports: {} };
    b(c, c.exports, a.angular), (a.infiniteScroll = c.exports);
  }
})(this, function (a, b, c) {
  "use strict";
  function d(a) {
    return a && a.__esModule ? a : { default: a };
  }
  Object.defineProperty(b, "__esModule", { value: !0 });
  var e = d(c),
    f = "infinite-scroll";
  e.default
    .module(f, [])
    .value("THROTTLE_MILLISECONDS", null)
    .directive("infiniteScroll", [
      "$rootScope",
      "$window",
      "$interval",
      "THROTTLE_MILLISECONDS",
      function (a, b, c, d) {
        return {
          scope: {
            infiniteScroll: "&",
            infiniteScrollContainer: "=",
            infiniteScrollDistance: "=",
            infiniteScrollDisabled: "=",
            infiniteScrollUseDocumentBottom: "=",
            infiniteScrollListenForEvent: "@",
          },
          link: function (f, g, h) {
            function i(a) {
              var b = a[0] || a;
              return isNaN(b.offsetHeight)
                ? b.document.documentElement.clientHeight
                : b.offsetHeight;
            }
            function j(a) {
              var b = a[0] || a;
              return isNaN(window.pageYOffset)
                ? b.document.documentElement.scrollTop
                : b.ownerDocument.defaultView.pageYOffset;
            }
            function k(a) {
              if (a[0].getBoundingClientRect && !a.css("none"))
                return a[0].getBoundingClientRect().top + j(a);
            }
            function l() {
              var b = void 0,
                d = void 0;
              if (y === u)
                (b = i(y) + j(y[0].document.documentElement)),
                  (d = k(g) + i(g));
              else {
                b = i(y);
                var e = 0;
                void 0 !== k(y) && (e = k(y)), (d = k(g) - e + i(g));
              }
              A &&
                (d = i((g[0].ownerDocument || g[0].document).documentElement));
              var h = d - b,
                l = h <= i(y) * v + 1;
              l
                ? ((x = !0),
                  w &&
                    (f.$$phase || a.$$phase
                      ? f.infiniteScroll()
                      : f.$apply(f.infiniteScroll)))
                : (C && c.cancel(C), (x = !1));
            }
            function m(a, b) {
              function d() {
                return (
                  (g = new Date().getTime()), c.cancel(f), (f = null), a.call()
                );
              }
              function e() {
                var e = new Date().getTime(),
                  h = b - (e - g);
                h <= 0
                  ? (c.cancel(f), (f = null), (g = e), a.call())
                  : f || (f = c(d, h, 1));
              }
              var f = null,
                g = 0;
              return e;
            }
            function n() {
              y.unbind("scroll", D),
                null != B && (B(), (B = null)),
                C && c.cancel(C);
            }
            function o(a) {
              v = parseFloat(a) || 0;
            }
            function p(a) {
              (w = !a), w && x && ((x = !1), D());
            }
            function q(a) {
              A = a;
            }
            function r(a) {
              null != y && y.unbind("scroll", D),
                (y = a),
                null != a && y.bind("scroll", D);
            }
            function s(a) {
              if (null != a && 0 !== a.length) {
                var b = void 0;
                if (
                  ((b =
                    a.nodeType && 1 === a.nodeType
                      ? e.default.element(a)
                      : "function" == typeof a.append
                      ? e.default.element(a[a.length - 1])
                      : "string" == typeof a
                      ? e.default.element(document.querySelector(a))
                      : a),
                  null == b)
                )
                  throw new Error(
                    "invalid infinite-scroll-container attribute."
                  );
                r(b);
              }
            }
            function t() {
              return z && D(), c.cancel(C);
            }
            var u = e.default.element(b),
              v = null,
              w = null,
              x = null,
              y = null,
              z = !0,
              A = !1,
              B = null,
              C = !1,
              D = null != d ? m(l, d) : l;
            return (
              f.$on("$destroy", n),
              f.$watch("infiniteScrollDistance", o),
              o(f.infiniteScrollDistance),
              f.$watch("infiniteScrollDisabled", p),
              p(f.infiniteScrollDisabled),
              f.$watch("infiniteScrollUseDocumentBottom", q),
              q(f.infiniteScrollUseDocumentBottom),
              r(u),
              f.infiniteScrollListenForEvent &&
                (B = a.$on(f.infiniteScrollListenForEvent, D)),
              f.$watch("infiniteScrollContainer", s),
              s(f.infiniteScrollContainer || []),
              null != h.infiniteScrollParent &&
                r(e.default.element(g.parent())),
              null != h.infiniteScrollImmediateCheck &&
                (z = f.$eval(h.infiniteScrollImmediateCheck)),
              (C = c(t))
            );
          },
        };
      },
    ]),
    (b.default = f),
    (a.exports = b.default);
});
angular.element(function () {
  angular.bootstrap(document, ["myApp"]);
});
var myApp = angular.module("myApp", ["infinite-scroll"]);
myApp.config([
  "$interpolateProvider",
  function ($interpolateProvider) {
    $interpolateProvider.startSymbol("[[");
    $interpolateProvider.endSymbol("]]");
  },
]);
var PERSONALIZE_URL = "/india/gift-personalize/BRAND_SEO/";
var brandsListUrl = "/india/gift-brands/list/";
var isNextPage = "True";
var is_paginated = "True";
var selectedCategory = "32";
var searchLogUrl = "/india/brands/search/log/";
var PERSONALIZE_APPEND_SEO_NAME = true;
var GIFT_CARD_MALL_URL = "/india/gift-card-mall/";
!(function (e, t, a, r) {
  "use strict";
  function n(a, r, n, o) {
    function i() {
      (p = t.devicePixelRatio > 1),
        l(n),
        r("delay") >= 0 &&
          setTimeout(function () {
            u(!0);
          }, r("delay")),
        (r("delay") < 0 || r("combined")) &&
          ((o.e = m(r("throttle"), function (e) {
            "resize" === e.type && (b = v = -1), u(e.all);
          })),
          (o.a = function (e) {
            l(e), n.push.apply(n, e);
          }),
          (o.g = function () {
            return (n = e(n).filter(function () {
              return !e(this).data(r("loadedName"));
            }));
          }),
          u(),
          e(r("appendScroll")).on(
            "scroll." + a.name + " resize." + a.name,
            o.e
          ));
    }
    function l(t) {
      if (
        ((t = e(t)
          .filter(function () {
            return (
              !e(this).data(r("handledName")) &&
              (e(this).attr(r("attribute")) ||
                e(this).attr(r("loaderAttribute")))
            );
          })
          .data("plugin_" + a.name, a)),
        r("defaultImage") || r("placeholder"))
      )
        for (var n = 0; n < t.length; n++) {
          var o = e(t[n]),
            i = t[n].tagName.toLowerCase(),
            l = "background-image";
          "img" == i && r("defaultImage") && !o.attr("src")
            ? o.attr("src", r("defaultImage"))
            : "img" == i ||
              !r("placeholder") ||
              (o.css(l) && "none" != o.css(l)) ||
              o.css(l, "url(" + r("placeholder") + ")");
        }
    }
    function u(t) {
      if (!n.length) return void (r("autoDestroy") && a.destroy());
      for (
        var o = !1, i = r("imageBase") ? r("imageBase") : "", l = 0;
        l < n.length;
        l++
      )
        (function (a) {
          if (c(a) || t) {
            var n,
              l = e(a),
              u = a.tagName.toLowerCase(),
              f = l.attr(r("attribute"));
            l.data(r("handledName")) ||
              (r("visibleOnly") && !l.is(":visible")) ||
              !(
                (f &&
                  (("img" == u && i + f != l.attr("src")) ||
                    ("img" != u && i + f != l.css("background-image")))) ||
                (n = l.attr(r("loaderAttribute")))
              ) ||
              ((o = !0), l.data(r("handledName"), !0), d(l, u, i, n));
          }
        })(n[l]);
      o &&
        (n = e(n).filter(function () {
          return !e(this).data(r("handledName"));
        }));
    }
    function d(t, a, n, o) {
      ++h;
      var i = function () {
        A("onError", t), g();
      };
      if ((A("beforeLoad", t), o))
        t.off("error").one("error", i),
          t.one("load", function () {
            r("removeAttribute") && t.removeAttr(r("loaderAttribute")),
              t.data(r("loadedName"), !0),
              A("afterLoad", t),
              g();
          }),
          A(o, t, function (e) {
            e ? t.load() : t.error();
          }) || t.error();
      else {
        var l = e(new Image());
        l.one("error", i),
          l.one("load", function () {
            t.hide(),
              "img" == a
                ? t.attr("src", l.attr("src"))
                : t.css("background-image", "url('" + l.attr("src") + "')"),
              t[r("effect")](r("effectTime")),
              r("removeAttribute") &&
                t.removeAttr(r("attribute") + " " + r("retinaAttribute")),
              t.data(r("loadedName"), !0),
              A("afterLoad", t),
              l.remove(),
              g();
          }),
          l.attr(
            "src",
            n +
              t.attr(
                r(
                  p && t.attr(r("retinaAttribute"))
                    ? "retinaAttribute"
                    : "attribute"
                )
              )
          ),
          l.complete && l.load();
      }
    }
    function c(e) {
      var t = e.getBoundingClientRect(),
        a = r("scrollDirection"),
        n = r("threshold"),
        o = s() + n > t.top && -n < t.bottom,
        i = f() + n > t.left && -n < t.right;
      return "vertical" == a ? o : "horizontal" == a ? i : o && i;
    }
    function f() {
      return b >= 0 ? b : (b = e(t).width());
    }
    function s() {
      return v >= 0 ? v : (v = e(t).height());
    }
    function m(e, t) {
      var n,
        o = 0;
      return function (i, l) {
        function u() {
          (o = +new Date()), t.call(a, i);
        }
        var d = +new Date() - o;
        n && clearTimeout(n),
          d > e || !r("enableThrottle") || l ? u() : (n = setTimeout(u, e - d));
      };
    }
    function g() {
      --h, n.length || h || A("onFinishedAll");
    }
    function A(e, t, n) {
      return (e = r(e)) ? (e.apply(a, [].slice.call(arguments, 1)), !0) : !1;
    }
    var h = 0,
      b = -1,
      v = -1,
      p = !1;
    !(function () {
      "event" == r("bind") ? i() : e(t).on("load." + a.name, i);
    })();
  }
  function o(a, o) {
    var i = this,
      l = e.extend({}, i.configuration, o),
      u = {};
    return (
      (i.config = function (e, t) {
        return t === r ? l[e] : ((l[e] = t), i);
      }),
      (i.addItems = function (t) {
        return u.a && u.a("string" === e.type(t) ? e(t) : t), i;
      }),
      (i.getItems = function () {
        return u.g ? u.g() : {};
      }),
      (i.update = function (e) {
        return u.e && u.e({}, !e), i;
      }),
      (i.loadAll = function () {
        return u.e && u.e({ all: !0 }, !0), i;
      }),
      (i.destroy = function () {
        return (
          e(i.config("appendScroll")).off("." + i.name, u.e),
          e(t).off("." + i.name),
          (u = {}),
          r
        );
      }),
      n(i, i.config, a, u),
      i.config("chainable") ? a : i
    );
  }
  (e.fn.Lazy = e.fn.lazy =
    function (e) {
      return new o(this, e);
    }),
    e.extend(o.prototype, {
      name: "lazy",
      configuration: {
        chainable: !0,
        autoDestroy: !0,
        bind: "load",
        threshold: 500,
        visibleOnly: !1,
        appendScroll: t,
        scrollDirection: "both",
        imageBase: null,
        defaultImage:
          "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",
        placeholder: null,
        delay: -1,
        combined: !1,
        attribute: "data-src",
        retinaAttribute: "data-retina",
        loaderAttribute: "data-loader",
        removeAttribute: !0,
        handledName: "handled",
        loadedName: "loaded",
        effect: "show",
        effectTime: 0,
        enableThrottle: !0,
        throttle: 250,
        beforeLoad: null,
        afterLoad: null,
        onError: null,
        onFinishedAll: null,
      },
    });
})(jQuery, window, document);
(function ($, undefined) {
  "use strict";
  var ver = "3.0.3";
  function debug(s) {
    if ($.fn.cycle.debug) log(s);
  }
  function log() {
    if (window.console && console.log)
      console.log("[cycle] " + Array.prototype.join.call(arguments, " "));
  }
  $.expr[":"].paused = function (el) {
    return el.cyclePause;
  };
  $.fn.cycle = function (options, arg2) {
    var o = { s: this.selector, c: this.context };
    if (this.length === 0 && options != "stop") {
      if (!$.isReady && o.s) {
        log("DOM not ready, queuing slideshow");
        $(function () {
          $(o.s, o.c).cycle(options, arg2);
        });
        return this;
      }
      log(
        "terminating; zero elements found by selector" +
          ($.isReady ? "" : " (DOM not ready)")
      );
      return this;
    }
    return this.each(function () {
      var opts = handleArguments(this, options, arg2);
      if (opts === false) return;
      opts.updateActivePagerLink =
        opts.updateActivePagerLink || $.fn.cycle.updateActivePagerLink;
      if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
      this.cycleTimeout = this.cyclePause = 0;
      this.cycleStop = 0;
      var $cont = $(this);
      var $slides = opts.slideExpr ? $(opts.slideExpr, this) : $cont.children();
      var els = $slides.get();
      if (els.length < 2) {
        log("terminating; too few slides: " + els.length);
        return;
      }
      var opts2 = buildOptions($cont, $slides, els, opts, o);
      if (opts2 === false) return;
      var startTime = opts2.continuous
        ? 10
        : getTimeout(
            els[opts2.currSlide],
            els[opts2.nextSlide],
            opts2,
            !opts2.backwards
          );
      if (startTime) {
        startTime += opts2.delay || 0;
        if (startTime < 10) startTime = 10;
        debug("first timeout: " + startTime);
        this.cycleTimeout = setTimeout(function () {
          go(els, opts2, 0, !opts.backwards);
        }, startTime);
      }
    });
  };
  function triggerPause(cont, byHover, onPager) {
    var opts = $(cont).data("cycle.opts");
    if (!opts) return;
    var paused = !!cont.cyclePause;
    if (paused && opts.paused) opts.paused(cont, opts, byHover, onPager);
    else if (!paused && opts.resumed)
      opts.resumed(cont, opts, byHover, onPager);
  }
  function handleArguments(cont, options, arg2) {
    if (cont.cycleStop === undefined) cont.cycleStop = 0;
    if (options === undefined || options === null) options = {};
    if (options.constructor == String) {
      switch (options) {
        case "destroy":
        case "stop":
          var opts = $(cont).data("cycle.opts");
          if (!opts) return false;
          cont.cycleStop++;
          if (cont.cycleTimeout) clearTimeout(cont.cycleTimeout);
          cont.cycleTimeout = 0;
          if (opts.elements) $(opts.elements).stop();
          $(cont).removeData("cycle.opts");
          if (options == "destroy") destroy(cont, opts);
          return false;
        case "toggle":
          cont.cyclePause = cont.cyclePause === 1 ? 0 : 1;
          checkInstantResume(cont.cyclePause, arg2, cont);
          triggerPause(cont);
          return false;
        case "pause":
          cont.cyclePause = 1;
          triggerPause(cont);
          return false;
        case "resume":
          cont.cyclePause = 0;
          checkInstantResume(false, arg2, cont);
          triggerPause(cont);
          return false;
        case "prev":
        case "next":
          opts = $(cont).data("cycle.opts");
          if (!opts) {
            log('options not found, "prev/next" ignored');
            return false;
          }
          if (typeof arg2 == "string") opts.oneTimeFx = arg2;
          $.fn.cycle[options](opts);
          return false;
        default:
          options = { fx: options };
      }
      return options;
    } else if (options.constructor == Number) {
      var num = options;
      options = $(cont).data("cycle.opts");
      if (!options) {
        log("options not found, can not advance slide");
        return false;
      }
      if (num < 0 || num >= options.elements.length) {
        log("invalid slide index: " + num);
        return false;
      }
      options.nextSlide = num;
      if (cont.cycleTimeout) {
        clearTimeout(cont.cycleTimeout);
        cont.cycleTimeout = 0;
      }
      if (typeof arg2 == "string") options.oneTimeFx = arg2;
      go(options.elements, options, 1, num >= options.currSlide);
      return false;
    }
    return options;
    function checkInstantResume(isPaused, arg2, cont) {
      if (!isPaused && arg2 === true) {
        var options = $(cont).data("cycle.opts");
        if (!options) {
          log("options not found, can not resume");
          return false;
        }
        if (cont.cycleTimeout) {
          clearTimeout(cont.cycleTimeout);
          cont.cycleTimeout = 0;
        }
        go(options.elements, options, 1, !options.backwards);
      }
    }
  }
  function removeFilter(el, opts) {
    if (!$.support.opacity && opts.cleartype && el.style.filter) {
      try {
        el.style.removeAttribute("filter");
      } catch (smother) {}
    }
  }
  function destroy(cont, opts) {
    if (opts.next) $(opts.next).unbind(opts.prevNextEvent);
    if (opts.prev) $(opts.prev).unbind(opts.prevNextEvent);
    if (opts.pager || opts.pagerAnchorBuilder)
      $.each(opts.pagerAnchors || [], function () {
        this.unbind().remove();
      });
    opts.pagerAnchors = null;
    $(cont).unbind("mouseenter.cycle mouseleave.cycle");
    if (opts.destroy) opts.destroy(opts);
  }
  function buildOptions($cont, $slides, els, options, o) {
    var startingSlideSpecified;
    var opts = $.extend(
      {},
      $.fn.cycle.defaults,
      options || {},
      $.metadata ? $cont.metadata() : $.meta ? $cont.data() : {}
    );
    var meta = $.isFunction($cont.data) ? $cont.data(opts.metaAttr) : null;
    if (meta) opts = $.extend(opts, meta);
    if (opts.autostop) opts.countdown = opts.autostopCount || els.length;
    var cont = $cont[0];
    $cont.data("cycle.opts", opts);
    opts.$cont = $cont;
    opts.stopCount = cont.cycleStop;
    opts.elements = els;
    opts.before = opts.before ? [opts.before] : [];
    opts.after = opts.after ? [opts.after] : [];
    if (!$.support.opacity && opts.cleartype)
      opts.after.push(function () {
        removeFilter(this, opts);
      });
    if (opts.continuous)
      opts.after.push(function () {
        go(els, opts, 0, !opts.backwards);
      });
    saveOriginalOpts(opts);
    if (!$.support.opacity && opts.cleartype && !opts.cleartypeNoBg)
      clearTypeFix($slides);
    if ($cont.css("position") == "static") $cont.css("position", "relative");
    if (opts.width) $cont.width(opts.width);
    if (opts.height && opts.height != "auto") $cont.height(opts.height);
    if (opts.startingSlide !== undefined) {
      opts.startingSlide = parseInt(opts.startingSlide, 10);
      if (opts.startingSlide >= els.length || opts.startSlide < 0)
        opts.startingSlide = 0;
      else startingSlideSpecified = true;
    } else if (opts.backwards) opts.startingSlide = els.length - 1;
    else opts.startingSlide = 0;
    if (opts.random) {
      opts.randomMap = [];
      for (var i = 0; i < els.length; i++) opts.randomMap.push(i);
      opts.randomMap.sort(function (a, b) {
        return Math.random() - 0.5;
      });
      if (startingSlideSpecified) {
        for (var cnt = 0; cnt < els.length; cnt++) {
          if (opts.startingSlide == opts.randomMap[cnt]) {
            opts.randomIndex = cnt;
          }
        }
      } else {
        opts.randomIndex = 1;
        opts.startingSlide = opts.randomMap[1];
      }
    } else if (opts.startingSlide >= els.length) opts.startingSlide = 0;
    opts.currSlide = opts.startingSlide || 0;
    var first = opts.startingSlide;
    $slides
      .css({ position: "absolute", top: 0, left: 0 })
      .hide()
      .each(function (i) {
        var z;
        if (opts.backwards)
          z = first
            ? i <= first
              ? els.length + (i - first)
              : first - i
            : els.length - i;
        else
          z = first
            ? i >= first
              ? els.length - (i - first)
              : first - i
            : els.length - i;
        $(this).css("z-index", z);
      });
    $(els[first]).css("opacity", 1).show();
    removeFilter(els[first], opts);
    if (opts.fit) {
      if (!opts.aspect) {
        if (opts.width) $slides.width(opts.width);
        if (opts.height && opts.height != "auto") $slides.height(opts.height);
      } else {
        $slides.each(function () {
          var $slide = $(this);
          var ratio =
            opts.aspect === true
              ? $slide.width() / $slide.height()
              : opts.aspect;
          if (opts.width && $slide.width() != opts.width) {
            $slide.width(opts.width);
            $slide.height(opts.width / ratio);
          }
          if (opts.height && $slide.height() < opts.height) {
            $slide.height(opts.height);
            $slide.width(opts.height * ratio);
          }
        });
      }
    }
    if (opts.center && (!opts.fit || opts.aspect)) {
      $slides.each(function () {
        var $slide = $(this);
        $slide.css({
          "margin-left": opts.width
            ? (opts.width - $slide.width()) / 2 + "px"
            : 0,
          "margin-top": opts.height
            ? (opts.height - $slide.height()) / 2 + "px"
            : 0,
        });
      });
    }
    if (opts.center && !opts.fit && !opts.slideResize) {
      $slides.each(function () {
        var $slide = $(this);
        $slide.css({
          "margin-left": opts.width
            ? (opts.width - $slide.width()) / 2 + "px"
            : 0,
          "margin-top": opts.height
            ? (opts.height - $slide.height()) / 2 + "px"
            : 0,
        });
      });
    }
    var reshape =
      (opts.containerResize || opts.containerResizeHeight) &&
      $cont.innerHeight() < 1;
    if (reshape) {
      var maxw = 0,
        maxh = 0;
      for (var j = 0; j < els.length; j++) {
        var $e = $(els[j]),
          e = $e[0],
          w = $e.outerWidth(),
          h = $e.outerHeight();
        if (!w) w = e.offsetWidth || e.width || $e.attr("width");
        if (!h) h = e.offsetHeight || e.height || $e.attr("height");
        maxw = w > maxw ? w : maxw;
        maxh = h > maxh ? h : maxh;
      }
      if (opts.containerResize && maxw > 0 && maxh > 0)
        $cont.css({ width: maxw + "px", height: maxh + "px" });
      if (opts.containerResizeHeight && maxh > 0)
        $cont.css({ height: maxh + "px" });
    }
    var pauseFlag = false;
    if (opts.pause)
      $cont
        .bind("mouseenter.cycle", function () {
          pauseFlag = true;
          this.cyclePause++;
          triggerPause(cont, true);
        })
        .bind("mouseleave.cycle", function () {
          if (pauseFlag) this.cyclePause--;
          triggerPause(cont, true);
        });
    if (supportMultiTransitions(opts) === false) return false;
    var requeue = false;
    options.requeueAttempts = options.requeueAttempts || 0;
    $slides.each(function () {
      var $el = $(this);
      this.cycleH =
        opts.fit && opts.height
          ? opts.height
          : $el.height() ||
            this.offsetHeight ||
            this.height ||
            $el.attr("height") ||
            0;
      this.cycleW =
        opts.fit && opts.width
          ? opts.width
          : $el.width() ||
            this.offsetWidth ||
            this.width ||
            $el.attr("width") ||
            0;
      if ($el.is("img")) {
        var loading = this.cycleH === 0 && this.cycleW === 0 && !this.complete;
        if (loading) {
          if (
            o.s &&
            opts.requeueOnImageNotLoaded &&
            ++options.requeueAttempts < 100
          ) {
            log(
              options.requeueAttempts,
              " - img slide not loaded, requeuing slideshow: ",
              this.src,
              this.cycleW,
              this.cycleH
            );
            setTimeout(function () {
              $(o.s, o.c).cycle(options);
            }, opts.requeueTimeout);
            requeue = true;
            return false;
          } else {
            log(
              "could not determine size of image: " + this.src,
              this.cycleW,
              this.cycleH
            );
          }
        }
      }
      return true;
    });
    if (requeue) return false;
    opts.cssBefore = opts.cssBefore || {};
    opts.cssAfter = opts.cssAfter || {};
    opts.cssFirst = opts.cssFirst || {};
    opts.animIn = opts.animIn || {};
    opts.animOut = opts.animOut || {};
    $slides.not(":eq(" + first + ")").css(opts.cssBefore);
    $($slides[first]).css(opts.cssFirst);
    if (opts.timeout) {
      opts.timeout = parseInt(opts.timeout, 10);
      if (opts.speed.constructor == String)
        opts.speed = $.fx.speeds[opts.speed] || parseInt(opts.speed, 10);
      if (!opts.sync) opts.speed = opts.speed / 2;
      var buffer = opts.fx == "none" ? 0 : opts.fx == "shuffle" ? 500 : 250;
      while (opts.timeout - opts.speed < buffer) opts.timeout += opts.speed;
    }
    if (opts.easing) opts.easeIn = opts.easeOut = opts.easing;
    if (!opts.speedIn) opts.speedIn = opts.speed;
    if (!opts.speedOut) opts.speedOut = opts.speed;
    opts.slideCount = els.length;
    opts.currSlide = opts.lastSlide = first;
    if (opts.random) {
      if (++opts.randomIndex == els.length) opts.randomIndex = 0;
      opts.nextSlide = opts.randomMap[opts.randomIndex];
    } else if (opts.backwards)
      opts.nextSlide =
        opts.startingSlide === 0 ? els.length - 1 : opts.startingSlide - 1;
    else
      opts.nextSlide =
        opts.startingSlide >= els.length - 1 ? 0 : opts.startingSlide + 1;
    if (!opts.multiFx) {
      var init = $.fn.cycle.transitions[opts.fx];
      if ($.isFunction(init)) init($cont, $slides, opts);
      else if (opts.fx != "custom" && !opts.multiFx) {
        log("unknown transition: " + opts.fx, "; slideshow terminating");
        return false;
      }
    }
    var e0 = $slides[first];
    if (!opts.skipInitializationCallbacks) {
      if (opts.before.length) opts.before[0].apply(e0, [e0, e0, opts, true]);
      if (opts.after.length) opts.after[0].apply(e0, [e0, e0, opts, true]);
    }
    if (opts.next)
      $(opts.next).bind(opts.prevNextEvent, function () {
        return advance(opts, 1);
      });
    if (opts.prev)
      $(opts.prev).bind(opts.prevNextEvent, function () {
        return advance(opts, 0);
      });
    if (opts.pager || opts.pagerAnchorBuilder) buildPager(els, opts);
    exposeAddSlide(opts, els);
    return opts;
  }
  function saveOriginalOpts(opts) {
    opts.original = { before: [], after: [] };
    opts.original.cssBefore = $.extend({}, opts.cssBefore);
    opts.original.cssAfter = $.extend({}, opts.cssAfter);
    opts.original.animIn = $.extend({}, opts.animIn);
    opts.original.animOut = $.extend({}, opts.animOut);
    $.each(opts.before, function () {
      opts.original.before.push(this);
    });
    $.each(opts.after, function () {
      opts.original.after.push(this);
    });
  }
  function supportMultiTransitions(opts) {
    var i,
      tx,
      txs = $.fn.cycle.transitions;
    if (opts.fx.indexOf(",") > 0) {
      opts.multiFx = true;
      opts.fxs = opts.fx.replace(/\s*/g, "").split(",");
      for (i = 0; i < opts.fxs.length; i++) {
        var fx = opts.fxs[i];
        tx = txs[fx];
        if (!tx || !txs.hasOwnProperty(fx) || !$.isFunction(tx)) {
          log("discarding unknown transition: ", fx);
          opts.fxs.splice(i, 1);
          i--;
        }
      }
      if (!opts.fxs.length) {
        log("No valid transitions named; slideshow terminating.");
        return false;
      }
    } else if (opts.fx == "all") {
      opts.multiFx = true;
      opts.fxs = [];
      for (var p in txs) {
        if (txs.hasOwnProperty(p)) {
          tx = txs[p];
          if (txs.hasOwnProperty(p) && $.isFunction(tx)) opts.fxs.push(p);
        }
      }
    }
    if (opts.multiFx && opts.randomizeEffects) {
      var r1 = Math.floor(Math.random() * 20) + 30;
      for (i = 0; i < r1; i++) {
        var r2 = Math.floor(Math.random() * opts.fxs.length);
        opts.fxs.push(opts.fxs.splice(r2, 1)[0]);
      }
      debug("randomized fx sequence: ", opts.fxs);
    }
    return true;
  }
  function exposeAddSlide(opts, els) {
    opts.addSlide = function (newSlide, prepend) {
      var $s = $(newSlide),
        s = $s[0];
      if (!opts.autostopCount) opts.countdown++;
      els[prepend ? "unshift" : "push"](s);
      if (opts.els) opts.els[prepend ? "unshift" : "push"](s);
      opts.slideCount = els.length;
      if (opts.random) {
        opts.randomMap.push(opts.slideCount - 1);
        opts.randomMap.sort(function (a, b) {
          return Math.random() - 0.5;
        });
      }
      $s.css("position", "absolute");
      $s[prepend ? "prependTo" : "appendTo"](opts.$cont);
      if (prepend) {
        opts.currSlide++;
        opts.nextSlide++;
      }
      if (!$.support.opacity && opts.cleartype && !opts.cleartypeNoBg)
        clearTypeFix($s);
      if (opts.fit && opts.width) $s.width(opts.width);
      if (opts.fit && opts.height && opts.height != "auto")
        $s.height(opts.height);
      s.cycleH = opts.fit && opts.height ? opts.height : $s.height();
      s.cycleW = opts.fit && opts.width ? opts.width : $s.width();
      $s.css(opts.cssBefore);
      if (opts.pager || opts.pagerAnchorBuilder)
        $.fn.cycle.createPagerAnchor(
          els.length - 1,
          s,
          $(opts.pager),
          els,
          opts
        );
      if ($.isFunction(opts.onAddSlide)) opts.onAddSlide($s);
      else $s.hide();
    };
  }
  $.fn.cycle.resetState = function (opts, fx) {
    fx = fx || opts.fx;
    opts.before = [];
    opts.after = [];
    opts.cssBefore = $.extend({}, opts.original.cssBefore);
    opts.cssAfter = $.extend({}, opts.original.cssAfter);
    opts.animIn = $.extend({}, opts.original.animIn);
    opts.animOut = $.extend({}, opts.original.animOut);
    opts.fxFn = null;
    $.each(opts.original.before, function () {
      opts.before.push(this);
    });
    $.each(opts.original.after, function () {
      opts.after.push(this);
    });
    var init = $.fn.cycle.transitions[fx];
    if ($.isFunction(init)) init(opts.$cont, $(opts.elements), opts);
  };
  function go(els, opts, manual, fwd) {
    var p = opts.$cont[0],
      curr = els[opts.currSlide],
      next = els[opts.nextSlide];
    if (manual && opts.busy && opts.manualTrump) {
      debug("manualTrump in go(), stopping active transition");
      $(els).stop(true, true);
      opts.busy = 0;
      clearTimeout(p.cycleTimeout);
    }
    if (opts.busy) {
      debug("transition active, ignoring new tx request");
      return;
    }
    if (p.cycleStop != opts.stopCount || (p.cycleTimeout === 0 && !manual))
      return;
    if (
      !manual &&
      !p.cyclePause &&
      !opts.bounce &&
      ((opts.autostop && --opts.countdown <= 0) ||
        (opts.nowrap && !opts.random && opts.nextSlide < opts.currSlide))
    ) {
      if (opts.end) opts.end(opts);
      return;
    }
    var changed = false;
    if ((manual || !p.cyclePause) && opts.nextSlide != opts.currSlide) {
      changed = true;
      var fx = opts.fx;
      curr.cycleH = curr.cycleH || $(curr).height();
      curr.cycleW = curr.cycleW || $(curr).width();
      next.cycleH = next.cycleH || $(next).height();
      next.cycleW = next.cycleW || $(next).width();
      if (opts.multiFx) {
        if (
          fwd &&
          (opts.lastFx === undefined || ++opts.lastFx >= opts.fxs.length)
        )
          opts.lastFx = 0;
        else if (!fwd && (opts.lastFx === undefined || --opts.lastFx < 0))
          opts.lastFx = opts.fxs.length - 1;
        fx = opts.fxs[opts.lastFx];
      }
      if (opts.oneTimeFx) {
        fx = opts.oneTimeFx;
        opts.oneTimeFx = null;
      }
      $.fn.cycle.resetState(opts, fx);
      if (opts.before.length)
        $.each(opts.before, function (i, o) {
          if (p.cycleStop != opts.stopCount) return;
          o.apply(next, [curr, next, opts, fwd]);
        });
      var after = function () {
        opts.busy = 0;
        $.each(opts.after, function (i, o) {
          if (p.cycleStop != opts.stopCount) return;
          o.apply(next, [curr, next, opts, fwd]);
        });
        if (!p.cycleStop) {
          queueNext();
        }
      };
      debug(
        "tx firing(" +
          fx +
          "); currSlide: " +
          opts.currSlide +
          "; nextSlide: " +
          opts.nextSlide
      );
      opts.busy = 1;
      if (opts.fxFn)
        opts.fxFn(curr, next, opts, after, fwd, manual && opts.fastOnEvent);
      else if ($.isFunction($.fn.cycle[opts.fx]))
        $.fn.cycle[opts.fx](
          curr,
          next,
          opts,
          after,
          fwd,
          manual && opts.fastOnEvent
        );
      else
        $.fn.cycle.custom(
          curr,
          next,
          opts,
          after,
          fwd,
          manual && opts.fastOnEvent
        );
    } else {
      queueNext();
    }
    if (changed || opts.nextSlide == opts.currSlide) {
      var roll;
      opts.lastSlide = opts.currSlide;
      if (opts.random) {
        opts.currSlide = opts.nextSlide;
        if (++opts.randomIndex == els.length) {
          opts.randomIndex = 0;
          opts.randomMap.sort(function (a, b) {
            return Math.random() - 0.5;
          });
        }
        opts.nextSlide = opts.randomMap[opts.randomIndex];
        if (opts.nextSlide == opts.currSlide)
          opts.nextSlide =
            opts.currSlide == opts.slideCount - 1 ? 0 : opts.currSlide + 1;
      } else if (opts.backwards) {
        roll = opts.nextSlide - 1 < 0;
        if (roll && opts.bounce) {
          opts.backwards = !opts.backwards;
          opts.nextSlide = 1;
          opts.currSlide = 0;
        } else {
          opts.nextSlide = roll ? els.length - 1 : opts.nextSlide - 1;
          opts.currSlide = roll ? 0 : opts.nextSlide + 1;
        }
      } else {
        roll = opts.nextSlide + 1 == els.length;
        if (roll && opts.bounce) {
          opts.backwards = !opts.backwards;
          opts.nextSlide = els.length - 2;
          opts.currSlide = els.length - 1;
        } else {
          opts.nextSlide = roll ? 0 : opts.nextSlide + 1;
          opts.currSlide = roll ? els.length - 1 : opts.nextSlide - 1;
        }
      }
    }
    if (changed && opts.pager)
      opts.updateActivePagerLink(
        opts.pager,
        opts.currSlide,
        opts.activePagerClass
      );
    function queueNext() {
      var ms = 0,
        timeout = opts.timeout;
      if (opts.timeout && !opts.continuous) {
        ms = getTimeout(els[opts.currSlide], els[opts.nextSlide], opts, fwd);
        if (opts.fx == "shuffle") ms -= opts.speedOut;
      } else if (opts.continuous && p.cyclePause) ms = 10;
      if (ms > 0)
        p.cycleTimeout = setTimeout(function () {
          go(els, opts, 0, !opts.backwards);
        }, ms);
    }
  }
  $.fn.cycle.updateActivePagerLink = function (pager, currSlide, clsName) {
    $(pager).each(function () {
      $(this).children().removeClass(clsName).eq(currSlide).addClass(clsName);
    });
  };
  function getTimeout(curr, next, opts, fwd) {
    if (opts.timeoutFn) {
      var t = opts.timeoutFn.call(curr, curr, next, opts, fwd);
      while (opts.fx != "none" && t - opts.speed < 250) t += opts.speed;
      debug("calculated timeout: " + t + "; speed: " + opts.speed);
      if (t !== false) return t;
    }
    return opts.timeout;
  }
  $.fn.cycle.next = function (opts) {
    advance(opts, 1);
  };
  $.fn.cycle.prev = function (opts) {
    advance(opts, 0);
  };
  function advance(opts, moveForward) {
    var val = moveForward ? 1 : -1;
    var els = opts.elements;
    var p = opts.$cont[0],
      timeout = p.cycleTimeout;
    if (timeout) {
      clearTimeout(timeout);
      p.cycleTimeout = 0;
    }
    if (opts.random && val < 0) {
      opts.randomIndex--;
      if (--opts.randomIndex == -2) opts.randomIndex = els.length - 2;
      else if (opts.randomIndex == -1) opts.randomIndex = els.length - 1;
      opts.nextSlide = opts.randomMap[opts.randomIndex];
    } else if (opts.random) {
      opts.nextSlide = opts.randomMap[opts.randomIndex];
    } else {
      opts.nextSlide = opts.currSlide + val;
      if (opts.nextSlide < 0) {
        if (opts.nowrap) return false;
        opts.nextSlide = els.length - 1;
      } else if (opts.nextSlide >= els.length) {
        if (opts.nowrap) return false;
        opts.nextSlide = 0;
      }
    }
    var cb = opts.onPrevNextEvent || opts.prevNextClick;
    if ($.isFunction(cb)) cb(val > 0, opts.nextSlide, els[opts.nextSlide]);
    go(els, opts, 1, moveForward);
    return false;
  }
  function buildPager(els, opts) {
    var $p = $(opts.pager);
    $.each(els, function (i, o) {
      $.fn.cycle.createPagerAnchor(i, o, $p, els, opts);
    });
    opts.updateActivePagerLink(
      opts.pager,
      opts.startingSlide,
      opts.activePagerClass
    );
  }
  $.fn.cycle.createPagerAnchor = function (i, el, $p, els, opts) {
    var a;
    if ($.isFunction(opts.pagerAnchorBuilder)) {
      a = opts.pagerAnchorBuilder(i, el);
      debug("pagerAnchorBuilder(" + i + ", el) returned: " + a);
    } else a = '<a href="#">' + (i + 1) + "</a>";
    if (!a) return;
    var $a = $(a);
    if ($a.parents("body").length === 0) {
      var arr = [];
      if ($p.length > 1) {
        $p.each(function () {
          var $clone = $a.clone(true);
          $(this).append($clone);
          arr.push($clone[0]);
        });
        $a = $(arr);
      } else {
        $a.appendTo($p);
      }
    }
    opts.pagerAnchors = opts.pagerAnchors || [];
    opts.pagerAnchors.push($a);
    var pagerFn = function (e) {
      e.preventDefault();
      opts.nextSlide = i;
      var p = opts.$cont[0],
        timeout = p.cycleTimeout;
      if (timeout) {
        clearTimeout(timeout);
        p.cycleTimeout = 0;
      }
      var cb = opts.onPagerEvent || opts.pagerClick;
      if ($.isFunction(cb)) cb(opts.nextSlide, els[opts.nextSlide]);
      go(els, opts, 1, opts.currSlide < i);
    };
    if (/mouseenter|mouseover/i.test(opts.pagerEvent)) {
      $a.hover(pagerFn, function () {});
    } else {
      $a.bind(opts.pagerEvent, pagerFn);
    }
    if (!/^click/.test(opts.pagerEvent) && !opts.allowPagerClickBubble)
      $a.bind("click.cycle", function () {
        return false;
      });
    var cont = opts.$cont[0];
    var pauseFlag = false;
    if (opts.pauseOnPagerHover) {
      $a.hover(
        function () {
          pauseFlag = true;
          cont.cyclePause++;
          triggerPause(cont, true, true);
        },
        function () {
          if (pauseFlag) cont.cyclePause--;
          triggerPause(cont, true, true);
        }
      );
    }
  };
  $.fn.cycle.hopsFromLast = function (opts, fwd) {
    var hops,
      l = opts.lastSlide,
      c = opts.currSlide;
    if (fwd) hops = c > l ? c - l : opts.slideCount - l;
    else hops = c < l ? l - c : l + opts.slideCount - c;
    return hops;
  };
  function clearTypeFix($slides) {
    debug("applying clearType background-color hack");
    function hex(s) {
      s = parseInt(s, 10).toString(16);
      return s.length < 2 ? "0" + s : s;
    }
    function getBg(e) {
      for (; e && e.nodeName.toLowerCase() != "html"; e = e.parentNode) {
        var v = $.css(e, "background-color");
        if (v && v.indexOf("rgb") >= 0) {
          var rgb = v.match(/\d+/g);
          return "#" + hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);
        }
        if (v && v != "transparent") return v;
      }
      return "#ffffff";
    }
    $slides.each(function () {
      $(this).css("background-color", getBg(this));
    });
  }
  $.fn.cycle.commonReset = function (curr, next, opts, w, h, rev) {
    $(opts.elements).not(curr).hide();
    if (typeof opts.cssBefore.opacity == "undefined")
      opts.cssBefore.opacity = 1;
    opts.cssBefore.display = "block";
    if (opts.slideResize && w !== false && next.cycleW > 0)
      opts.cssBefore.width = next.cycleW;
    if (opts.slideResize && h !== false && next.cycleH > 0)
      opts.cssBefore.height = next.cycleH;
    opts.cssAfter = opts.cssAfter || {};
    opts.cssAfter.display = "none";
    $(curr).css("zIndex", opts.slideCount + (rev === true ? 1 : 0));
    $(next).css("zIndex", opts.slideCount + (rev === true ? 0 : 1));
  };
  $.fn.cycle.custom = function (curr, next, opts, cb, fwd, speedOverride) {
    var $l = $(curr),
      $n = $(next);
    var speedIn = opts.speedIn,
      speedOut = opts.speedOut,
      easeIn = opts.easeIn,
      easeOut = opts.easeOut,
      animInDelay = opts.animInDelay,
      animOutDelay = opts.animOutDelay;
    $n.css(opts.cssBefore);
    if (speedOverride) {
      if (typeof speedOverride == "number") speedIn = speedOut = speedOverride;
      else speedIn = speedOut = 1;
      easeIn = easeOut = null;
    }
    var fn = function () {
      $n.delay(animInDelay).animate(opts.animIn, speedIn, easeIn, function () {
        cb();
      });
    };
    $l.delay(animOutDelay).animate(
      opts.animOut,
      speedOut,
      easeOut,
      function () {
        $l.css(opts.cssAfter);
        if (!opts.sync) fn();
      }
    );
    if (opts.sync) fn();
  };
  $.fn.cycle.transitions = {
    fade: function ($cont, $slides, opts) {
      $slides.not(":eq(" + opts.currSlide + ")").css("opacity", 0);
      opts.before.push(function (curr, next, opts) {
        $.fn.cycle.commonReset(curr, next, opts);
        opts.cssBefore.opacity = 0;
      });
      opts.animIn = { opacity: 1 };
      opts.animOut = { opacity: 0 };
      opts.cssBefore = { top: 0, left: 0 };
    },
  };
  $.fn.cycle.ver = function () {
    return ver;
  };
  $.fn.cycle.defaults = {
    activePagerClass: "activeSlide",
    after: null,
    allowPagerClickBubble: false,
    animIn: null,
    animInDelay: 0,
    animOut: null,
    animOutDelay: 0,
    aspect: false,
    autostop: 0,
    autostopCount: 0,
    backwards: false,
    before: null,
    center: null,
    cleartype: !$.support.opacity,
    cleartypeNoBg: false,
    containerResize: 1,
    containerResizeHeight: 0,
    continuous: 0,
    cssAfter: null,
    cssBefore: null,
    delay: 0,
    easeIn: null,
    easeOut: null,
    easing: null,
    end: null,
    fastOnEvent: 0,
    fit: 0,
    fx: "fade",
    fxFn: null,
    height: "auto",
    manualTrump: true,
    metaAttr: "cycle",
    next: null,
    nowrap: 0,
    onPagerEvent: null,
    onPrevNextEvent: null,
    pager: null,
    pagerAnchorBuilder: null,
    pagerEvent: "click.cycle",
    pause: 0,
    pauseOnPagerHover: 0,
    prev: null,
    prevNextEvent: "click.cycle",
    random: 0,
    randomizeEffects: 1,
    requeueOnImageNotLoaded: true,
    requeueTimeout: 250,
    rev: 0,
    shuffle: null,
    skipInitializationCallbacks: false,
    slideExpr: null,
    slideResize: 1,
    speed: 1000,
    speedIn: null,
    speedOut: null,
    startingSlide: undefined,
    sync: 1,
    timeout: 4000,
    timeoutFn: null,
    updateActivePagerLink: null,
    width: null,
  };
})(jQuery);
(function ($) {
  "use strict";
  $.fn.cycle.transitions.none = function ($cont, $slides, opts) {
    opts.fxFn = function (curr, next, opts, after) {
      $(next).show();
      $(curr).hide();
      after();
    };
  };
  $.fn.cycle.transitions.fadeout = function ($cont, $slides, opts) {
    $slides
      .not(":eq(" + opts.currSlide + ")")
      .css({ display: "block", opacity: 1 });
    opts.before.push(function (curr, next, opts, w, h, rev) {
      $(curr).css("zIndex", opts.slideCount + (rev !== true ? 1 : 0));
      $(next).css("zIndex", opts.slideCount + (rev !== true ? 0 : 1));
    });
    opts.animIn.opacity = 1;
    opts.animOut.opacity = 0;
    opts.cssBefore.opacity = 1;
    opts.cssBefore.display = "block";
    opts.cssAfter.zIndex = 0;
  };
  $.fn.cycle.transitions.scrollUp = function ($cont, $slides, opts) {
    $cont.css("overflow", "hidden");
    opts.before.push($.fn.cycle.commonReset);
    var h = $cont.height();
    opts.cssBefore.top = h;
    opts.cssBefore.left = 0;
    opts.cssFirst.top = 0;
    opts.animIn.top = 0;
    opts.animOut.top = -h;
  };
  $.fn.cycle.transitions.scrollDown = function ($cont, $slides, opts) {
    $cont.css("overflow", "hidden");
    opts.before.push($.fn.cycle.commonReset);
    var h = $cont.height();
    opts.cssFirst.top = 0;
    opts.cssBefore.top = -h;
    opts.cssBefore.left = 0;
    opts.animIn.top = 0;
    opts.animOut.top = h;
  };
  $.fn.cycle.transitions.scrollLeft = function ($cont, $slides, opts) {
    $cont.css("overflow", "hidden");
    opts.before.push($.fn.cycle.commonReset);
    var w = $cont.width();
    opts.cssFirst.left = 0;
    opts.cssBefore.left = w;
    opts.cssBefore.top = 0;
    opts.animIn.left = 0;
    opts.animOut.left = 0 - w;
  };
  $.fn.cycle.transitions.scrollRight = function ($cont, $slides, opts) {
    $cont.css("overflow", "hidden");
    opts.before.push($.fn.cycle.commonReset);
    var w = $cont.width();
    opts.cssFirst.left = 0;
    opts.cssBefore.left = -w;
    opts.cssBefore.top = 0;
    opts.animIn.left = 0;
    opts.animOut.left = w;
  };
  $.fn.cycle.transitions.scrollHorz = function ($cont, $slides, opts) {
    $cont.css("overflow", "hidden").width();
    opts.before.push(function (curr, next, opts, fwd) {
      if (opts.rev) fwd = !fwd;
      $.fn.cycle.commonReset(curr, next, opts);
      opts.cssBefore.left = fwd ? next.cycleW - 1 : 1 - next.cycleW;
      opts.animOut.left = fwd ? -curr.cycleW : curr.cycleW;
    });
    opts.cssFirst.left = 0;
    opts.cssBefore.top = 0;
    opts.animIn.left = 0;
    opts.animOut.top = 0;
  };
  $.fn.cycle.transitions.scrollVert = function ($cont, $slides, opts) {
    $cont.css("overflow", "hidden");
    opts.before.push(function (curr, next, opts, fwd) {
      if (opts.rev) fwd = !fwd;
      $.fn.cycle.commonReset(curr, next, opts);
      opts.cssBefore.top = fwd ? 1 - next.cycleH : next.cycleH - 1;
      opts.animOut.top = fwd ? curr.cycleH : -curr.cycleH;
    });
    opts.cssFirst.top = 0;
    opts.cssBefore.left = 0;
    opts.animIn.top = 0;
    opts.animOut.left = 0;
  };
  $.fn.cycle.transitions.slideX = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $(opts.elements).not(curr).hide();
      $.fn.cycle.commonReset(curr, next, opts, false, true);
      opts.animIn.width = next.cycleW;
    });
    opts.cssBefore.left = 0;
    opts.cssBefore.top = 0;
    opts.cssBefore.width = 0;
    opts.animIn.width = "show";
    opts.animOut.width = 0;
  };
  $.fn.cycle.transitions.slideY = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $(opts.elements).not(curr).hide();
      $.fn.cycle.commonReset(curr, next, opts, true, false);
      opts.animIn.height = next.cycleH;
    });
    opts.cssBefore.left = 0;
    opts.cssBefore.top = 0;
    opts.cssBefore.height = 0;
    opts.animIn.height = "show";
    opts.animOut.height = 0;
  };
  $.fn.cycle.transitions.shuffle = function ($cont, $slides, opts) {
    var i,
      w = $cont.css("overflow", "visible").width();
    $slides.css({ left: 0, top: 0 });
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, true, true, true);
    });
    if (!opts.speedAdjusted) {
      opts.speed = opts.speed / 2;
      opts.speedAdjusted = true;
    }
    opts.random = 0;
    opts.shuffle = opts.shuffle || { left: -w, top: 15 };
    opts.els = [];
    for (i = 0; i < $slides.length; i++) opts.els.push($slides[i]);
    for (i = 0; i < opts.currSlide; i++) opts.els.push(opts.els.shift());
    opts.fxFn = function (curr, next, opts, cb, fwd) {
      if (opts.rev) fwd = !fwd;
      var $el = fwd ? $(curr) : $(next);
      $(next).css(opts.cssBefore);
      var count = opts.slideCount;
      $el.animate(opts.shuffle, opts.speedIn, opts.easeIn, function () {
        var hops = $.fn.cycle.hopsFromLast(opts, fwd);
        for (var k = 0; k < hops; k++) {
          if (fwd) opts.els.push(opts.els.shift());
          else opts.els.unshift(opts.els.pop());
        }
        if (fwd) {
          for (var i = 0, len = opts.els.length; i < len; i++)
            $(opts.els[i]).css("z-index", len - i + count);
        } else {
          var z = $(curr).css("z-index");
          $el.css("z-index", parseInt(z, 10) + 1 + count);
        }
        $el.animate(
          { left: 0, top: 0 },
          opts.speedOut,
          opts.easeOut,
          function () {
            $(fwd ? this : curr).hide();
            if (cb) cb();
          }
        );
      });
    };
    $.extend(opts.cssBefore, { display: "block", opacity: 1, top: 0, left: 0 });
  };
  $.fn.cycle.transitions.turnUp = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, true, false);
      opts.cssBefore.top = next.cycleH;
      opts.animIn.height = next.cycleH;
      opts.animOut.width = next.cycleW;
    });
    opts.cssFirst.top = 0;
    opts.cssBefore.left = 0;
    opts.cssBefore.height = 0;
    opts.animIn.top = 0;
    opts.animOut.height = 0;
  };
  $.fn.cycle.transitions.turnDown = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, true, false);
      opts.animIn.height = next.cycleH;
      opts.animOut.top = curr.cycleH;
    });
    opts.cssFirst.top = 0;
    opts.cssBefore.left = 0;
    opts.cssBefore.top = 0;
    opts.cssBefore.height = 0;
    opts.animOut.height = 0;
  };
  $.fn.cycle.transitions.turnLeft = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, false, true);
      opts.cssBefore.left = next.cycleW;
      opts.animIn.width = next.cycleW;
    });
    opts.cssBefore.top = 0;
    opts.cssBefore.width = 0;
    opts.animIn.left = 0;
    opts.animOut.width = 0;
  };
  $.fn.cycle.transitions.turnRight = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, false, true);
      opts.animIn.width = next.cycleW;
      opts.animOut.left = curr.cycleW;
    });
    $.extend(opts.cssBefore, { top: 0, left: 0, width: 0 });
    opts.animIn.left = 0;
    opts.animOut.width = 0;
  };
  $.fn.cycle.transitions.zoom = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, false, false, true);
      opts.cssBefore.top = next.cycleH / 2;
      opts.cssBefore.left = next.cycleW / 2;
      $.extend(opts.animIn, {
        top: 0,
        left: 0,
        width: next.cycleW,
        height: next.cycleH,
      });
      $.extend(opts.animOut, {
        width: 0,
        height: 0,
        top: curr.cycleH / 2,
        left: curr.cycleW / 2,
      });
    });
    opts.cssFirst.top = 0;
    opts.cssFirst.left = 0;
    opts.cssBefore.width = 0;
    opts.cssBefore.height = 0;
  };
  $.fn.cycle.transitions.fadeZoom = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, false, false);
      opts.cssBefore.left = next.cycleW / 2;
      opts.cssBefore.top = next.cycleH / 2;
      $.extend(opts.animIn, {
        top: 0,
        left: 0,
        width: next.cycleW,
        height: next.cycleH,
      });
    });
    opts.cssBefore.width = 0;
    opts.cssBefore.height = 0;
    opts.animOut.opacity = 0;
  };
  $.fn.cycle.transitions.blindX = function ($cont, $slides, opts) {
    var w = $cont.css("overflow", "hidden").width();
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts);
      opts.animIn.width = next.cycleW;
      opts.animOut.left = curr.cycleW;
    });
    opts.cssBefore.left = w;
    opts.cssBefore.top = 0;
    opts.animIn.left = 0;
    opts.animOut.left = w;
  };
  $.fn.cycle.transitions.blindY = function ($cont, $slides, opts) {
    var h = $cont.css("overflow", "hidden").height();
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts);
      opts.animIn.height = next.cycleH;
      opts.animOut.top = curr.cycleH;
    });
    opts.cssBefore.top = h;
    opts.cssBefore.left = 0;
    opts.animIn.top = 0;
    opts.animOut.top = h;
  };
  $.fn.cycle.transitions.blindZ = function ($cont, $slides, opts) {
    var h = $cont.css("overflow", "hidden").height();
    var w = $cont.width();
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts);
      opts.animIn.height = next.cycleH;
      opts.animOut.top = curr.cycleH;
    });
    opts.cssBefore.top = h;
    opts.cssBefore.left = w;
    opts.animIn.top = 0;
    opts.animIn.left = 0;
    opts.animOut.top = h;
    opts.animOut.left = w;
  };
  $.fn.cycle.transitions.growX = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, false, true);
      opts.cssBefore.left = this.cycleW / 2;
      opts.animIn.left = 0;
      opts.animIn.width = this.cycleW;
      opts.animOut.left = 0;
    });
    opts.cssBefore.top = 0;
    opts.cssBefore.width = 0;
  };
  $.fn.cycle.transitions.growY = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, true, false);
      opts.cssBefore.top = this.cycleH / 2;
      opts.animIn.top = 0;
      opts.animIn.height = this.cycleH;
      opts.animOut.top = 0;
    });
    opts.cssBefore.height = 0;
    opts.cssBefore.left = 0;
  };
  $.fn.cycle.transitions.curtainX = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, false, true, true);
      opts.cssBefore.left = next.cycleW / 2;
      opts.animIn.left = 0;
      opts.animIn.width = this.cycleW;
      opts.animOut.left = curr.cycleW / 2;
      opts.animOut.width = 0;
    });
    opts.cssBefore.top = 0;
    opts.cssBefore.width = 0;
  };
  $.fn.cycle.transitions.curtainY = function ($cont, $slides, opts) {
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, true, false, true);
      opts.cssBefore.top = next.cycleH / 2;
      opts.animIn.top = 0;
      opts.animIn.height = next.cycleH;
      opts.animOut.top = curr.cycleH / 2;
      opts.animOut.height = 0;
    });
    opts.cssBefore.height = 0;
    opts.cssBefore.left = 0;
  };
  $.fn.cycle.transitions.cover = function ($cont, $slides, opts) {
    var d = opts.direction || "left";
    var w = $cont.css("overflow", "hidden").width();
    var h = $cont.height();
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts);
      opts.cssAfter.display = "";
      if (d == "right") opts.cssBefore.left = -w;
      else if (d == "up") opts.cssBefore.top = h;
      else if (d == "down") opts.cssBefore.top = -h;
      else opts.cssBefore.left = w;
    });
    opts.animIn.left = 0;
    opts.animIn.top = 0;
    opts.cssBefore.top = 0;
    opts.cssBefore.left = 0;
  };
  $.fn.cycle.transitions.uncover = function ($cont, $slides, opts) {
    var d = opts.direction || "left";
    var w = $cont.css("overflow", "hidden").width();
    var h = $cont.height();
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, true, true, true);
      if (d == "right") opts.animOut.left = w;
      else if (d == "up") opts.animOut.top = -h;
      else if (d == "down") opts.animOut.top = h;
      else opts.animOut.left = -w;
    });
    opts.animIn.left = 0;
    opts.animIn.top = 0;
    opts.cssBefore.top = 0;
    opts.cssBefore.left = 0;
  };
  $.fn.cycle.transitions.toss = function ($cont, $slides, opts) {
    var w = $cont.css("overflow", "visible").width();
    var h = $cont.height();
    opts.before.push(function (curr, next, opts) {
      $.fn.cycle.commonReset(curr, next, opts, true, true, true);
      if (!opts.animOut.left && !opts.animOut.top)
        $.extend(opts.animOut, { left: w * 2, top: -h / 2, opacity: 0 });
      else opts.animOut.opacity = 0;
    });
    opts.cssBefore.left = 0;
    opts.cssBefore.top = 0;
    opts.animIn.left = 0;
  };
  $.fn.cycle.transitions.wipe = function ($cont, $slides, opts) {
    var w = $cont.css("overflow", "hidden").width();
    var h = $cont.height();
    opts.cssBefore = opts.cssBefore || {};
    var clip;
    if (opts.clip) {
      if (/l2r/.test(opts.clip)) clip = "rect(0px 0px " + h + "px 0px)";
      else if (/r2l/.test(opts.clip))
        clip = "rect(0px " + w + "px " + h + "px " + w + "px)";
      else if (/t2b/.test(opts.clip)) clip = "rect(0px " + w + "px 0px 0px)";
      else if (/b2t/.test(opts.clip))
        clip = "rect(" + h + "px " + w + "px " + h + "px 0px)";
      else if (/zoom/.test(opts.clip)) {
        var top = parseInt(h / 2, 10);
        var left = parseInt(w / 2, 10);
        clip =
          "rect(" + top + "px " + left + "px " + top + "px " + left + "px)";
      }
    }
    opts.cssBefore.clip =
      opts.cssBefore.clip || clip || "rect(0px 0px 0px 0px)";
    var d = opts.cssBefore.clip.match(/(\d+)/g);
    var t = parseInt(d[0], 10),
      r = parseInt(d[1], 10),
      b = parseInt(d[2], 10),
      l = parseInt(d[3], 10);
    opts.before.push(function (curr, next, opts) {
      if (curr == next) return;
      var $curr = $(curr),
        $next = $(next);
      $.fn.cycle.commonReset(curr, next, opts, true, true, false);
      opts.cssAfter.display = "block";
      var step = 1,
        count = parseInt(opts.speedIn / 13, 10) - 1;
      (function f() {
        var tt = t ? t - parseInt(step * (t / count), 10) : 0;
        var ll = l ? l - parseInt(step * (l / count), 10) : 0;
        var bb = b < h ? b + parseInt(step * ((h - b) / count || 1), 10) : h;
        var rr = r < w ? r + parseInt(step * ((w - r) / count || 1), 10) : w;
        $next.css({
          clip: "rect(" + tt + "px " + rr + "px " + bb + "px " + ll + "px)",
        });
        step++ <= count ? setTimeout(f, 13) : $curr.css("display", "none");
      })();
    });
    $.extend(opts.cssBefore, { display: "block", opacity: 1, top: 0, left: 0 });
    opts.animIn = { left: 0 };
    opts.animOut = { left: 0 };
  };
})(jQuery);
function waysToUseHappyCard() {
  let waysToUseData = { Language: siteLanguage, Platform: sitePlatform };
  clevertap.event.push(clevertap_events.waysToUse, waysToUseData);
  console.log("Clevertap Web waysToUse event pushed");
}
function downloadAppClicked(os) {
  let downloadAppData = {
    "OS selected": os,
    Language: siteLanguage,
    Platform: sitePlatform,
  };
  clevertap.event.push(clevertap_events.downloadApp, downloadAppData);
  console.log("Clevertap Web downloadApp event pushed");
}
$(".close-me").on("click", function () {
  $(".alert_success").addClass("hide");
});
function setup_page() {
  var brands = $(".flip-container");
  brands
    .mouseenter(function () {
      var gallery = $(this).find(".back .slideshow");
      var images = gallery.find(".image");
      var first_loaded = function () {
        gallery.cycle({
          fx: "scrollHorz",
          timeout: 1700,
          speed: 300,
          backwards: false,
        });
      };
      if (images.length > 0) {
        images.each(function (i) {
          var t = $(this);
          $("<img />")
            .attr("src", t.data("src"))
            .load(function () {
              t.removeClass("lazy")
                .css("opacity", 0)
                .css("background-image", 'url("' + t.data("src") + '")')
                .animate({ opacity: 1 }, "fast");
              if (i == 0) first_loaded();
            });
        });
      } else if (gallery.data("cycle.opts") !== undefined) {
        gallery.cycle("resume");
      } else {
        first_loaded();
      }
      first_loaded();
    })
    .mouseleave(function () {
      var gallery = $(this).find(".back .slideshow");
      gallery.cycle("pause");
    });
}
jQuery(document).ready(function ($) {
  $(".lazy").Lazy({
    scrollDirection: "vertical",
    effect: "fadeIn",
    visibleOnly: true,
    onError: function (element) {},
  });
  $(".lazy-init").Lazy({
    scrollDirection: "vertical",
    effect: "fadeIn",
    bind: "event",
    delay: 0,
    onError: function (element) {},
  });
  setup_page();
});
var qryHashUrl = "";
function brand_popup_close() {
  var country_url = "/india/";
}
function brandPopupOpen() {}
// $(".brand-modal").on("show.bs.modal", function (e) {
//   brandPopupOpen();
// });
// $(".brand-modal").on("hide.bs.modal", function (e) {
//   brand_popup_close();
// });
// $("span.icon-close").on("click", function () {
//   brand_popup_close();
// });
myApp.controller("brandListController", [
  "$scope",
  "$timeout",
  "httpService",
  function ($scope, $timeout, httpService) {
    $scope.nextUrl = null;
    $scope.busy = true;
    $scope.pageCount = false;
    $scope.parseQueryString = function (str) {
      var objURL = {};
      str.replace(
        new RegExp("([^?=&]+)(=([^&]*))?", "g"),
        function ($0, $1, $2, $3) {
          objURL[$1] = $3;
        }
      );
      return objURL;
    };
    // $scope.init = function () {
    //   var objSearchQuery = $scope.parseQueryString(window.location.search);
    //   if (objSearchQuery.page == undefined) {
    //     $scope.pageNumber = 1;
    //   } else {
    //     $scope.pageNumber = objSearchQuery.page;
    //   }
    //   if (
    //     objSearchQuery.page != undefined &&
    //     objSearchQuery.page != undefined &&
    //     objSearchQuery.page != 1
    //   ) {
    //     $scope.hideSeeAllBtn = true;
    //     $scope.pageCount = true;
    //   }
    //   var url = brandsListUrl + "?page=2&category=" + selectedCategory;
    //   httpService.ajaxGetRequest(url).then(function (data) {});
    // };
    // if (is_paginated === "True") {
    //   $scope.init();
    // }
    // $scope.seeAllCategoryBrands = function () {
    //   $scope.seeAllBtn = true;
    //   $scope.pageCount = false;
    //   var url = brandsListUrl + "?page=2&category=" + selectedCategory;
    //   httpService.ajaxGetRequest(url).then(function (data) {
    //     if (typeof $scope.brands === "undefined") {
    //       $scope.brands = data.brands;
    //     } else {
    //       $scope.brands = $scope.brands.concat(data.brands);
    //     }
    //     $scope.nextUrl = data.next;
    //     if (data.next) {
    //       $scope.busy = false;
    //     } else {
    //       $scope.busy = true;
    //     }
    //   });
    //   let seeAllBrandsData = {
    //     Store: angular
    //       .element("#countrySelect")
    //       .find("option:selected")
    //       .data("country"),
    //     Language: siteLanguage,
    //     Platform: sitePlatform,
    //   };
    //   clevertap.event.push(clevertap_events.seeAllBrands, seeAllBrandsData);
    //   console.log("Clevertap Web seeAllBrands event pushed");
    // };
    $scope.loadPageBrands = function (event, total, pageIndex) {
      event.preventDefault();
      if ($(event.currentTarget).parent("li").hasClass("selected")) {
        return false;
      }
      angular.element(".overlay-loader").show();
      $scope.hideSeeAllBtn = true;
      $scope.pageCount = true;
      if (pageIndex >= total) {
        angular.element(".paging > li:last").addClass("inactive");
        angular.element(".paging > li:first").removeClass("inactive");
      }
      if (pageIndex <= 1) {
        angular.element(".paging > li:first").addClass("inactive");
        angular.element(".paging > li:last").removeClass("inactive");
        $scope.hideSeeAllBtn = false;
        $scope.pageCount = false;
      }
      if (pageIndex > 1 && pageIndex < total) {
        angular
          .element(".paging > li:first, .paging > li:last")
          .removeClass("inactive");
      }
      $scope.seeAllBtn = false;
      var url =
        brandsListUrl + "?page=" + pageIndex + "&category=" + selectedCategory;
      httpService.ajaxGetRequest(url).then(function (data) {
        angular.element(".brand-item-preloaded").remove();
        angular.element(".paging > li").removeClass("selected");
        $(event.currentTarget).parent("li").addClass("selected");
        $scope.brands = data.brands;
        $scope.nextUrl = null;
        $scope.busy = true;
        $scope.pageNumber = pageIndex;
        window.history.pushState({}, "", "?page=" + pageIndex + "#_scroll_sp");
        angular.element(".overlay-loader").hide();
      });
    };
    $scope.loadPageBrandsNav = function (event, total, nav) {
      if ($(event.currentTarget).parent("li").hasClass("inactive")) {
        return false;
      }
      $scope.hideSeeAllBtn = true;
      $scope.pageCount = true;
      $scope.seeAllBtn = false;
      var objSearchQuery = $scope.parseQueryString(window.location.search);
      if (objSearchQuery.page == undefined) {
        pageIndex = 2;
      } else {
        if (nav == "next") {
          pageIndex = parseInt(objSearchQuery.page) + 1;
          if (pageIndex > total) {
            angular.element(".paging > li:last").addClass("inactive");
            return false;
          } else {
            angular.element(".paging > li:last").removeClass("inactive");
          }
          if (pageIndex >= total) {
            angular.element(".paging > li:last").addClass("inactive");
            angular.element(".paging > li:first").removeClass("inactive");
          }
        } else if (nav == "prev") {
          pageIndex = parseInt(objSearchQuery.page) - 1;
          if (pageIndex < 1) {
            angular.element(".paging > li:first").addClass("inactive");
            return false;
          } else {
            angular.element(".paging > li:first").removeClass("inactive");
          }
          if (pageIndex <= 1) {
            angular.element(".paging > li:first").addClass("inactive");
            angular.element(".paging > li:last").removeClass("inactive");
            $scope.hideSeeAllBtn = false;
            $scope.pageCount = false;
          }
        }
      }
      if (pageIndex > 1 && pageIndex < total) {
        angular
          .element(".paging > li:first, .paging > li:last")
          .removeClass("inactive");
      }
      var url =
        brandsListUrl + "?page=" + pageIndex + "&category=" + selectedCategory;
      httpService.ajaxGetRequest(url).then(function (data) {
        angular.element(".brand-item-preloaded").remove();
        angular.element(".paging > li").removeClass("selected");
        angular.element(".paging > li").eq(pageIndex).addClass("selected");
        $scope.brands = data.brands;
        $scope.nextUrl = null;
        $scope.busy = true;
        $scope.pageNumber = pageIndex;
        window.history.pushState({}, "", "?page=" + pageIndex + "#_scroll_sp");
      });
    };
    window.onpopstate = function (event) {
      if (event) {
        var objSearchQuery = $scope.parseQueryString(window.location.search);
        pageIndex = parseInt(objSearchQuery.page);
        if (pageIndex > 1) {
          $scope.pageCount = true;
          $scope.hideSeeAllBtn = true;
        } else {
          $scope.pageCount = false;
          $scope.seeAllBtn = false;
          $scope.hideSeeAllBtn = false;
        }
        if (objSearchQuery.page == undefined || objSearchQuery.page == 1) {
          $scope.seeAllBtnPosCenter = true;
        } else {
          $scope.seeAllBtnPosCenter = false;
        }
        var url =
          brandsListUrl +
          "?page=" +
          pageIndex +
          "&category=" +
          selectedCategory;
        httpService.ajaxGetRequest(url).then(function (data) {
          angular.element(".brand-item-preloaded").remove();
          angular.element(".paging > li").removeClass("selected");
          angular.element(".paging > li").eq(pageIndex).addClass("selected");
          $scope.brands = data.brands;
          $scope.nextUrl = null;
          $scope.busy = true;
          $scope.pageNumber = pageIndex;
        });
      }
    };
    $scope.initBrand = function (el) {
      $timeout(function () {
        angular.element(el).addClass("visible");
      }, 0);
    };
    $scope.loadMore = function (url) {
      if ($scope.busy) return;
      $scope.busy = true;
      httpService.ajaxGetRequest(url).then(function (data) {
        $scope.brands = $scope.brands.concat(data.brands);
        $scope.nextUrl = data.next;
        if (data.next) {
          $scope.busy = false;
        }
      });
    };
    $scope.searchTrigger = function (event) {
      $scope.noSearchResult = false;
      if ($(event.target).val()) {
        $scope.searchEnabled = true;
      } else {
        $scope.searchEnabled = false;
      }
      if ($(event.target).val() == $scope.searchKey) {
        $scope.searchEnabled = false;
      }
    };
    $scope.brandSearch = function (event, searchKey) {
      $scope.seeAllBtn = true;
      $scope.pageCount = false;
      $scope.brands = [];
      $scope.resultCount = [];
      if (searchKey.length) {
        var url = brandsListUrl + "?q=" + searchKey + "&search=true";
        httpService.ajaxGetRequest(url).then(function (data) {
          angular.element(".brand-item-preloaded").remove();
          angular.element(".see-all-brands").find("button").remove();
          $scope.brands = data.brands;
          $scope.nextUrl = data.next;
          $scope.resultCount = data.count;
          if (data.next) {
            $scope.busy = false;
          } else {
            $scope.busy = true;
          }
          $scope.searchEnabled = false;
          if (!$scope.brands.length) {
            $scope.noSearchResult = true;
          }
          var currLoc = window.location.href;
          var data = {
            search_string: searchKey,
            csrfmiddlewaretoken: Cookies.get("csrftoken"),
            result_count: $scope.resultCount,
            request_data: currLoc,
          };
          httpService.ajaxPostRequest(searchLogUrl, data).then(function (data) {
            if ($scope.brands.length) {
              let searchEventData = {
                Keyword: searchKey,
                "Number of Search Results": $scope.resultCount,
                Store: angular
                  .element("#countrySelect")
                  .find("option:selected")
                  .data("country"),
                Language: siteLanguage,
                Platform: sitePlatform,
              };
              clevertap.event.push(
                clevertap_events.searchEvent,
                searchEventData
              );
              console.log("Clevertap Web searchEvent event pushed");
            }
          });
        });
      } else {
        $scope.clearSearch(event);
      }
    };
    $scope.clearSearch = function (event) {
      $scope.searchKey = "";
      var url = brandsListUrl + "?page=1&category=" + selectedCategory;
      httpService.ajaxGetRequest(url).then(function (data) {
        $scope.brands = data.brands;
        $scope.nextUrl = data.next;
        if (data.next) {
          $scope.busy = false;
        }
      });
    };
    $scope.startSlideshow = function (event) {
      var _this = $(event.currentTarget);
      var gallery = _this.find(".back .slideshow");
      var images = gallery.find(".image");
      var first_loaded = function () {
        gallery.cycle({
          fx: "scrollHorz",
          timeout: 1700,
          speed: 300,
          backwards: false,
        });
      };
      if (images.length > 0) {
        images.each(function (i) {
          var t = $(this);
          $("<img />")
            .attr("src", t.data("src"))
            .load(function () {
              t.removeClass("lazy")
                .css("opacity", 0)
                .css("background-image", 'url("' + t.data("src") + '")')
                .animate({ opacity: 1 }, "fast");
              if (i == 0) first_loaded();
            });
        });
      } else if (gallery.data("cycle.opts") !== undefined) {
        gallery.cycle("resume");
      } else {
        first_loaded();
      }
      first_loaded();
    };
    $scope.stopSlideshow = function (event) {
      var _this = $(event.currentTarget);
      var gallery = _this.find(".back .slideshow");
      gallery.cycle("pause");
    };
    $scope.getRandomIconCls = function () {
      var arrIcons = [
        "xmas_icon1",
        "",
        "xmas_icon2",
        "xmas_icon3",
        "",
        "xmas_icon4",
        "",
        "xmas_icon5",
        "",
        "xmas_icon6",
        "",
        "xmas_icon7",
        "xmas_icon8",
      ];
      return arrIcons[Math.floor(Math.random() * arrIcons.length)];
    };
  },
]);
myApp.factory("httpService", function ($http) {
  return {
    ajaxGetRequest: function (url, data) {
      if (data != undefined) {
        return $http
          .get(url, {
            data: data,
            headers: { "Content-type": "application/json" },
          })
          .then(function (result) {
            return result.data;
          });
      } else {
        return $http
          .get(url, {
            cache: true,
            headers: { "Content-type": "application/json" },
          })
          .then(function (result) {
            return result.data;
          });
      }
    },
    ajaxPostRequest: function (url, params) {
      if (params) {
        return $.post(url, params).done(function (data) {
          return data;
        });
      } else {
        return $.post(url).done(function (data) {
          return data;
        });
      }
    },
    ajaxGetRequestWithParams: function (url, params) {
      return $http
        .get(url, params, { headers: { "Content-type": "application/json" } })
        .then(function (result) {
          return result.data;
        });
    },
  };
});
myApp.directive("loading", [
  "$http",
  function ($http) {
    return {
      restrict: "A",
      link: function (scope, elm, attrs) {
        scope.isLoading = function () {
          return $http.pendingRequests.length > 0;
        };
        scope.$watch(scope.isLoading, function (v) {
          if (v) {
            elm.show();
          } else {
            elm.hide();
          }
        });
      },
    };
  },
]);
myApp.directive("brandInit", function ($compile) {
  return function (scope, element, attrs) {
    scope.initBrand(element);
  };
});
myApp.directive("scrollOnClick", function () {
  return {
    restrict: "A",
    link: function (scope, $elm, attrs) {
      $elm.on("click", function () {
        if (
          !$elm.parent("li").hasClass("inactive") &&
          !$elm.parent("li").hasClass("selected")
        ) {
          $("html, body").animate(
            { scrollTop: $(attrs.goto).offset().top },
            "slow"
          );
        }
      });
    },
  };
});
myApp.directive("brandScroll", function () {
  return {
    link: function (scope, element, attrs) {
      scope.seeAllBtnPosCenter = false;
      if ($(window).scrollTop() > 1000) {
        scope.seeAllBtnPosCenter = true;
      }
      $(window).scroll(function () {
        if ($(window).scrollTop() > 1000) {
          var objSearchQuery = scope.parseQueryString(window.location.search);
          if (objSearchQuery.page == undefined || objSearchQuery.page == 1) {
            scope.seeAllBtnPosCenter = true;
          } else {
            scope.seeAllBtnPosCenter = false;
          }
          scope.$apply();
        }
      });
    },
  };
});
myApp.directive("infinitScroll", function () {
  return {
    link: function (scope, element, attrs) {
      $(window).scroll(function () {
        var distance = attrs.scrollDistance * 1000;
        if (
          !scope.busy &&
          $(window).scrollTop() >=
            $(document).height() - $(window).height() - distance
        ) {
          if (scope.nextUrl) {
            scope.loadMore(scope.nextUrl);
          }
        }
      });
    },
  };
});



var recaptcha_loaded = false;
var forgot_recaptcha_loaded = false;
var ajax_opt_widget_id;
var ajax_forgot_opt_widget_id;



$(document).ready(function () {
  $(".show-pass")
    .off("click")
    .on("click", function () {
      var target = $(this).closest("div").find("input");
      if (target.val() != "") {
        if (target.attr("type") == "text") {
          target.attr("type", "password");
          $(this).html('<span class="icon-eye_active"></span>');
        } else if (target.attr("type") == "password") {
          target.attr("type", "text");
          $(this).html('<span class="icon-eye"></span>');
        }
      }
    });
  $('[name="password"]').keyup(function () {
    if ($(this).val() != "") {
      $(this).closest(".input-group").find(".show-pass").fadeIn();
    } else {
      $(this).closest(".input-group").find(".show-pass").fadeOut();
    }
  });
});

function getUserLocation() {
  response = {};
  $.get(
    "https://ipinfo.io",
    function (response) {
      // if ("geolocation" in navigator) {
      // 	navigator.geolocation.getCurrentPosition(function(position) {
      // 	var x = position.coords.latitude;
      // 	var y = position.coords.longitude;
      $.ajax({
        type: "POST",
        url: "/proxy/user/address/",
        dataType: "json",
        data: JSON.stringify(response),
        contentType: "application/json; charset=utf-8",
        async: false, //add this
      }).done(function (data) {
        var h = 20;
      });
    },
    "jsonp"
  );
  // });
  // };
}
